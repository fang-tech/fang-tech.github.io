<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统内存管理 - Linux虚拟内存管理 | Function's Blog</title><meta name="author" content="Function"><meta name="copyright" content="Function"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虚拟内存管理以问题来引入  申请内存申请到的真的是物理内存吗 对虚拟内存的申请如何转化成对物理内存的访问? top命令输出进程的内存指标中VIRT和RES分别是什么含义 堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么 进程栈和线程栈是一个东西吗 malloc大概是怎么工作的  虚拟内存和物理页为什么要有虚拟内存 用户进程访问内核数据要加以限制 用户进程之间需要隔离 内存不足的时候sw">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统内存管理 - Linux虚拟内存管理">
<meta property="og:url" content="https://fang-tech.github.io/2025/08/04/computer-fundamentals/Operating%20System/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Function&#39;s Blog">
<meta property="og:description" content="虚拟内存管理以问题来引入  申请内存申请到的真的是物理内存吗 对虚拟内存的申请如何转化成对物理内存的访问? top命令输出进程的内存指标中VIRT和RES分别是什么含义 堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么 进程栈和线程栈是一个东西吗 malloc大概是怎么工作的  虚拟内存和物理页为什么要有虚拟内存 用户进程访问内核数据要加以限制 用户进程之间需要隔离 内存不足的时候sw">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg">
<meta property="article:published_time" content="2025-08-04T05:16:26.000Z">
<meta property="article:modified_time" content="2025-08-12T16:34:26.422Z">
<meta property="article:author" content="Function">
<meta property="article:tag" content="Computer Fundamentals">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="Memory">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统内存管理 - Linux虚拟内存管理",
  "url": "https://fang-tech.github.io/2025/08/04/computer-fundamentals/Operating%20System/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/",
  "image": "https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg",
  "datePublished": "2025-08-04T05:16:26.000Z",
  "dateModified": "2025-08-12T16:34:26.422Z",
  "author": [
    {
      "@type": "Person",
      "name": "Function",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><link rel="canonical" href="https://fang-tech.github.io/2025/08/04/computer-fundamentals/Operating%20System/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统内存管理 - Linux虚拟内存管理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> 项目</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Architecture/Distributed-Systems"><i class="fa-fw fa-solid fa-layer-group"></i><span> 分布式架构</span></a></li><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-laptop-code"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-cogs"></i><span> 计算机基础</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm"><i class="fa-fw fas fa-route"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/OS"><i class="fa-fw fas fa-desktop"></i><span> OS</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/Network"><i class="fa-fw fas fa-network-wired"></i><span> 计算机网络</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Function's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统内存管理 - Linux虚拟内存管理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> 项目</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Architecture/Distributed-Systems"><i class="fa-fw fa-solid fa-layer-group"></i><span> 分布式架构</span></a></li><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-laptop-code"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-cogs"></i><span> 计算机基础</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm"><i class="fa-fw fas fa-route"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/OS"><i class="fa-fw fas fa-desktop"></i><span> OS</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/Network"><i class="fa-fw fas fa-network-wired"></i><span> 计算机网络</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统内存管理 - Linux虚拟内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-04T05:16:26.000Z" title="发表于 2025-08-04 13:16:26">2025-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-12T16:34:26.422Z" title="更新于 2025-08-13 00:34:26">2025-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/">Computer Fundamentals</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/OS/">OS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/OS/Memory/">Memory</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><p>以问题来引入</p>
<ol>
<li>申请内存申请到的真的是物理内存吗</li>
<li>对虚拟内存的申请如何转化成对物理内存的访问?</li>
<li>top命令输出进程的内存指标中VIRT和RES分别是什么含义</li>
<li>堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么</li>
<li>进程栈和线程栈是一个东西吗</li>
<li>malloc大概是怎么工作的</li>
</ol>
<h2 id="虚拟内存和物理页"><a href="#虚拟内存和物理页" class="headerlink" title="虚拟内存和物理页"></a>虚拟内存和物理页</h2><h3 id="为什么要有虚拟内存"><a href="#为什么要有虚拟内存" class="headerlink" title="为什么要有虚拟内存"></a>为什么要有虚拟内存</h3><ul>
<li>用户进程访问内核数据要加以限制</li>
<li>用户进程之间需要隔离</li>
<li>内存不足的时候swap到硬盘上, 保证系统可正常运行</li>
</ul>
<h3 id="虚拟地址空间到底是什么"><a href="#虚拟地址空间到底是什么" class="headerlink" title="虚拟地址空间到底是什么"></a>虚拟地址空间到底是什么</h3><p>在内核中的定义, 每个进程的task_struct都有一个核心对象 - mm_struct类型的mm. 代表的就是进程的虚拟地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> 	*<span class="title">mm</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个虚拟内存空间里面, 每一段已经分配出去的地址范围都是通过一个个虚拟内存区域VMA来表示, 也就是对应到内核中的数据结构vm_area_struct</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中vm_start和vm_end就是使用了的虚拟地址范围的开始和结尾</p>
<p>通过一个个的vm_area_struct就组成了这个进程已经分配出去的地址范围, 加起来就是对整个虚拟地址空间的占用情况. 内核会保证vm_area_struct的范围之间不会有交叉的情况出现</p>
<p>内存访问的过程中, 需要经常查找虚拟地址和某个vm_area_strcut的对应关系. 所以我们需要合适的数据结构来组织多个vm_area_strcut</p>
<p>在Linux6.1之前, 使用的是红黑树来提供logn的查询效率, 双链表来提高高效遍历效率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struuct</span> *<span class="title">mmap</span>;</span></span><br><span class="line">    <span class="comment">// 红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_mm_rb</span>;</span></span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案最明显的缺陷就是随着现在的服务器上的核数越来越多, 多线程情况下锁争抢问题. 需要加锁的原因是红黑树的平衡操作牵扯到多个节点, 以及修改需要同步到双向链表. 所以这两个数据结构都需要加锁修改.</p>
<p>在Linux6.1以后, 对VMA管理换成了maple tree. 是按照RCU无锁编程方式来实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">maple_tree</span> <span class="title">mm_mt</span>;</span></span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// file:include/linux/maple_tree.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">maple_tree</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line">     <span class="type">void</span> __rcu *ma_root;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> ma_flags; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250804165552.png"></p>
<h3 id="什么时候分配的物理页"><a href="#什么时候分配的物理页" class="headerlink" title="什么时候分配的物理页"></a>什么时候分配的物理页</h3><p>这个其实是个老生常谈的话题, 也是面试常考的问题, 答案就是是在触发缺页中断的时候, 但是这里我们将深入到Linux在触发中断以后的调用的具体的函数和涉及到的具体的数据结构来看</p>
<p>当进程在运行的过程中, 在栈上开始分配和访问变量的时候, 如果物理页还没有分配,这个时候就会触发缺页中断. 在中断处理函数中来真正分配物理内存</p>
<p>内存缺页中断的核心处理入口<code>do_user_addr_fault(unsigned long address)</code>函数</p>
<ol>
<li><code>vma = find_vma(mm, address)</code>: 根据新的addr来找到对应的vma</li>
<li><code>fault = handle_mm_fault(mm, vma, address, flags)</code>调用<code>handle_mm_fault</code>函数来真正地分配物理内存申请</li>
</ol>
<blockquote>
<p>find_vma(mm, address)</p>
<p>这个函数会优先尝试从vmacache中获取, 这是软件层面的cache, 由进程持有,  每个进程有自己VMA缓存, 缓存的内容是最近访问VMA. 下面的两个遍历操作, 都是在缓存没有命中的时候进行的</p>
</blockquote>
<p>在Linux6.1以前, 因为mm_struct中的vm_area_struct是通过红黑树和双向链表组织起来的, find_vma的实现是通过遍历VMA双向链表, 找到满足vm_start &lt;&#x3D; vma &lt;&#x3D; vm_end的VMA并返回()</p>
<p>在6.1及以后, 组织VMA的数据结构也变成了maple_tree, find_vma也就变成了调用maple tree的查找函数mas_walk来查询了</p>
<p><strong>在find_vma找到了正确的vma以后, 就进入到了真正的物理内存的分配, 会依次调用handle_mm_fault-&gt;__handle_mm_fault来完成物理内存分配</strong></p>
<blockquote>
<p>__handle_mm_fault(vma, addr…)</p>
</blockquote>
<p>首先要介绍在现在的64位的cpu下, 四级的虚拟内存页表</p>
<ul>
<li>一级页表: Page Global Dir, 简称 pgd</li>
<li>二级页表: Page Upper Dir, 简称pud</li>
<li>三级页表: Page Mid Dir, 简称pmd</li>
<li>四级页表: Page Table, 简称pte</li>
</ul>
<p>在<code>__handle_mm_fault(vma, addr...)</code>中</p>
<ol>
<li>依次查看或申请每一级的页表项</li>
<li>完成对页表的处理以后, 在<code>handle_pte_fault(vm_fault)</code>中进入到<code>do_anoymous_page</code>中进行处理</li>
<li>在<code>do_anonymous_page</code>中调用<code>alloc_zeroed_user_highpage_movable</code>分配一个可移动的匿名物理页出来, 在底层会调用伙伴系统的<code>alloc_pages</code>进行实际物理页面的分配</li>
</ol>
<blockquote>
<p><code>handle_pte_fault(vm_fault)</code>会处理很多种内存缺页处理, 比如文件映射缺页处理, swap缺页处理, 写时复制缺页处理, 匿名映射页缺页处理等情况. 开发者申请的变量内存对应的是匿名映射页处理, 会进入到do_anonymous_page</p>
</blockquote>
<blockquote>
<p>内核是用伙伴系统来管理所有的物理页的 其他的模块需要物理页的时候都会调用伙伴系统对外提供的函数来申请物理内存</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p> 申请内存申请到的真的是物理内存吗</p>
</blockquote>
<p>申请的时候实际上只会申请VMA, 真正的物理内存是等到访问的时候触发缺页中断, 再调用alloc_pages从伙伴系统中申请</p>
<p>进程的堆栈的物理内存分配时间也是同样的, 创建进程的时候新进程的栈内存分配的也只是一段地址空间范围</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250804231842.png"></p>
<blockquote>
<p>top命令输出进程的内存指标中VIRT和RES分别是什么含义</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250804232548.png"></p>
<p>VIRT就是进程使用的虚拟内存的大小, RES就是进程实际申请的物理内存的大小</p>
<h2 id="虚拟内存使用方式"><a href="#虚拟内存使用方式" class="headerlink" title="虚拟内存使用方式"></a>虚拟内存使用方式</h2><p>整个进程的运行过程中, 几乎都是在围绕着对虚拟内存的分配和使用而进行的, 具体的使用方式主要有三种</p>
<p>第一类是操作系统加载程序时在加载逻辑里对新进程的虚拟内存的设置和使用</p>
<ul>
<li>程序启动时, 加载程序会将程序代码段, 数据段通过mmap映射到虚拟地址空间中</li>
<li>对新进程初始化栈区和堆区</li>
</ul>
<p>第二类是程序运行期间动态地对所存储各种数据进行申请和释放. 涉及到栈, 进程线程运行时函数调用, 存储局部变量使用到的都是栈</p>
<p>第三类是堆, 各种开发语言运行时通过new, malloc等函数就是从堆中分配内存. 这类内存申请和释放需要依赖操作系统提供的关系虚拟地址空间相关的mmap, brk等系统调用来实现.</p>
<h3 id="进程启动时对虚拟内存的使用"><a href="#进程启动时对虚拟内存的使用" class="headerlink" title="进程启动时对虚拟内存的使用"></a>进程启动时对虚拟内存的使用</h3><p>在进程加载完毕以后, 在解析完ELF文件信息以后</p>
<ul>
<li>为进程创建新的地址空间, 同时为其准备一个默认大小4KB的栈</li>
<li>将可执行文件以及它所依赖的各种动态链接so库通过elf_map函数映射到虚拟地址空间中</li>
<li>对堆区进行初始化</li>
</ul>
<p>在程序加载启动成功以后, 在进程的地址空间中的代码段, 数据段设置完毕, 堆, 栈也都准备好了</p>
<p>底层实现上, 上面四者在底层都是对应一个个的vm_area_struct对象, 每一个vma都表示这段虚拟内存空间已经被分配和使用了</p>
<blockquote>
<p>对于栈的申请</p>
</blockquote>
<p>是在<code>execve</code>依次调用<code>do_execve_common</code>, <code>bprm_mm_init</code>, 最后在<code>__bprm_mm_init</code>中申请的vma对象</p>
<blockquote>
<p>对于可执行文件以及进程所依赖的各种so动态链接库</p>
</blockquote>
<p><code>execve</code>时依次调用<code>do_execve_common</code>, <code>search_binary_handler</code>, <code>load_elf_binary</code>, <code>elf_map</code>, 调用<code>mmap_region</code>申请vm_area_struct对象, 最终将可执行文件中的代码段, 数据段等映射到内存中</p>
<blockquote>
<p>对于堆内存</p>
</blockquote>
<p>在<code>load_elf_binary</code>的最后<code>set_brk</code>初始化堆的时候, 依次调用<code>vm_brk_flags</code>, 最后成功申请vma对象</p>
<p>可以使用<code>cat/proc/&lt;pid&gt;/maps</code>来查看进程的虚拟地址空间概要</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>这个系统调用是虚拟内存管理中提供的最接近底层调用, 也是最常用的mmap. 可以用于文件映射和匿名映射, 这里我们忽略文件映射. </p>
<blockquote>
<p>匿名映射这个名字有一些的迷惑性, 实际上是文件映射有文件, 而匿名映射没有对应的物理文件, 直接叫普通内存地址空间会更容易理解</p>
</blockquote>
<p>匿名映射的过程实际上就是向内核申请一段可用的内存地址范围而已, 非常简单. 也就是调用了mmap以后, 内核就会多申请一个vm_area_struct出来. 表示这段内存可用, 然后返回给用户.</p>
<p>mmap的调用逻辑比较深, <code>mmap </code>&#x3D;&gt; <code>ksts_mmap_pgoff </code>&#x3D;&gt; <code>vm_mmap_pgoff </code>&#x3D;&gt; <code>do_mmap_pgoff</code> &#x3D;&gt; <code>do_mmap </code>&#x3D;&gt; <code>mmap_region</code>. 最关键的就是最后的mmap_region</p>
<p>在这个位置会申请新的vm_area_struct, 并对其初始化(初始化vm_start和vm_end), 最后返回addr, 也就是虚拟地址的起始位置</p>
<p>这个时候用户申请的虚拟空间就申请好了, 用户就可以使用了.</p>
<h3 id="sbrk-brk"><a href="#sbrk-brk" class="headerlink" title="sbrk&#x2F;brk"></a>sbrk&#x2F;brk</h3><p>在set_brk中会先为数据段申请虚拟内存, 然后初始化堆区的指针, mm_struct-&gt;brk &#x3D; end(这里的end是数据段的末尾)</p>
<p>从set_brk开始, 依次调用到do_brk_flags的时候申请堆区内存(也就是申请了vma), 然后初始化mm中和堆区相关的值, brk指向的就是堆区的终止地址, start_brk指向堆区的起始地址(也就是数据段的末尾)</p>
<ul>
<li>sbrk系统调用: 返回mm_struct-&gt;brk的指针值</li>
<li>brk系统调用: 修改mm_struct-&gt;brk的指针值<ul>
<li>往大了改就是加大堆区</li>
<li>往小了改就是缩小堆区</li>
</ul>
</li>
</ul>
<h2 id="进程栈内存的使用"><a href="#进程栈内存的使用" class="headerlink" title="进程栈内存的使用"></a>进程栈内存的使用</h2><blockquote>
<p>从问题开始</p>
<ol>
<li>进程栈的大小限制是多少</li>
<li>栈限制的大小可以调整吗, 可以的话怎么调整</li>
<li>栈溢出以后会发生什么</li>
</ol>
</blockquote>
<h3 id="进程栈的初始化"><a href="#进程栈的初始化" class="headerlink" title="进程栈的初始化"></a>进程栈的初始化</h3><p>加载系统调用<code>execve</code>依次调用<code>do_execve_common</code>,  </p>
<ul>
<li>在<code>bprm_mm_init</code>的时候申请一个全新的地址空间mm_struct对象, 准备给新的进程使用.</li>
<li>申请完地址空间以后, 调用<code>__bprm_mm_init</code>为新进程的栈申请一页大小的虚拟内存空间, 作为给新进程准备的栈内存. 申请完以后, 把栈的指针(<code>vma-&gt;vm_end - sizeof(void *)</code>)保存到bprm-&gt;p中记录起来</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bprm-&gt;vma = vma = vm_area_alloc(mm);</span><br><span class="line">vma-&gt;vm_end = STACK_TOP_MAX;</span><br><span class="line">vma-&gt;vm_start = vma-&gt;vm_end - PAGE_SIZE;</span><br><span class="line">...</span><br><span class="line">bprm-&gt;p = vma-&gt;vm_end - <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br></pre></td></tr></table></figure>

<p>接下来进程加载过程会使用<code>load_elf_binary</code>真正开始加载可执行二进制程序. 在加载时把前面的进程栈的地址空间指针设置到新进程mm对象上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br></pre></td></tr></table></figure>

<p>这个时候, 新的进程就能使用进程栈内存了</p>
<h3 id="栈的自动增长"><a href="#栈的自动增长" class="headerlink" title="栈的自动增长"></a>栈的自动增长</h3><p>随着进程的运行, 进程的栈空间超过4KB是难免的问题, 这个时候进程的栈空间就需要增长</p>
<p>首先会进入到缺页处理函数里面<code>__do_page_fault</code>, 然后会进入到处理用户进程的缺页异常处理函数<code>do_user_addr_fault</code></p>
<blockquote>
<p>do_user_addr_fault</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/mm/fault.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_user_addr_fault</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> error_code,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">   	...</span><br><span class="line">     <span class="comment">// 如果vma的start比addr小, 说明现在使用的栈地址是在栈的范围内的, 不需要额外申请虚拟地址 (vma的start指向低地址)</span></span><br><span class="line">	<span class="keyword">if</span> (likely(vma-&gt;vm_start &lt;= address))</span><br><span class="line">		<span class="keyword">goto</span> good_area;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// vma的开始地址比addr大, 说明需要额外申请虚拟内存空间</span></span><br><span class="line">    <span class="comment">// 通过判断VM_GROWDOWN来判断可不可以动态扩张</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) &#123;</span><br><span class="line">		bad_area(regs, error_code, address);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行栈的动态扩张</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(expand_stack(vma, address))) &#123;</span><br><span class="line">		bad_area(regs, error_code, address);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, we have a good vm_area for this memory access, so</span></span><br><span class="line"><span class="comment">	 * we can handle it..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">good_area:</span><br><span class="line">	...</span><br><span class="line">    fault = handle_mm_fault(vma, address, flags, regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>__do_page_fault</code>实际上是之前版本的缺页处理函数, 在6.1已经更名为<code>handle_page_fault</code>, 这里为了和前面以及市面上广泛的教材保持一致, 使用前者</p>
</blockquote>
<p>栈一般是向下的增长的, 如果vma-&gt;start &gt; addr表示栈不够用了, 这个时候就需要调用expand_stack进行扩张</p>
<blockquote>
<p>其实在Linux栈地址空间增长是分成两种的, 一种是从高地址往低地址增长, 一种是反过来. 大部分情况都是由高往低增长. 这里只以向下增长为例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/mmap.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expand_stack</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> expand_downwards(vma, address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">expand_downwards</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 计算扩张以后的栈的大小</span></span><br><span class="line">    size = vma-&gt;vm_end - address;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算需要扩张的页面数量</span></span><br><span class="line">	grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 校验能否扩张</span></span><br><span class="line">	error = acct_stack_growth(vma, size, grow);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改vm_start, 开始扩张</span></span><br><span class="line">	vma-&gt;vm_start = address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数进行了两个运算</p>
<ol>
<li>计算出来扩张以后栈的大小. <code>size = vma-&gt;vm_end - address;</code></li>
<li>计算需要扩张以后的页面数量. <code>grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;</code></li>
</ol>
<p>扩充的操作就是简单粗暴的修改vm_start就行</p>
<p>接下来看到acct_stack_growth进行了哪些限制判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/mmap.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">acct_stack_growth</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">			     <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">unsigned</span> <span class="type">long</span> grow)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查地址空间是否超过限制 */</span></span><br><span class="line">	<span class="keyword">if</span> (!may_expand_vm(mm, vma-&gt;vm_flags, grow))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检测是否超出栈的大小限制 */</span></span><br><span class="line">	<span class="keyword">if</span> (size &gt; rlimit(RLIMIT_STACK))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acct_stack_growth主要进行了两个判断</p>
<ul>
<li>may_expand_vm判断的是增长完这几个页以后, 是否超出整体虚拟地址空间大小的限制</li>
<li>rlimit判断是否超出栈的大小限制</li>
</ul>
<p>后者栈的大小限制, 能通过命令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -a</span></span><br><span class="line">...</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br></pre></td></tr></table></figure>

<p>也能通过命令来修改</p>
<ul>
<li>重启后会丢失</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s &lt;new_size&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启后不会丢失</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 添加下面这行</span></span><br><span class="line">* soft stack &lt;new_size&gt;</span><br></pre></td></tr></table></figure>

<h2 id="线程栈是怎么使用内存的"><a href="#线程栈是怎么使用内存的" class="headerlink" title="线程栈是怎么使用内存的"></a>线程栈是怎么使用内存的</h2><p>在Linux内核里面其实并没有线程这个概念, 内核原生的clone系统调用只是支持生成一个和父进程共享地址空间等资源的轻量级进程而已</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250806163352.png"></p>
<p>Linux的线程包含了两部分的实现</p>
<ul>
<li>第一部分是用户态的glibc库, 创建线程的时候调用的pthread_create就是在glibc实现的, glibc完全是用户态运行的, 不是内核源码</li>
<li>内核态的clone系统调用, 内核通过clone系统调用可以创建出来和父进程共享地址空间的轻量级用户进程</li>
</ul>
<h3 id="glibc的线程对象"><a href="#glibc的线程对象" class="headerlink" title="glibc的线程对象"></a>glibc的线程对象</h3><p>线程包括了内核态和用户态的两部分的实现, 所对应的资源也是同样的分成了两部分, 一部分是内核资源, 例如代表轻量级进程的内核对象task_struct, 另一部分就是用户态的资源, 包含线程栈. 在C语言glibc中的实现中, 用户资源这一部分的核心的数据结构就是pthread. 存储了线程的相关信息, 包含了线程栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:nptl/descr.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pid_t</span> tid;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="comment">// 线程栈内存</span></span><br><span class="line">    <span class="type">void</span> *stackblock;</span><br><span class="line">    <span class="type">size_t</span> stackblock_size; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>tid对象存储了线程的ID值</li>
<li>stackblock指向了线程栈内存</li>
<li>stackblock_size表明栈的内存区域大小</li>
</ul>
<h3 id="线程栈的创建"><a href="#线程栈的创建" class="headerlink" title="线程栈的创建"></a>线程栈的创建</h3><p><code>pthread_create</code>的调用路径是<code>__pthread_create_2_1</code> -&gt; <code>create_thread</code></p>
<blockquote>
<p>create_thread</p>
</blockquote>
<ol>
<li>定义线程对象 pthread</li>
<li>执行<code>ALLOCATE_STACK</code><ol>
<li>确定栈空间的大小</li>
<li>申请用户栈内存</li>
</ol>
</li>
<li>创建用户进程</li>
</ol>
<p>ALLOCATE_STACK是一个宏, 最后会调用到<code>allocate_stack</code>函数</p>
<blockquote>
<p>allocate_stack</p>
</blockquote>
<ol>
<li>确定栈空间大小: <code>size = attr-&gt;stacksize ?: __default_stacksize;</code>如果用户创建线程的时候指定了栈的大小, 就会使用用户指定的大小, 如果没有指定, 就会使用默认的大小</li>
</ol>
<blockquote>
<p>在<code>__pthread_initialize_minimal_internal</code>中会为__default_stacksize这个变量赋值, 逻辑是</p>
<ul>
<li>如果ulimit没有配置或者配置的是无限大, 那么大小就是ARCH_STACK_DEFAULT_SIZE （32<br>MB）</li>
<li>如果用户配置的太小了, 可能会导致程序无法正常运行,  glibc也给了一个PTHREAD_STACK_MIN (16384B)</li>
<li>在ulimit配置合理的情况下, 会将配置数值对齐一下就会使用了</li>
</ul>
</blockquote>
<ol start="2">
<li>确定完栈空间大小以后, 就要执行栈空间的申请了<ol>
<li>首先尝试通过<code>get_cached_stack</code>获取一块缓存直接用</li>
<li>假设没有取到缓存, 就使用<code>mmap</code>系统调用直接申请一块匿名页内存空间</li>
<li>将pthread对象放到栈上</li>
<li>将栈添加到全局在用栈的链表中管理起来</li>
</ol>
</li>
</ol>
<blockquote>
<p>通过这里的我们能发现, 线程栈是不能伸缩的, 并没有想进程栈一样, 提供了伸缩的函数, 和判断进程栈是不是用超了的逻辑, 所以线程栈要是用超了, 就要开始报错了</p>
</blockquote>
<p>在栈申请好以后, 在create_thread中调用do_clone系统调用开始创建</p>
<p>glibc中的每个线程在结束阶段都会执行一个公共操作, 释放掉那些已结束线程的栈空间, 从stack_used移除, 放入到stack_cache中, 相当于析构函数</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>进程栈和线程栈式一个东西吗</p>
</blockquote>
<p>进程栈</p>
<ul>
<li>持有的资源是完完全全的内核态的资源, </li>
<li>在创建进程的时候完成初始化, </li>
<li>默认是4KB, </li>
<li>在访问栈内存的时候会执行expand_stack自动扩容, 有向下和向上两种扩容逻辑</li>
</ul>
<p>而Linux中glibc中的线程库是nptl线程, 包含了两部分的资源</p>
<ul>
<li>第一部分是内核态中的task_struct, 地址空间等内核对象. </li>
<li>另一部分就是用户态的管理用户的线程对象的pthread, </li>
<li>申请的栈内存最大32MB, 最小16384B, 可以在创建线程的时候指定大小, </li>
<li>不能动态伸缩</li>
<li>同时维护了全局链表stack_used和stack_cache, 结束的线程会做将栈内存从stack_used中移除, 添加到stack_cache中, 创建线程的时候会优先尝试从stack_cache中获取</li>
</ul>
<p>进程的栈默认是进程使用的, 线程是不能使用进程的栈的, 所以才需要额外的线程的的栈内存</p>
<p>glibc中的每个线程在结束阶段都会执行一个公共操作, 释放掉那些已结束线程的栈空间, 从stack_used移除, 放入到stack_cache中, 相当于析构函数</p>
<blockquote>
<p>堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么</p>
</blockquote>
<p>进程的栈, 默认是4KB, 线程栈最小是16438B, 最大不超过32MB, 默认是ulimit -a中的栈的配置的大小, 栈溢出以后因为访问了没有申请的内存, 会发生Segmentation fault</p>
<blockquote>
<p>进程栈的大小限制是多少</p>
</blockquote>
<p>进程栈最大大小通过ulimit -a中的stack size来限制</p>
<blockquote>
<p>栈限制的大小可以调整吗, 可以的话怎么调整</p>
</blockquote>
<p>通过 ulimit -s &lt;size&gt;和修改 &#x2F;etc&#x2F;security&#x2F;limits.conf文件来调整</p>
<h2 id="malloc堆内存分配原理"><a href="#malloc堆内存分配原理" class="headerlink" title="malloc堆内存分配原理"></a>malloc堆内存分配原理</h2><p>如果只是使用裸的系统调用来使用和分配内存, 很容易出现的问题就是内部和外部的内存碎片, 同时每次申请内存都需要进入到内核态执行系统调用, 开销很大</p>
<p>所以我们需要一个任意大小内存块管理的机制. 内存管理器的核心机制都是类似的. 都是预先向操作系统申请一些内存</p>
<ul>
<li>当我们申请内存的时候, 直接由分配器从预先申请好的内存池里申请</li>
<li>释放内存的时候, 分配器会将这些内存管理起来, 通过一些策略来判断是否要将其回收给操作系统</li>
</ul>
<h3 id="malloc-chunk-最小内存分配单位"><a href="#malloc-chunk-最小内存分配单位" class="headerlink" title="malloc_chunk: 最小内存分配单位"></a>malloc_chunk: 最小内存分配单位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:malloc/malloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">	INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">	INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的内容字段实际上是malloc_chunk的header部分, 实际申请的内存是紧接着header的后面的. 这种机制使malloc_chunk非常的灵活.</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250806234122.png"></p>
<h3 id="ptmalloc-内存分配器"><a href="#ptmalloc-内存分配器" class="headerlink" title="ptmalloc: 内存分配器"></a>ptmalloc: 内存分配器</h3><p>每次调用malloc申请内存的时候, 分配器都会给我们分配一个chunk出来, 并把body部分的user data地址返回给用户程序</p>
<p>chunk如果还没有分配出去, 或者通过free释放的话. 内存实际上并不会归还给内核. 而是glibc又组织起来</p>
<h4 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h4><p>ptmalloc的第一个单元其实并不是malloc_chunk而是malloc_state, 可以简单的将一个malloc_state看作是一个内存池</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:malloc/malloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">// 锁, 用来解决在多线程分配时的竞争问题</span></span><br><span class="line">    <span class="type">mutex_t</span> mutex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配区下管理内存的各种数据结构</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Linked List</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最开始的版本的malloc是使用全局锁来保证多线程竞争情况下的安全性, 但是一个全局锁导致竞争严重, 无法有效利用多核CPU, 于是分配器抽象出来了一个Arena的概念, 一个Arena就相当一个内存池, 只有使用同一个Arena的线程之间要竞争锁. </p>
<blockquote>
<p>什么时候创建Arena?</p>
</blockquote>
<p>在程序启动的时候会创建一个main_arena.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: malloc/malloc.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在后续多线程调用malloc的时候</p>
<ol>
<li>尝试get空闲的arena, 如果没有尝试创建</li>
<li>同时没有空闲的arena, 创建失败, 或者因为arena数量已经达到上限了, 无法创建arena, 这个时候才会出现多个线程之间复用一个arena然后出现malloc的锁竞争问题</li>
</ol>
<h4 id="分配区下管理内存的数据结构"><a href="#分配区下管理内存的数据结构" class="headerlink" title="分配区下管理内存的数据结构"></a>分配区下管理内存的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...;</span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里剩下的就是和管理内存的相关的最核心的数据结构</p>
<p> glibc会将相似大小的空闲chunk都串起来, 这样下次用户再来分配的时候, 找到链表就可以快速分配. 这样的一个链表被称为一个bin</p>
<blockquote>
<p>fastbins: 用于管理小块的内存, 用来支持小内存的快速申请</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250807002417.png"></p>
<blockquote>
<p>unsorted bins, small bins, large bins</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250807002353.png"></p>
<blockquote>
<p>unsorted bins</p>
</blockquote>
<p>在将内存free的时候, 并不会直接将chunk放到对应的bin上, 而是会先统一地放到unsorted bins上, unsorted bins相当于bins的缓冲区</p>
<blockquote>
<p>small bins, large bins</p>
</blockquote>
<p>分别管理32~1008B的chunk和大于1024B的chunk</p>
<p>从地址空间的视角来看, 堆中的内存基本上是由一个又一个chunk组成的, 其中有个特殊的chunk是Top chunk, 它是所有没有申请了的但是没有被分配的内存的集合</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250807003207.png"></p>
<h3 id="malloc的工作过程"><a href="#malloc的工作过程" class="headerlink" title="malloc的工作过程"></a>malloc的工作过程</h3><p>申请内存步骤</p>
<ol>
<li>对用户请求的内存规范化, 对齐到32, 48, 64等字节数</li>
<li><strong>fast bin 申请</strong>: 如果申请的字节数小于fastbin管理的内存块的最大字节数, 则尝试从fastbin中获取, 申请成功则返回. 用于快速处理频繁的小内存管理</li>
<li><strong>small bin 申请</strong>: 尝试从small bins中申请内存, 申请成功返回, 处理32 - 1008之间大小的内存块的申请</li>
<li><strong>unsorted bin 申请</strong>: 尝试从unsorted bins中申请内存, 成功则返回. 这里是为了首先将free时回收的内存利用起来, 顺带地会把chunk往small large里面整理</li>
<li><strong>unsorted bin 申请</strong>: 尝试从unsorted bins中申请内存, 成功则返回. 这里是为了处理1024以上的大内存块的申请</li>
<li><strong>top chunk 申请</strong>: 前面的申请都没有成功,尝试从top chunk中申请</li>
<li><strong>从操作系统中申请</strong>: 最后的兜底解决方法就是向操作系统中申请</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Computer-Fundamentals/">Computer Fundamentals</a><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/Memory/">Memory</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/09/computer-fundamentals/Operating%20System/Linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux物理内存篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">操作系统内存管理 - Linux物理内存篇</div></div><div class="info-2"><div class="info-item-1">Linux物理内存物理内存检测在物理内存这个硬件和操作系统之间, 还存在着一个固件层(firmware)也叫BIOS. 它负责硬件自检, 初始化所有硬件设备, 加载操作系统引导程序, 将控制权移交给操作系统并提供结构供操作系统读取硬件信息. 操作系统所需的内存等硬件信息都是通过固件来获取的 在固件ACPI接口规范中定义了探测内存的物理分布规范. 内核请求中断15H , 并设置操作码为E820H,  因为操作码是E820, 所以这个机制也被称为E820 会在detect_memory_e820函数发出15号中断并处理所有结果, 把内存地址范围保存到boot_params.e820_table对象中. boot_params只是一个中间数据, 专门还有一个e820_table全局数据结构来保存内存地址范围, 在e820__memory_setup中会将boot_params.e820_table保存到e820_table中, 并打印出来. 服务器能通过mseg命令来查看到实际的物理内存地址. memblock内存分配器的创建在完成了E820机制检测到可用的内存地址范围以后, 调用e8...</div></div></div></a><a class="pagination-related" href="/2025/08/02/computer-fundamentals/Network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="计网-深入理解三次握手的实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">计网-深入理解三次握手的实现原理</div></div><div class="info-2"><div class="info-item-1">三次握手的内部实现原理 不同于八股中简单的对三次握手的流程的介绍, 本文会从在Linux中使用socket建立TCP连接完成的工作的角度深度剖析三次握手 参考:  深入理解Linux网络： 修炼底层内功，掌握高性能原理 (张彦飞)   使用Socket通信的过程 123456// 客户端的核心代码int main()&#123;	int fd = socket(AF_INET, SOCK_STREAM, 0);    connect(fd, ....);    ....&#125;  12345678// 服务端的核心代码int main() &#123;    int fd = socket(AF_INET, SOCK_STREAM, 0);    bind(fd, ...);    listen(fd, 128);    accept(fd, ...);    ...&#125;  socket函数的作用从开发者的角度我们调用socket函数, 创建一个socket, 然后返回一个句柄用于访问和操作我们这个创建的socket. 从内核的角度来看, 调用这个函数会在内核内部创建...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/09/computer-fundamentals/Operating%20System/Linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux物理内存篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-09</div><div class="info-item-2">操作系统内存管理 - Linux物理内存篇</div></div><div class="info-2"><div class="info-item-1">Linux物理内存物理内存检测在物理内存这个硬件和操作系统之间, 还存在着一个固件层(firmware)也叫BIOS. 它负责硬件自检, 初始化所有硬件设备, 加载操作系统引导程序, 将控制权移交给操作系统并提供结构供操作系统读取硬件信息. 操作系统所需的内存等硬件信息都是通过固件来获取的 在固件ACPI接口规范中定义了探测内存的物理分布规范. 内核请求中断15H , 并设置操作码为E820H,  因为操作码是E820, 所以这个机制也被称为E820 会在detect_memory_e820函数发出15号中断并处理所有结果, 把内存地址范围保存到boot_params.e820_table对象中. boot_params只是一个中间数据, 专门还有一个e820_table全局数据结构来保存内存地址范围, 在e820__memory_setup中会将boot_params.e820_table保存到e820_table中, 并打印出来. 服务器能通过mseg命令来查看到实际的物理内存地址. memblock内存分配器的创建在完成了E820机制检测到可用的内存地址范围以后, 调用e8...</div></div></div></a><a class="pagination-related" href="/2025/07/25/computer-fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="操作系统I&#x2F;O - 多路复用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">操作系统I&#x2F;O - 多路复用</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O-多路复用多路复用是解决的什么问题解决的最根本的问题是: 我们怎么让我们的服务器能并发处理更多的数量的请求 最经典的问题就是C10K问题: 服务器怎么并发处理1w个请求 解决这个问题我们就需要考虑到, 连接占用的资源有哪些  文件描述符: Socket实际上是一个虚拟的文件, 也就对应着有相应的文件描述符, 在Linux中一个进程能打开的文件描述符的数量是有限的, 一般来说是1024(默认值) 系统内存: 每个TCP连接在内核中都有对应的数据结构, 也就是每个连接都占用了一定的内存  在这些基础上, 我们该怎么实现并发处理1w个请求呢?  多进程模型?  我们每成功建立一个连接就创建一个进程, 这个时候因为fork()创建的子进程中的文件描述符也是被继承过去, 让子进程来通过已连接Socket来提供服务 但是这种方式很明显是不能解决C10K问题的, 没有哪个系统扛得住创建1W个进程, 并且进程间切换的成本很高, 性能很差  多线程模型  为了解决多进程模型中, 进程的体量很大并且切换成本高的问题, 我们换成多线程模型 当服务器与客户端 TCP 完成连接后，通过 p...</div></div></div></a><a class="pagination-related" href="/2025/07/25/computer-fundamentals/Operating%20System/IO-%E9%9B%B6%E6%8B%B7%E8%B4%9D/" title="操作系统I&#x2F;O - 零拷贝"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">操作系统I&#x2F;O - 零拷贝</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O的演进DMA技术在最开始的时候, 读一个文件的过程是   用户进程调用read(), 切换到内核态, CPU向磁盘发起IO请求 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信号给CPU CPU将数据从磁盘数据控制器缓冲区中拷贝到 PageCache CPU将数据从PageCache中拷贝到用户缓冲区 read()调用返回, 切换到用户态  一共发生了两次用户态和内核态的上下文切换, 发生了两次拷贝, 并且数据的搬运也是交给CPU来操作的, 占用了大量的CPU的时间, 导致了CPU吞吐量下降 解决方式就是引入了DMA(Direct Memory Access)直接内存访问技术,  我们将把数据从磁盘控制器缓冲区搬运到PageCache的工作交给了DMA控制器来进行  现在的读一个文件的流程变成了  用户进程调用read(), 切换到内核态, 向操作系统发起IO请求, 将数据读取到自己的内存缓冲区中, 进程进入到了阻塞状态 CPU收到操作系统发送的指令以后, 将请求发送给DMA, DMA再进一步发送给磁盘 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信...</div></div></div></a><a class="pagination-related" href="/2025/08/12/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="操作系统进程管理-Linux进程与线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-12</div><div class="info-item-2">操作系统进程管理-Linux进程与线程</div></div><div class="info-2"><div class="info-item-1">进程与线程进程的创建fork函数是linux中创建进程的核心函数, fork的原意是叉子, 也就是分叉. fork调用是程序执行的一个分叉点, 从这里开始, 原本的一个执行流变成了两个独立的执行流 创建的子进程继承了父进程的资源  打开的文件描述符 文件系统信息 …  创建的子进程在创建的时候是和父进程一样的内存空间, 会将父进程的地址空间也就是页表复制, 并复制所有的VMA, 但是标记为只读, 在修改的时候会触发page fault, 分配新的物理页, 复制数据, 更新页表项为可写 值得一提的是这里的继承和复制都是深拷贝, 也就是会将fs_struct, mm_struct, file_struct等资源都是深拷贝, 这里虽然是继承过去了, 但是实际上已经和父进程的资源是隔离的了, 只是在最开始的时候数据是完全相同的 doforkfork函数是以一个系统调用的形式存在的, 这个系统调用执行的内容就是执行dofork 1234SYSCALL_DEFINE0(fork)&#123;	return do_fork(SIGCHLD, 0, 0, NULL, NULL);&#125;  ...</div></div></div></a><a class="pagination-related" href="/2025/08/11/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="操作系统进程管理-进程实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">操作系统进程管理-进程实现原理</div></div><div class="info-2"><div class="info-item-1">进程实现原理进程是一个程序运行时的实例, 一个程序要运行起来, 需要硬盘, 内存, CPU, 网络等资源, 如果这些部分都有用户手动来管理, 开发一个程序会变成一个极其繁琐和困难的事情, 操作系统针对这些程序运行时需要的资源抽象出来了进程这个概念. 进程持有并统一管理所有一个程序要运行时需要的资源 对于资源的集合, 在概念中被称为PCB(Process Control Block), 而在Linux中对应的内核对象就是task_struct这个数据结构 123456789101112131415161718192021222324252627282930struct task_struct &#123;    // 1. 进程的状态    volatile long state;        // 2. 进程的pid    pid_t pid;    pid_t tgid;        //3. 和进程树的关系 (父进程, 子进程, 兄弟进程)    struct task_struct __rcu *parent;    struct listhead children; ...</div></div></div></a><a class="pagination-related" href="/2025/07/10/computer-fundamentals/Algorithm/Binary%20Search/" title="算法-Binary Sort-二分查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">算法-Binary Sort-二分查找</div></div><div class="info-2"><div class="info-item-1">二分查找典型特征 原数组是有序的, 或者改变原数组顺序不影响答案 我们要找出来一个数字在数组中的位置(标准二分查找题目)  一般化特征 我们能一次性排除解空间中的一半解 我们要找出来解空间中的某一个解的位置  解题通法-红蓝染色法我们能将数组依照单调性分成两部分, 以我们要找出target为例 num &gt;&#x3D; target的部分染成蓝色, num &lt; target为红色, 我们需要染色的区间是[left, right]或者(left-1, right+1)…  [left, right]要染色的区间的含义就是我们现在没有染色也就是不知道其中的元素和target之间的关系  循环不变量(以两端闭区间举例)  left - 1始终是红色 right + 1始终是蓝色  思考顺序 首先确定我们怎么确定答案, 这种方式一定是要利用原数组在找到答案方面的单调性, 我们一定能一次性排除一半的解空间 确定下来红蓝染色情况 确定下来没有染色区间的开闭选择(一般是双开区间)  典型例题及实现找到第一个大于等于target的值 闭区间12345678910111213141516...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E9%A1%B5"><span class="toc-number">1.1.</span> <span class="toc-text">虚拟内存和物理页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么要有虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">虚拟地址空间到底是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%86%E9%85%8D%E7%9A%84%E7%89%A9%E7%90%86%E9%A1%B5"><span class="toc-number">1.1.3.</span> <span class="toc-text">什么时候分配的物理页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">虚拟内存使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%97%B6%E5%AF%B9%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程启动时对虚拟内存的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap"><span class="toc-number">1.2.2.</span> <span class="toc-text">mmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sbrk-brk"><span class="toc-number">1.2.3.</span> <span class="toc-text">sbrk&#x2F;brk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">进程栈内存的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程栈的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A2%9E%E9%95%BF"><span class="toc-number">1.3.2.</span> <span class="toc-text">栈的自动增长</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84"><span class="toc-number">1.4.</span> <span class="toc-text">线程栈是怎么使用内存的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#glibc%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.1.</span> <span class="toc-text">glibc的线程对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.2.</span> <span class="toc-text">线程栈的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">malloc堆内存分配原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-chunk-%E6%9C%80%E5%B0%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8D%95%E4%BD%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">malloc_chunk: 最小内存分配单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptmalloc-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">ptmalloc: 内存分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Arena"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">Arena</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%8C%BA%E4%B8%8B%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">分配区下管理内存的数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">malloc的工作过程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/12/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="操作系统进程管理-Linux进程与线程">操作系统进程管理-Linux进程与线程</a><time datetime="2025-08-12T14:26:26.000Z" title="发表于 2025-08-12 22:26:26">2025-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/11/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="操作系统进程管理-进程实现原理">操作系统进程管理-进程实现原理</a><time datetime="2025-08-11T05:57:26.000Z" title="发表于 2025-08-11 13:57:26">2025-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/09/computer-fundamentals/Operating%20System/Linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux物理内存篇">操作系统内存管理 - Linux物理内存篇</a><time datetime="2025-08-09T03:10:20.000Z" title="发表于 2025-08-09 11:10:20">2025-08-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/04/computer-fundamentals/Operating%20System/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux虚拟内存管理">操作系统内存管理 - Linux虚拟内存管理</a><time datetime="2025-08-04T05:16:26.000Z" title="发表于 2025-08-04 13:16:26">2025-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/02/computer-fundamentals/Network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="计网-深入理解三次握手的实现原理">计网-深入理解三次握手的实现原理</a><time datetime="2025-08-02T05:33:20.000Z" title="发表于 2025-08-02 13:33:20">2025-08-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Function</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"lang":"zh-CN","input_position":"top","emit_metadata":1,"reactions_enabled":1}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'fang-tech/fang-tech.github.io',
      'data-repo-id': 'R_kgDOPJD8XA',
      'data-category-id': 'DIC_kwDOPJD8XM4CswtE',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>