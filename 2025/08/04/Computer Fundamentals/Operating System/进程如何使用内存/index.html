<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统内存管理 - 进程是如何使用内存的 | Function's Blog</title><meta name="author" content="Function"><meta name="copyright" content="Function"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程是如何使用内存的以问题来引入  申请内存申请到的真的是物理内存吗 对虚拟内存的申请如何转化成对物理内存的访问? top命令输出进程的内存指标中VIRT和RES分别是什么含义 堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么 进程栈和线程栈是一个东西吗 malloc大概是怎么工作的  虚拟内存和物理页为什么要有虚拟内存 用户进程访问内核数据要加以限制 用户进程之间需要隔离 内存不足的">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统内存管理 - 进程是如何使用内存的">
<meta property="og:url" content="https://fang-tech.github.io/2025/08/04/Computer%20Fundamentals/Operating%20System/%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="Function&#39;s Blog">
<meta property="og:description" content="进程是如何使用内存的以问题来引入  申请内存申请到的真的是物理内存吗 对虚拟内存的申请如何转化成对物理内存的访问? top命令输出进程的内存指标中VIRT和RES分别是什么含义 堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么 进程栈和线程栈是一个东西吗 malloc大概是怎么工作的  虚拟内存和物理页为什么要有虚拟内存 用户进程访问内核数据要加以限制 用户进程之间需要隔离 内存不足的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg">
<meta property="article:published_time" content="2025-08-04T08:26:00.000Z">
<meta property="article:modified_time" content="2025-08-04T18:03:09.538Z">
<meta property="article:author" content="Function">
<meta property="article:tag" content="Computer Fundamentals">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="IO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统内存管理 - 进程是如何使用内存的",
  "url": "https://fang-tech.github.io/2025/08/04/Computer%20Fundamentals/Operating%20System/%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/",
  "image": "https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg",
  "datePublished": "2025-08-04T08:26:00.000Z",
  "dateModified": "2025-08-04T18:03:09.538Z",
  "author": [
    {
      "@type": "Person",
      "name": "Function",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><link rel="canonical" href="https://fang-tech.github.io/2025/08/04/Computer%20Fundamentals/Operating%20System/%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统内存管理 - 进程是如何使用内存的',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/Interview/"><i class="fa-fw fa-solid fa-clipboard-question"></i><span> Interview</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> Project</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> Middleware</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/Middleware/Redis/"><i class="fa-fw fa-solid fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/categories/Middleware/MQ/"><i class="fa-fw fa-solid fa-comments"></i><span> MQ</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-j"></i><span> Java</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/JUC/"><i class="fa-fw fa-brands fa-threads"></i><span> JUC</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-leaf"></i><span> Spring</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/Spring-AI/"><i class="fa-fw fa-solid fa-brain"></i><span> Spring AI</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-code"></i><span> Algorithm</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm/Binary-Sort/"><i class="fa-fw fas fa-code"></i><span> Binary Sort</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Function's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统内存管理 - 进程是如何使用内存的</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/Interview/"><i class="fa-fw fa-solid fa-clipboard-question"></i><span> Interview</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> Project</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> Middleware</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/Middleware/Redis/"><i class="fa-fw fa-solid fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/categories/Middleware/MQ/"><i class="fa-fw fa-solid fa-comments"></i><span> MQ</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-j"></i><span> Java</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/JUC/"><i class="fa-fw fa-brands fa-threads"></i><span> JUC</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-leaf"></i><span> Spring</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/Spring-AI/"><i class="fa-fw fa-solid fa-brain"></i><span> Spring AI</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-code"></i><span> Algorithm</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm/Binary-Sort/"><i class="fa-fw fas fa-code"></i><span> Binary Sort</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统内存管理 - 进程是如何使用内存的</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-04T08:26:00.000Z" title="发表于 2025-08-04 16:26:00">2025-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-04T18:03:09.538Z" title="更新于 2025-08-05 02:03:09">2025-08-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/">Computer Fundamentals</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/OS/">OS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/OS/IO/">IO</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="进程是如何使用内存的"><a href="#进程是如何使用内存的" class="headerlink" title="进程是如何使用内存的"></a>进程是如何使用内存的</h1><p>以问题来引入</p>
<ol>
<li>申请内存申请到的真的是物理内存吗</li>
<li>对虚拟内存的申请如何转化成对物理内存的访问?</li>
<li>top命令输出进程的内存指标中VIRT和RES分别是什么含义</li>
<li>堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么</li>
<li>进程栈和线程栈是一个东西吗</li>
<li>malloc大概是怎么工作的</li>
</ol>
<h2 id="虚拟内存和物理页"><a href="#虚拟内存和物理页" class="headerlink" title="虚拟内存和物理页"></a>虚拟内存和物理页</h2><h3 id="为什么要有虚拟内存"><a href="#为什么要有虚拟内存" class="headerlink" title="为什么要有虚拟内存"></a>为什么要有虚拟内存</h3><ul>
<li>用户进程访问内核数据要加以限制</li>
<li>用户进程之间需要隔离</li>
<li>内存不足的时候swap到硬盘上, 保证系统可正常运行</li>
</ul>
<h3 id="虚拟地址空间到底是什么"><a href="#虚拟地址空间到底是什么" class="headerlink" title="虚拟地址空间到底是什么"></a>虚拟地址空间到底是什么</h3><p>在内核中的定义, 每个进程的task_struct都有一个核心对象 - mm_struct类型的mm. 代表的就是进程的虚拟地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> 	*<span class="title">mm</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个虚拟内存空间里面, 每一段已经分配出去的地址范围都是通过一个个虚拟内存区域VMA来表示, 也就是对应到内核中的数据结构vm_area_struct</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中vm_start和vm_end就是使用了的虚拟地址范围的开始和结尾</p>
<p>通过一个个的vm_area_struct就组成了这个进程已经分配出去的地址范围, 加起来就是对整个虚拟地址空间的占用情况. 内核会保证vm_area_struct的范围之间不会有交叉的情况出现</p>
<p>内存访问的过程中, 需要经常查找虚拟地址和某个vm_area_strcut的对应关系. 所以我们需要合适的数据结构来组织多个vm_area_strcut</p>
<p>在Linux6.1之前, 使用的是红黑树来提供logn的查询效率, 双链表来提高高效遍历效率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struuct</span> *<span class="title">mmap</span>;</span></span><br><span class="line">    <span class="comment">// 红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_mm_rb</span>;</span></span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案最明显的缺陷就是随着现在的服务器上的核数越来越多, 多线程情况下锁争抢问题. 需要加锁的原因是红黑树的平衡操作牵扯到多个节点, 以及修改需要同步到双向链表. 所以这两个数据结构都需要加锁修改.</p>
<p>在Linux6.1以后, 对VMA管理换成了maple tree. 是按照RCU无锁编程方式来实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">maple_tree</span> <span class="title">mm_mt</span>;</span></span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// file:include/linux/maple_tree.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">maple_tree</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line">     <span class="type">void</span> __rcu *ma_root;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> ma_flags; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250804165552.png"></p>
<h3 id="什么时候分配的物理页"><a href="#什么时候分配的物理页" class="headerlink" title="什么时候分配的物理页"></a>什么时候分配的物理页</h3><p>这个其实是个老生常谈的话题, 也是面试常考的问题, 答案就是是在触发缺页中断的时候, 但是这里我们将深入到Linux在触发中断以后的调用的具体的函数和涉及到的具体的数据结构来看</p>
<p>当进程在运行的过程中, 在栈上开始分配和访问变量的时候, 如果物理页还没有分配,这个时候就会触发缺页中断. 在中断处理函数中来真正分配物理内存</p>
<p>内存缺页中断的核心处理入口<code>do_user_addr_fault(unsigned long address)</code>函数</p>
<ol>
<li><code>vma = find_vma(mm, address)</code>: 根据新的addr来找到对应的vma</li>
<li><code>fault = handle_mm_fault(mm, vma, address, flags)</code>调用<code>handle_mm_fault</code>函数来真正地分配物理内存申请</li>
</ol>
<blockquote>
<p>find_vma(mm, address)</p>
<p>这个函数会优先尝试从vmacache中获取, 这是软件层面的cache, 由进程持有,  每个进程有自己VMA缓存, 缓存的内容是最近访问VMA. 下面的两个遍历操作, 都是在缓存没有命中的时候进行的</p>
</blockquote>
<p>在Linux6.1以前, 因为mm_struct中的vm_area_struct是通过红黑树和双向链表组织起来的, find_vma的实现是通过遍历VMA双向链表, 找到满足vm_start &lt;&#x3D; vma &lt;&#x3D; vm_end的VMA并返回()</p>
<p>在6.1及以后, 组织VMA的数据结构也变成了maple_tree, find_vma也就变成了调用maple tree的查找函数mas_walk来查询了</p>
<p><strong>在find_vma找到了正确的vma以后, 就进入到了真正的物理内存的分配, 会依次调用handle_mm_fault-&gt;__handle_mm_fault来完成物理内存分配</strong></p>
<blockquote>
<p>__handle_mm_fault(vma, addr…)</p>
</blockquote>
<p>首先要介绍在现在的64位的cpu下, 四级的虚拟内存页表</p>
<ul>
<li>一级页表: Page Global Dir, 简称 pgd</li>
<li>二级页表: Page Upper Dir, 简称pud</li>
<li>三级页表: Page Mid Dir, 简称pmd</li>
<li>四级页表: Page Table, 简称pte</li>
</ul>
<p>在<code>__handle_mm_fault(vma, addr...)</code>中</p>
<ol>
<li>依次查看或申请每一级的页表项</li>
<li>完成对页表的处理以后, 在<code>handle_pte_fault(vm_fault)</code>中进入到<code>do_anoymous_page</code>中进行处理</li>
<li>在<code>do_anonymous_page</code>中调用<code>alloc_zeroed_user_highpage_movable</code>分配一个可移动的匿名物理页出来, 在底层会调用伙伴系统的<code>alloc_pages</code>进行实际物理页面的分配</li>
</ol>
<blockquote>
<p><code>handle_pte_fault(vm_fault)</code>会处理很多种内存缺页处理, 比如文件映射缺页处理, swap缺页处理, 写时复制缺页处理, 匿名映射页缺页处理等情况. 开发者申请的变量内存对应的是匿名映射页处理, 会进入到do_anonymous_page</p>
</blockquote>
<blockquote>
<p>内核是用伙伴系统来管理所有的物理页的 其他的模块需要物理页的时候都会调用伙伴系统对外提供的函数来申请物理内存</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p> 申请内存申请到的真的是物理内存吗</p>
</blockquote>
<p>申请的时候实际上只会申请VMA, 真正的物理内存是等到访问的时候触发缺页中断, 再调用alloc_pages从伙伴系统中申请</p>
<p>进程的堆栈的物理内存分配时间也是同样的, 创建进程的时候新进程的栈内存分配的也只是一段地址空间范围</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250804231842.png"></p>
<h2 id="虚拟内存使用方式"><a href="#虚拟内存使用方式" class="headerlink" title="虚拟内存使用方式"></a>虚拟内存使用方式</h2><p>整个进程的运行过程中, 几乎都是在围绕着对虚拟内存的分配和使用而进行的, 具体的使用方式主要有三种</p>
<p>第一类是操作系统加载程序时在加载逻辑里对新进程的虚拟内存的设置和使用</p>
<ul>
<li>程序启动时, 加载程序会将程序代码段, 数据段通过mmap映射到虚拟地址空间中</li>
<li>对新进程初始化栈区和堆区</li>
</ul>
<p>第二类是程序运行期间动态地对所存储各种数据进行申请和释放. 涉及到栈, 进程线程运行时函数调用, 存储局部变量使用到的都是栈</p>
<p>第三类是堆, 各种开发语言运行时通过new, malloc等函数就是从堆中分配内存. 这类内存申请和释放需要依赖操作系统提供的关系虚拟地址空间相关的mmap, brk等系统调用来实现.</p>
<h3 id="进程启动时对虚拟内存的使用"><a href="#进程启动时对虚拟内存的使用" class="headerlink" title="进程启动时对虚拟内存的使用"></a>进程启动时对虚拟内存的使用</h3><p>在进程加载完毕以后, 在解析完ELF文件信息以后</p>
<ul>
<li>为进程创建新的地址空间, 同时为其准备一个默认大小4KB的栈</li>
<li>将可执行文件以及它所依赖的各种动态链接so库通过elf_map函数映射到虚拟地址空间中</li>
<li>对堆区进行初始化</li>
</ul>
<p>在程序加载启动成功以后, 在进程的地址空间中的代码段, 数据段设置完毕, 堆, 栈也都准备好了</p>
<p>底层实现上, 上面四者在底层都是对应一个个的vm_area_struct对象, 每一个vma都表示这段虚拟内存空间已经被分配和使用了</p>
<blockquote>
<p>对于栈的申请</p>
</blockquote>
<p>是在<code>execve</code>依次调用<code>do_execve_common</code>, <code>bprm_mm_init</code>, 最后在<code>__bprm_mm_init</code>中申请的vma对象</p>
<blockquote>
<p>对于可执行文件以及进程所依赖的各种so动态链接库</p>
</blockquote>
<p><code>execve</code>时依次调用<code>do_execve_common</code>, <code>search_binary_handler</code>, <code>load_elf_binary</code>, <code>elf_map</code>, 调用<code>mmap_region</code>申请vm_area_struct对象, 最终将可执行文件中的代码段, 数据段等映射到内存中</p>
<blockquote>
<p>对于堆内存</p>
</blockquote>
<p>在<code>load_elf_binary</code>的最后<code>set_brk</code>初始化堆的时候, 依次调用<code>vm_brk_flags</code>, 最后成功申请vma对象</p>
<p>可以使用<code>cat/proc/&lt;pid&gt;/maps</code>来查看进程的虚拟地址空间概要</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>这个系统调用是虚拟内存管理中提供的最接近底层调用, 也是最常用的mmap. 可以用于文件映射和匿名映射, 这里我们忽略文件映射. </p>
<blockquote>
<p>匿名映射这个名字有一些的迷惑性, 实际上是文件映射有文件, 而匿名映射没有对应的物理文件, 直接叫普通内存地址空间会更容易理解</p>
</blockquote>
<p>匿名映射的过程实际上就是向内核申请一段可用的内存地址范围而已, 非常简单. 也就是调用了mmap以后, 内核就会多申请一个vm_area_struct出来. 表示这段内存可用, 然后返回给用户.</p>
<p>mmap的调用逻辑比较深, <code>mmap </code>&#x3D;&gt; <code>ksts_mmap_pgoff </code>&#x3D;&gt; <code>vm_mmap_pgoff </code>&#x3D;&gt; <code>do_mmap_pgoff</code> &#x3D;&gt; <code>do_mmap </code>&#x3D;&gt; <code>mmap_region</code>. 最关键的就是最后的mmap_region</p>
<p>在这个位置会申请新的vm_area_struct, 并对其初始化(初始化vm_start和vm_end), 最后返回addr, 也就是虚拟地址的起始位置</p>
<p>这个时候用户申请的虚拟空间就申请好了, 用户就可以使用了.</p>
<h3 id="sbrk-brk"><a href="#sbrk-brk" class="headerlink" title="sbrk&#x2F;brk"></a>sbrk&#x2F;brk</h3><p>在set_brk中会先为数据段申请虚拟内存, 然后初始化堆区的指针, mm_struct-&gt;brk &#x3D; end(这里的end是数据段的末尾)</p>
<p>从set_brk开始, 依次调用到do_brk_flags的时候申请堆区内存(也就是申请了vma), 然后初始化mm中和堆区相关的值, brk指向的就是堆区的终止地址, start_brk指向堆区的起始地址(也就是数据段的末尾)</p>
<ul>
<li>sbrk系统调用: 返回mm_struct-&gt;brk的指针值</li>
<li>brk系统调用: 修改mm_struct-&gt;brk的指针值<ul>
<li>往大了改就是加大堆区</li>
<li>往小了改就是缩小堆区</li>
</ul>
</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>对虚拟内存的申请如何转化成对物理内存的访问?</p>
<ol>
<li>top命令输出进程的内存指标中VIRT和RES分别是什么含义</li>
<li>堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么</li>
<li>进程栈和线程栈是一个东西吗</li>
<li>malloc大概是怎么工作的</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Computer-Fundamentals/">Computer Fundamentals</a><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/IO/">IO</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/08/02/Computer%20Fundamentals/Network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="深入理解三次握手的实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">深入理解三次握手的实现原理</div></div><div class="info-2"><div class="info-item-1">三次握手的内部实现原理 不同于八股中简单的对三次握手的流程的介绍, 本文会从在Linux中使用socket建立TCP连接完成的工作的角度深度剖析三次握手 参考:  深入理解Linux网络： 修炼底层内功，掌握高性能原理 (张彦飞)   使用Socket通信的过程 123456// 客户端的核心代码int main()&#123;	int fd = socket(AF_INET, SOCK_STREAM, 0);    connect(fd, ....);    ....&#125;  12345678// 服务端的核心代码int main() &#123;    int fd = socket(AF_INET, SOCK_STREAM, 0);    bind(fd, ...);    listen(fd, 128);    accept(fd, ...);    ...&#125;  socket函数的作用从开发者的角度我们调用socket函数, 创建一个socket, 然后返回一个句柄用于访问和操作我们这个创建的socket. 从内核的角度来看, 调用这个函数会在内核内部创建...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/25/Computer%20Fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="操作系统I&#x2F;O - 多路复用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">操作系统I&#x2F;O - 多路复用</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O-多路复用多路复用是解决的什么问题解决的最根本的问题是: 我们怎么让我们的服务器能并发处理更多的数量的请求 最经典的问题就是C10K问题: 服务器怎么并发处理1w个请求 解决这个问题我们就需要考虑到, 连接占用的资源有哪些  文件描述符: Socket实际上是一个虚拟的文件, 也就对应着有相应的文件描述符, 在Linux中一个进程能打开的文件描述符的数量是有限的, 一般来说是1024(默认值) 系统内存: 每个TCP连接在内核中都有对应的数据结构, 也就是每个连接都占用了一定的内存  在这些基础上, 我们该怎么实现并发处理1w个请求呢?  多进程模型?  我们每成功建立一个连接就创建一个进程, 这个时候因为fork()创建的子进程中的文件描述符也是被继承过去, 让子进程来通过已连接Socket来提供服务 但是这种方式很明显是不能解决C10K问题的, 没有哪个系统扛得住创建1W个进程, 并且进程间切换的成本很高, 性能很差  多线程模型  为了解决多进程模型中, 进程的体量很大并且切换成本高的问题, 我们换成多线程模型 当服务器与客户端 TCP 完成连接后，通过 p...</div></div></div></a><a class="pagination-related" href="/2025/07/25/Computer%20Fundamentals/Operating%20System/IO-%E9%9B%B6%E6%8B%B7%E8%B4%9D/" title="操作系统I&#x2F;O - 零拷贝"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">操作系统I&#x2F;O - 零拷贝</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O的演进DMA技术在最开始的时候, 读一个文件的过程是   用户进程调用read(), 切换到内核态, CPU向磁盘发起IO请求 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信号给CPU CPU将数据从磁盘数据控制器缓冲区中拷贝到 PageCache CPU将数据从PageCache中拷贝到用户缓冲区 read()调用返回, 切换到用户态  一共发生了两次用户态和内核态的上下文切换, 发生了两次拷贝, 并且数据的搬运也是交给CPU来操作的, 占用了大量的CPU的时间, 导致了CPU吞吐量下降 解决方式就是引入了DMA(Direct Memory Access)直接内存访问技术,  我们将把数据从磁盘控制器缓冲区搬运到PageCache的工作交给了DMA控制器来进行  现在的读一个文件的流程变成了  用户进程调用read(), 切换到内核态, 向操作系统发起IO请求, 将数据读取到自己的内存缓冲区中, 进程进入到了阻塞状态 CPU收到操作系统发送的指令以后, 将请求发送给DMA, DMA再进一步发送给磁盘 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信...</div></div></div></a><a class="pagination-related" href="/2025/07/10/Computer%20Fundamentals/Algorithm/Binary%20Search/" title="Binary Sort-二分查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">Binary Sort-二分查找</div></div><div class="info-2"><div class="info-item-1">二分查找典型特征 原数组是有序的, 或者改变原数组顺序不影响答案 我们要找出来一个数字在数组中的位置(标准二分查找题目)  一般化特征 我们能一次性排除解空间中的一半解 我们要找出来解空间中的某一个解的位置  解题通法-红蓝染色法我们能将数组依照单调性分成两部分, 以我们要找出target为例 num &gt;&#x3D; target的部分染成蓝色, num &lt; target为红色, 我们需要染色的区间是[left, right]或者(left-1, right+1)…  [left, right]要染色的区间的含义就是我们现在没有染色也就是不知道其中的元素和target之间的关系  循环不变量(以两端闭区间举例)  left - 1始终是红色 right + 1始终是蓝色  思考顺序 首先确定我们怎么确定答案, 这种方式一定是要利用原数组在找到答案方面的单调性, 我们一定能一次性排除一半的解空间 确定下来红蓝染色情况 确定下来没有染色区间的开闭选择(一般是双开区间)  典型例题及实现找到第一个大于等于target的值 闭区间12345678910111213141516...</div></div></div></a><a class="pagination-related" href="/2025/07/30/Computer%20Fundamentals/Algorithm/Stack/" title="栈 (单调栈)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-30</div><div class="info-item-2">栈 (单调栈)</div></div><div class="info-2"><div class="info-item-1">栈栈核心特征 (什么时候使用栈)本质上是一种用空间换时间的优化方案, 如果我们缓存数据的方向是从左往右(从右往左), 而我们求解答案的时候是从右往左的, 计算完成以后就不需要了, 符合后进先出的特征, 使用栈结构 比如括号匹配问题, 我们从左向右遍历和缓存数据, 然后在我们匹配到右括号的时候, 从右往左将数据弹出 一般解法1234567891011for (int i = 0; i &lt; nums.length; i++) &#123;   	// 特殊的情况下, 也就是匹配到了需要解递归的数据的时候    // 元素出栈    while (!stack.isEmpty() &amp;&amp; condition) &#123;        int j = stack.pop();        ...    &#125;        // 一般情况下直接将元素入栈    stack.push(i);&#125;  典型题目20. 有效的括号 394. 字符串解码 非典型题目155. 最小栈 单调栈核心特征单调栈是栈的一种特殊的用法, 我们维护的栈是一个大小单调变化的...</div></div></div></a><a class="pagination-related" href="/2025/08/01/Computer%20Fundamentals/Algorithm/Heap/" title="堆"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-01</div><div class="info-item-2">堆</div></div><div class="info-2"><div class="info-item-1">堆核心概念 这里并不讨论堆的实现和基本的原理, 只是讨论这个数据结构的使用场景, 解决的问题  使用堆我们能获得O(logn)的时间复杂度的插入和删除元素, O(1)的时间复杂度的获取某个集合的最大(小)值 如果一个场景需要持续获取某个变化集合的最大(小)值, 我们就能考虑使用堆, 并且一定会有出堆操作!!! 不然我们简单维护一个min或max变量就行了 一般解法1234// 创建小堆Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();// 创建大堆Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a,b) -&gt; b-a);  典型例题295. 数据流的中位数 347. 前 K 个高频元素 215. 数组中的第K个最大元素 </div></div></div></a><a class="pagination-related" href="/2025/08/02/Computer%20Fundamentals/Network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="深入理解三次握手的实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="info-item-2">深入理解三次握手的实现原理</div></div><div class="info-2"><div class="info-item-1">三次握手的内部实现原理 不同于八股中简单的对三次握手的流程的介绍, 本文会从在Linux中使用socket建立TCP连接完成的工作的角度深度剖析三次握手 参考:  深入理解Linux网络： 修炼底层内功，掌握高性能原理 (张彦飞)   使用Socket通信的过程 123456// 客户端的核心代码int main()&#123;	int fd = socket(AF_INET, SOCK_STREAM, 0);    connect(fd, ....);    ....&#125;  12345678// 服务端的核心代码int main() &#123;    int fd = socket(AF_INET, SOCK_STREAM, 0);    bind(fd, ...);    listen(fd, 128);    accept(fd, ...);    ...&#125;  socket函数的作用从开发者的角度我们调用socket函数, 创建一个socket, 然后返回一个句柄用于访问和操作我们这个创建的socket. 从内核的角度来看, 调用这个函数会在内核内部创建...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Function</div><div class="author-info-description">Function的个人博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fang-tech"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">进程是如何使用内存的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E9%A1%B5"><span class="toc-number">1.1.</span> <span class="toc-text">虚拟内存和物理页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么要有虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">虚拟地址空间到底是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%86%E9%85%8D%E7%9A%84%E7%89%A9%E7%90%86%E9%A1%B5"><span class="toc-number">1.1.3.</span> <span class="toc-text">什么时候分配的物理页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">虚拟内存使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%97%B6%E5%AF%B9%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程启动时对虚拟内存的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap"><span class="toc-number">1.2.2.</span> <span class="toc-text">mmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sbrk-brk"><span class="toc-number">1.2.3.</span> <span class="toc-text">sbrk&#x2F;brk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94"><span class="toc-number">1.3.</span> <span class="toc-text">解答</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/04/Computer%20Fundamentals/Operating%20System/%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/" title="操作系统内存管理 - 进程是如何使用内存的">操作系统内存管理 - 进程是如何使用内存的</a><time datetime="2025-08-04T08:26:00.000Z" title="发表于 2025-08-04 16:26:00">2025-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/02/Computer%20Fundamentals/Network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="深入理解三次握手的实现原理">深入理解三次握手的实现原理</a><time datetime="2025-08-02T05:33:20.000Z" title="发表于 2025-08-02 13:33:20">2025-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/01/Architecture/%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1/REST/" title="无标题">无标题</a><time datetime="2025-08-01T09:56:46.412Z" title="发表于 2025-08-01 17:56:46">2025-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/01/Architecture/%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" title="分布式架构-远程服务调用 (RPC)">分布式架构-远程服务调用 (RPC)</a><time datetime="2025-08-01T08:40:26.000Z" title="发表于 2025-08-01 16:40:26">2025-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/01/Computer%20Fundamentals/Algorithm/Heap/" title="堆">堆</a><time datetime="2025-07-31T16:28:20.000Z" title="发表于 2025-08-01 00:28:20">2025-08-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Function</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"lang":"zh-CN","input_position":"top","emit_metadata":1,"reactions_enabled":1}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'fang-tech/fang-tech.github.io',
      'data-repo-id': 'R_kgDOPJD8XA',
      'data-category-id': 'DIC_kwDOPJD8XM4CswtE',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>