<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll | Function's Blog</title><meta name="author" content="Function"><meta name="copyright" content="Function"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux中的同步阻塞IO与多路复用epollLinux中的同步阻塞IO在完成了socket的创建, 三次握手的过程以后, 通信双方建立了连接, 接下来的过程就是通信的过程了, 相互传递数据, 使用同步阻塞进行通信的过程其实就是简单地直接使用recv阻塞式地等待数据发送到来, 发送到了再接收处理  等待接收消息通过strace能发现recv执行的系统调用是recvform, 进入到系统调用以后,">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll">
<meta property="og:url" content="https://fang-tech.github.io/2025/08/14/computer-fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index.html">
<meta property="og:site_name" content="Function&#39;s Blog">
<meta property="og:description" content="Linux中的同步阻塞IO与多路复用epollLinux中的同步阻塞IO在完成了socket的创建, 三次握手的过程以后, 通信双方建立了连接, 接下来的过程就是通信的过程了, 相互传递数据, 使用同步阻塞进行通信的过程其实就是简单地直接使用recv阻塞式地等待数据发送到来, 发送到了再接收处理  等待接收消息通过strace能发现recv执行的系统调用是recvform, 进入到系统调用以后,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg">
<meta property="article:published_time" content="2025-08-14T13:54:26.000Z">
<meta property="article:modified_time" content="2025-08-16T06:07:39.972Z">
<meta property="article:author" content="Function">
<meta property="article:tag" content="Computer Fundamentals">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="Netwokr-IO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll",
  "url": "https://fang-tech.github.io/2025/08/14/computer-fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/",
  "image": "https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg",
  "datePublished": "2025-08-14T13:54:26.000Z",
  "dateModified": "2025-08-16T06:07:39.972Z",
  "author": [
    {
      "@type": "Person",
      "name": "Function",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><link rel="canonical" href="https://fang-tech.github.io/2025/08/14/computer-fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> 项目</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Architecture/Distributed-Systems"><i class="fa-fw fa-solid fa-layer-group"></i><span> 分布式架构</span></a></li><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-laptop-code"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-cogs"></i><span> 计算机基础</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm"><i class="fa-fw fas fa-route"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/OS"><i class="fa-fw fas fa-desktop"></i><span> OS</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/Network"><i class="fa-fw fas fa-network-wired"></i><span> 计算机网络</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Function's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> 项目</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Architecture/Distributed-Systems"><i class="fa-fw fa-solid fa-layer-group"></i><span> 分布式架构</span></a></li><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-laptop-code"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-cogs"></i><span> 计算机基础</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm"><i class="fa-fw fas fa-route"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/OS"><i class="fa-fw fas fa-desktop"></i><span> OS</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/Network"><i class="fa-fw fas fa-network-wired"></i><span> 计算机网络</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-14T13:54:26.000Z" title="发表于 2025-08-14 21:54:26">2025-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-16T06:07:39.972Z" title="更新于 2025-08-16 14:07:39">2025-08-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/">Computer Fundamentals</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/OS/">OS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/OS/Netwokr-IO/">Netwokr-IO</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Linux中的同步阻塞IO与多路复用epoll"><a href="#Linux中的同步阻塞IO与多路复用epoll" class="headerlink" title="Linux中的同步阻塞IO与多路复用epoll"></a>Linux中的同步阻塞IO与多路复用epoll</h1><h2 id="Linux中的同步阻塞IO"><a href="#Linux中的同步阻塞IO" class="headerlink" title="Linux中的同步阻塞IO"></a>Linux中的同步阻塞IO</h2><p>在完成了socket的创建, 三次握手的过程以后, 通信双方建立了连接, 接下来的过程就是通信的过程了, 相互传递数据, 使用同步阻塞进行通信的过程其实就是简单地直接使用<code>recv</code>阻塞式地等待数据发送到来, 发送到了再接收处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120305.png"></p>
<h3 id="等待接收消息"><a href="#等待接收消息" class="headerlink" title="等待接收消息"></a>等待接收消息</h3><p>通过<code>strace</code>能发现<code>recv</code>执行的系统调用是<code>recvform</code>, 进入到系统调用以后, 用户进程就进入到了内核态, 执行一系列的内核协议层函数, 然后到socket对象的接收队列中查看是否有数据, 没有数据的话, 就把自己添加到socket对应的等待队列中. 最后让出CPU</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120332.png"></p>
<p>这里的关键是<code>recvfrom</code>最后是怎么将自己的进程给阻塞调用的</p>
<p>在<code>recvfrom</code>系统调用中根据fd找到对应的socket对象以后, 调用<code>sock_recvmsg</code></p>
<p><code>sock_recvmsg </code>-&gt; <code>__sock_recvmsg</code> -&gt; <code>__sock_recvmsg_nosec</code></p>
<p>在最后的方法中, 调用到了socket-&gt;ops-&gt;recvmsg</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120355.png"></p>
<p>由socket对象图, 我们能知道这个时候<code>recvmsg</code>指向的是<code>inet_recvmsg</code>函数</p>
<p>在这里我们又要调用socket对象中的sock的sk_prot中的<code>recvmsg</code>方法, 同样我们能从socket对象图中回忆起来这个方法指向是<code>tcp_recvmsg</code></p>
<blockquote>
<p>tcp_recvmsg 执行过程</p>
</blockquote>
<ol>
<li>遍历接收队列接收数据</li>
<li>如果接收队列中的数据长度 &gt;&#x3D; target, 接收数据</li>
<li>反之, 没有收到足够长度的数据, 启用<code>sk_wait_data</code>阻塞掉当前进程</li>
</ol>
<p>接下来就是看到sk_wait_data是怎么将进程阻塞掉的</p>
<blockquote>
<p>sk_wait_data执行过程</p>
</blockquote>
<ol>
<li>创建等待队列项wait</li>
<li>调用DEFINE_WAIT宏, 将当前进程(current)关联到所定义的等待队列项上, 并且为这个等待队列项注册了回调函数<code>autoremove_wake_function</code></li>
<li>调用<code>sk_sleep</code>获取socket对象下的等待队列列表头wait_queue_head_t</li>
<li>调用<code>prepare_to_wait</code>来把新定义的等待队列项wait插入sock对象的等待队列, 并设置进程的状态为TASK_INTERRUPTIBLE</li>
<li>最后调用<code>schedule_timeout</code>让出CPU, 然后进行睡眠</li>
</ol>
<p>当内核收完数据产生就绪事件的时候, 就可以查找socket等待队列上的等待项, 进而可以找到回调函数(<code>autoremove_wake_function</code>)和在等待该socket就绪事件的进程了. <strong>这里我们产生了一次进程上下文切换的开销</strong></p>
<h3 id="软中断模块"><a href="#软中断模块" class="headerlink" title="软中断模块"></a>软中断模块</h3><p>接下来让我们转换视角, 从来到负责接收和处理数据包的软中断这里来</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120520.png"></p>
<p>我们直接看到TCP协议的接收函数<code>tcp_v4_rcv</code>上</p>
<blockquote>
<p>tcp_v4_rcv</p>
</blockquote>
<ol>
<li>获取数据帧的ip header, tcp header</li>
<li>根据数据包header中的信息, 查找到对应的socket</li>
<li>然后进入到tcp_v4_do_rcv主体函数</li>
</ol>
<blockquote>
<p>tcp_v4_do_rcv</p>
</blockquote>
<p>如果连接状态是ESTABLISHED, 进入到tcp_rcv_established函数处理</p>
<blockquote>
<p>tcp_rcv_established</p>
</blockquote>
<ol>
<li>调用<code>tcp_queue_rcv</code>将接收数据放到接收队列中<ol>
<li>这个函数将接收到的数据放入到socket的接收队列的队尾</li>
</ol>
</li>
<li>数据准备好, 调用<code>sock_def_readble</code>唤醒socket上阻塞掉的进程<ol>
<li>这里实际上调用的是sk_data_ready函数指针, 但是在创建socket的时候, 在sock_init_data函数里面, 已经将这个函数指针指向了sock_def_readable函数了, 它是默认的数据就绪处理函数</li>
<li>这里会从socket-&gt;wait等待队列上获取到等待的wait项, 并从中获取到我们在之前的<code>recvfrom</code>中调用的<code>DEFINE_WAIT(wait)</code>的时候关联的进程</li>
<li>调用<code>wake_up_interruptible_sync_poll</code>来唤醒socket上因为等待数据被阻塞的进程</li>
</ol>
</li>
</ol>
<blockquote>
<p>wake_up_interruptible_sync_poll</p>
</blockquote>
<p>这是一个宏函数, 实际上会执行到<code>__wake_up_sync_key</code>上, 这个函数最后调用<code>__wake_up_common</code>实现唤醒, 这个时候其中的nr_exclusive参数传入的是1, 这是指即使有多个进程都阻塞在同一个socket上, 也只唤醒一个进程</p>
<p>在<code>__wake_up_common</code>中, 会招出来一个等待队列项curr, 然后调用其curr-&gt;func, 这里实际上调用的函数是我们在<code>DEFINE_WAIT</code>的时候设置的<code>autoremove_wake_function</code></p>
<p>在<code>autoremove_wake_function</code>中调用到了<code>default_wake_function</code>, 最后调用到<code>try_wake_up(curr-&gt;private)</code>, 这里的private就是我们在之前的<code>DEFINE_WAIT</code>关联的被阻塞的进程. 在这个函数执行完以后, 进程就被推入到可运行队列里面了. 这里我们又将产生了一次进程上下文切换的开销</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120154.png"></p>
<p>这个模式基本没有在使用了, 因为性能差开销大. 一个线程也只能维护一个连接, 将维持的连接的数量和线程的数量绑定, 连接的数量少还好, 如果是10K的连接, 岂不是要创建10K个线程, 没有哪台机器能扛得住, 同时在IO密集型任务里面, 使用同步阻塞的方式会导致频繁的进程上下文的切换, 这也导致性能极差. </p>
<p>但是也不是说这个方式一无是处, 编程的方式简单这个优点对比Epoll尤其明显 (不要把实现简单不当成优势, 程序员也是人, 需要在有限的时间里实现特定的功能, 在实现的难度、 性能等方面进行多方面的权衡后选择一个合适的技术实现才是正确的方式)</p>
<h2 id="多路复用Epoll"><a href="#多路复用Epoll" class="headerlink" title="多路复用Epoll"></a>多路复用Epoll</h2><p>现在我们正式进入到这个章节的重点, 多路复用, 首先我们要明确这里复用的内容是什么, 是进程(线程, task), 我们想实现在一个进程里面同时监听并处理多个连接, 这就是对于进程的复用.</p>
<p>epoll的存在我们可以想象成一只牧羊犬. 在没有牧羊犬之前, 人一次只能放一只羊, 等这只羊吃完草以后才能放别的🐏. 在有了牧羊犬以后, 我们将🐏交给牧羊犬管理, 一旦有那只羊有什么情况, 由牧羊犬统一通知我们, 这样我们就能实现管理多只🐏.</p>
<p>一个简单的例子 (伪代码)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	listen(lfd, ...);</span><br><span class="line">    cfd1 = accept(...);</span><br><span class="line">    cfd2 = accept(...);</span><br><span class="line">    efd = epoll_create(...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不光可以将accept socket添加在epoll中, 监听socket同样能添加到其中</span></span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, cfd1, ...);</span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, cfd2, ...);</span><br><span class="line">    epoll_Wait(efd, ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到epoll关键的函数是</p>
<ul>
<li><code>epoll_create</code>: 创建一个epoll对象</li>
<li><code>epoll_ctl</code>: 向epoll对象添加要管理的连接</li>
<li><code>epoll_wait</code>: 等待其管理的连接上的IO事件</li>
</ul>
<p>接下来我们挨个解析这些函数</p>
<h3 id="epoll内核对象的创建"><a href="#epoll内核对象的创建" class="headerlink" title="epoll内核对象的创建"></a>epoll内核对象的创建</h3><p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816140652.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816140712.png"></p>
<p>这个数据结构的几个成员的含义</p>
<ul>
<li>wq: 等待队列链表, 软中断数据就绪的时候会通过wq来找到阻塞在epoll对象上的用户进程</li>
<li>rbr: 红黑树, 为了支持对海量连接的高效查找, 插入, 删除操作, epoll内部使用了红黑树, 用于管理用户进程下添加进来的所有socket进程</li>
<li>rdllist: 就绪的描述符的链表, 当有连接就绪的时候, 内核就会把就绪的连接放入到这个链表中, 这样应用进程就只需要判断链表就能找到就绪连接, 不需要遍历整棵树</li>
</ul>
<p>epoll_create中执行的主要函数就是ep_alloc从slab内存管理器中申请一个epoll出来并将其初始化, 这里的初始化工作其实就是将其中的各个成员都初始化一遍</p>
<h3 id="为epoll添加socket"><a href="#为epoll添加socket" class="headerlink" title="为epoll添加socket"></a>为epoll添加socket</h3><p>这里我们只考虑使用EPOLL_CTL_ADD添加socket, 忽略删除和更新</p>
<p>现在假设和客户端的多个连接的socket都创建好了, 并且也创建好了socket对象, 要使用epoll_ctl注册每一个socket的时候, 内核会做的事</p>
<ul>
<li>分配一个红黑树节点对象epitem</li>
<li>将等待事件添加到socket的等待队列中, 回调函数是<code>ep_poll_callback</code></li>
<li>将epitem插入到epoll对象的红黑树</li>
</ul>
<blockquote>
<p>看到epoll_ctl系统调用</p>
</blockquote>
<ol>
<li>根据传入的fd找到eventpoll, socket内核对象</li>
<li>对于EPOLL_CTL_ADD操作来说, 会执行到ep_insert函数, 所有的注册都是在这个函数中完成的</li>
</ol>
<blockquote>
<p>ep_insert</p>
</blockquote>
<ol>
<li>分配并初始化epitem</li>
<li>设置socket等待队列</li>
<li>将epi插入到eventpoll对象的红黑树中</li>
</ol>
<h4 id="分配并初始化epitem"><a href="#分配并初始化epitem" class="headerlink" title="分配并初始化epitem"></a>分配并初始化epitem</h4><p>epitem也就是红黑树节点指向的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">	<span class="comment">// 红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket文件描述符信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所归属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是将epi-&gt;ep设置传入的struct eventpoll, 然后用要添加的socket的file和fd填充到epi-&gt;ffd中.</p>
<p>也就是一个epitem对象在初始化以后会关联到一个eventpoll对象和一个socket(file, fd)</p>
<h4 id="设置socket等待队列"><a href="#设置socket等待队列" class="headerlink" title="设置socket等待队列"></a>设置socket等待队列</h4><p>在完成了epitem的创建并初始化了以后, 就要设置socket对象上的等待任务队列并设置回调函数</p>
<p>看到ep_item_poll函数</p>
<p>这个函数会通过<code>ep_item_poll</code> -&gt; <code>epi-&gt;ffd.file-&gt;f_op-&gt;poll(这里是struct file中的f_op, 在这里实际指向的是sock_poll函数)</code> -&gt; <code>sock-&gt;ops-&gt;poll(这里实际指向的是tcp_poll)</code> -&gt; <code>sock_poll_wait</code></p>
<p>在最后的sock_poll_wait会传入由sk_sleep获取的sock对象下的等待队列列表头wait_queue_head_t, 这个也是前面同步阻塞中<code>sk_wait_data函数</code>获取等待队列列表头的方法, 这里是为插入等待队列项做准备</p>
<p><code>sock_wait </code>-&gt; <code>poll_wait </code>-&gt; <code>p-&gt;qproc</code>(实际上调用的是在<code>ep_insert</code>中设置成的<code>ep_ptable_queue_proc</code>函数)</p>
<p>在<code>ep_ptable_queue_proc</code>中, 新建了一个等待队列项, 并注册其为回调函数<code>ep_poll_callback</code>函数, 然后将这个等待项添加到socket的等待队列中 (注意这里不是epoll的等待队列, 是socket的等待队列)</p>
<p>这个时候等待队列项是交给epoll来管理的, 所以不需要像之前的recvfrom里面一样将private设置成当前进程在socket就绪的时候唤醒进程, 这里会设置成NULL</p>
<p>这样设置以后, 在软中断将数据收到socket的接收队列以后, 会通过注册的ep_poll_callback函数回调, 进而通知epoll对象</p>
<h4 id="插入红黑树"><a href="#插入红黑树" class="headerlink" title="插入红黑树"></a>插入红黑树</h4><p>在分配完epitem对象以后, 就将其插入到红黑树中</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816140735.png"></p>
<p>为什么使用红黑树? 为了能让epoll在查找效率, 插入效率, 内存开销等多个方面比较均衡, 只考虑查找效率的话, 肯定使用哈希表了, 谁能查得过它.</p>
<h3 id="epoll-wait等待接收"><a href="#epoll-wait等待接收" class="headerlink" title="epoll_wait等待接收"></a>epoll_wait等待接收</h3><p>当它被调用的时候, 观察eventpoll-&gt;rdllist链表中有没有数据, 有数据就返回, 没有数据就创建一个等待队列项, 将其添加到eventpoll的等待队列, 然后就将自己阻塞掉. 这里的过程比较像之前recvfrom中创建socket的等待队列项的过程</p>
<ol>
<li>会定义等待队列项 并关联current(当前进程), 这里设置的回调函数是default_wake_function</li>
<li>添加到epoll对象的等待队列链表中</li>
<li>将自己阻塞了, 让出CPU, 选择下一个进程调度</li>
</ol>
<p>这样设置以后, 实际上在触发软中断以后会将epoll关联的进程给唤醒, 然后再让epoll去处理它管理的socket们, 将自己的rdllist中的数据返回</p>
<blockquote>
<p>也就是当没有IO事件的时候, epoll也是会将自己阻塞的, 毕竟没有任务, 占着CPU干嘛, 在epoll中. 其实epoll本身是阻塞的, 只是将socket设置成了非阻塞</p>
</blockquote>
<h3 id="数据来了"><a href="#数据来了" class="headerlink" title="数据来了"></a>数据来了</h3><p>在epoll_ctl运行完以后为sock添加了等待队列项, 回调函数是<code>ep_poll_callback</code>, 这里的private指向的是NULL, 因为socket不再关联进程</p>
<p>在epoll_wait运行完以后, 又为epoll添加了等待队列项, 回调函数是<code>default_wake_function</code>, 这里private指向的就是进程了.</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816140258.png"></p>
<p>接下来就是看到软中断处理完以后, 怎么依次进入到各个回调函数中, 最后通知到用户进程的</p>
<h4 id="将数据收到任务队列中"><a href="#将数据收到任务队列中" class="headerlink" title="将数据收到任务队列中"></a>将数据收到任务队列中</h4><p>和前面的同步阻塞中的软中断模块一样, 我们从tcp_v4_rcv进入, 最后通过tcp_queue_rcv将数据保存到socket的接收队列中. </p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120520.png"></p>
<h4 id="查找就绪回调函数"><a href="#查找就绪回调函数" class="headerlink" title="查找就绪回调函数"></a>查找就绪回调函数</h4><p>走完了左边的保存数据的路径以后, 接下来就是唤醒等待队列上的进程的路径, 同样我们最终调用到<code>sock_def_readable</code>这个默认的数据就绪处理函数</p>
<p>以<code>sock_def_readable</code>这个函数为入口, 从socket-&gt;wait等待队列上获取到等待的wait项, 这里会得到我们之前在<code>epoll_ctl</code>中设置的<code>ep_poll_callback</code>回调函数</p>
<blockquote>
<p>sock_def_readable</p>
</blockquote>
<ol>
<li>通过<code>wq_has_sleeper</code>判断sock等待队列不为空</li>
<li>不为空的话, 通过<code>wake_up_interruptible_sync_poll</code>执行等待队列项上的回调函数</li>
</ol>
<blockquote>
<p>wake_up_interruptible_sync_poll</p>
</blockquote>
<p>这个函数和在同步阻塞中一样, 调用到<code>__wake_up_common</code>, 并从中获取到等待队列项curr, 然后调用curr-&gt;func. 这里就是在<code>ep_insert</code>中设置的<code>ep_poll_callback</code>了</p>
<h4 id="执行socket就绪回调函数"><a href="#执行socket就绪回调函数" class="headerlink" title="执行socket就绪回调函数"></a>执行socket就绪回调函数</h4><blockquote>
<p>ep_poll_callback</p>
</blockquote>
<ol>
<li>获取到wait对应的epitem</li>
<li>获取epitem对应的eventpoll结构体</li>
<li>将当前epitem添加到eventpoll的就绪队列上, 也就是eventpoll-&gt;rdllist</li>
<li>查看eventpoll的等待队列上是否有等待, 如果有等待就调用<code>wake_up_locked</code>将epoll对应的进程唤醒</li>
</ol>
<blockquote>
<p>wake_up_locked</p>
</blockquote>
<p>这里实际上最后也是调用到wake_up_interruptible_sync_poll获取等待队列项, 然后调用curr-&gt;func, 不过这个时候调用到的是epoll的等待队列项中的回调函default_wake_function, 将epoll唤醒</p>
<blockquote>
<p>default_wake_function</p>
</blockquote>
<p>这个函数会重新将epoll_wait进程推入可运行队列,  等待内核重新调度. 当这个进程重新运行的时候, 会从epoll_wait阻塞时暂停的代码处继续执行, 将rdllist中就绪的事件返回给用户进程</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816140551.png"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Computer-Fundamentals/">Computer Fundamentals</a><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/Netwokr-IO/">Netwokr-IO</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/20/Architecture/%E4%BA%8B%E5%8A%A1/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1/" title="分布式架构-事务-本地事务"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">分布式架构-事务-本地事务</div></div><div class="info-2"><div class="info-item-1">本地事务什么是事务事务是解决数据一致性(Consistency) 问题的一种机制 根据数据源的数量, 将一致性分成了单一数据源情况下的”内部一致性“, 多数据源情况下的”外部一致性“.  内部一致性  通过ACID机制来保证数据源内部一致性, 其中AID是手段, C是目的  原子性 (Atomic): 在一个事务中对于数据的修改要不全部成功, 要不全部失败回滚 持久性 (Duration): 事务提交以后, 对于数据的修改不会出现丢失和撤销 隔离性 (Isolation): 多个事务并发执行的时候, 每个事务之间的读, 写操作都相互隔离 一致性 (Consistency): 事务前后, 数据满足完整性约束, 数据库保持一致状态   外部一致性  将一致性从”是&#x2F;否”的二元属性, 拓展成了多元的”强一致性, 最终一致性, 弱一致性”划分, 通过额外的架构手段来在确保代价可承受的条件下获得强度尽可能高的一致性 (XA, TCC, AT, SEGA…) 本节只讨论本地事务, 也就是数据源怎么获取内部一致性, 怎么实现的AID. 实现原子性和持久性实现原子性和持久性的核心是实现...</div></div></div></a><a class="pagination-related" href="/2025/08/13/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/" title="操作系统进程加载(ELF)-Linux进程加载启动原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">操作系统进程加载(ELF)-Linux进程加载启动原理</div></div><div class="info-2"><div class="info-item-1">Linux进程加载启动原理可执行文件格式这里讲的都是linux中的可执行文件的格式, 不同的操作系统中的可执行文件的格式是不一样的, 这也是你在不同的平台上编译出来的可执行文件是不能跨平台执行的. 也是为什么如果要跨平台运行其他平台的可执行文件需要转义中间层.  Linux中的可执行文件是ELF(Executable and Linkable Format)文件, 其组成可以分成  ELF文件头 Program Header Table Segment Section   Section Header Table  下面查看的都是该程序的编译后的ELF文件 123456789#include &lt;stdio.h&gt;int data1;int data2 = 1;int main() &#123;        printf(&quot;hello, world&quot;);        return 0;&#125;  ELF文件头记录了整个文件中的属性信息, 可以通过下面的命令查看 1readelf --file-header &lt;file&gt;   可以看到...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/25/computer-fundamentals/Operating%20System/IO-%E9%9B%B6%E6%8B%B7%E8%B4%9D/" title="操作系统I&#x2F;O - 零拷贝"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">操作系统I&#x2F;O - 零拷贝</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O的演进DMA技术在最开始的时候, 读一个文件的过程是   用户进程调用read(), 切换到内核态, CPU向磁盘发起IO请求 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信号给CPU CPU将数据从磁盘数据控制器缓冲区中拷贝到 PageCache CPU将数据从PageCache中拷贝到用户缓冲区 read()调用返回, 切换到用户态  一共发生了两次用户态和内核态的上下文切换, 发生了两次拷贝, 并且数据的搬运也是交给CPU来操作的, 占用了大量的CPU的时间, 导致了CPU吞吐量下降 解决方式就是引入了DMA(Direct Memory Access)直接内存访问技术,  我们将把数据从磁盘控制器缓冲区搬运到PageCache的工作交给了DMA控制器来进行  现在的读一个文件的流程变成了  用户进程调用read(), 切换到内核态, 向操作系统发起IO请求, 将数据读取到自己的内存缓冲区中, 进程进入到了阻塞状态 CPU收到操作系统发送的指令以后, 将请求发送给DMA, DMA再进一步发送给磁盘 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信...</div></div></div></a><a class="pagination-related" href="/2025/08/09/computer-fundamentals/Operating%20System/Linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux物理内存篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-09</div><div class="info-item-2">操作系统内存管理 - Linux物理内存篇</div></div><div class="info-2"><div class="info-item-1">Linux物理内存物理内存检测在物理内存这个硬件和操作系统之间, 还存在着一个固件层(firmware)也叫BIOS. 它负责硬件自检, 初始化所有硬件设备, 加载操作系统引导程序, 将控制权移交给操作系统并提供结构供操作系统读取硬件信息. 操作系统所需的内存等硬件信息都是通过固件来获取的 在固件ACPI接口规范中定义了探测内存的物理分布规范. 内核请求中断15H , 并设置操作码为E820H,  因为操作码是E820, 所以这个机制也被称为E820 会在detect_memory_e820函数发出15号中断并处理所有结果, 把内存地址范围保存到boot_params.e820_table对象中. boot_params只是一个中间数据, 专门还有一个e820_table全局数据结构来保存内存地址范围, 在e820__memory_setup中会将boot_params.e820_table保存到e820_table中, 并打印出来. 服务器能通过mseg命令来查看到实际的物理内存地址. memblock内存分配器的创建在完成了E820机制检测到可用的内存地址范围以后, 调用e8...</div></div></div></a><a class="pagination-related" href="/2025/08/04/computer-fundamentals/Operating%20System/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux虚拟内存管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-04</div><div class="info-item-2">操作系统内存管理 - Linux虚拟内存管理</div></div><div class="info-2"><div class="info-item-1">虚拟内存管理以问题来引入  申请内存申请到的真的是物理内存吗 对虚拟内存的申请如何转化成对物理内存的访问? top命令输出进程的内存指标中VIRT和RES分别是什么含义 堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么 进程栈和线程栈是一个东西吗 malloc大概是怎么工作的  虚拟内存和物理页为什么要有虚拟内存 用户进程访问内核数据要加以限制 用户进程之间需要隔离 内存不足的时候swap到硬盘上, 保证系统可正常运行  虚拟地址空间到底是什么在内核中的定义, 每个进程的task_struct都有一个核心对象 - mm_struct类型的mm. 代表的就是进程的虚拟地址空间 1234struct task_struct &#123;    ...        struct mm_struct 	*mm;&#125;  在这个虚拟内存空间里面, 每一段已经分配出去的地址范围都是通过一个个虚拟内存区域VMA来表示, 也就是对应到内核中的数据结构vm_area_struct 12345struct vm_area_struct &#123;	unsigned long v...</div></div></div></a><a class="pagination-related" href="/2025/08/12/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="操作系统进程管理-Linux进程与线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-12</div><div class="info-item-2">操作系统进程管理-Linux进程与线程</div></div><div class="info-2"><div class="info-item-1">进程与线程进程的创建fork函数是linux中创建进程的核心函数, fork的原意是叉子, 也就是分叉. fork调用是程序执行的一个分叉点, 从这里开始, 原本的一个执行流变成了两个独立的执行流 创建的子进程继承了父进程的资源  打开的文件描述符 文件系统信息 …  创建的子进程在创建的时候是和父进程一样的内存空间, 会将父进程的地址空间也就是页表复制, 并复制所有的VMA, 但是标记为只读, 在修改的时候会触发page fault, 分配新的物理页, 复制数据, 更新页表项为可写 值得一提的是这里的继承和复制都是深拷贝, 也就是会将fs_struct, mm_struct, file_struct等资源都是深拷贝, 这里虽然是继承过去了, 但是实际上已经和父进程的资源是隔离的了, 只是在最开始的时候数据是完全相同的 doforkfork函数是以一个系统调用的形式存在的, 这个系统调用执行的内容就是执行dofork 1234SYSCALL_DEFINE0(fork)&#123;	return do_fork(SIGCHLD, 0, 0, NULL, NULL);&#125;  ...</div></div></div></a><a class="pagination-related" href="/2025/08/13/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/" title="操作系统进程加载(ELF)-Linux进程加载启动原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">操作系统进程加载(ELF)-Linux进程加载启动原理</div></div><div class="info-2"><div class="info-item-1">Linux进程加载启动原理可执行文件格式这里讲的都是linux中的可执行文件的格式, 不同的操作系统中的可执行文件的格式是不一样的, 这也是你在不同的平台上编译出来的可执行文件是不能跨平台执行的. 也是为什么如果要跨平台运行其他平台的可执行文件需要转义中间层.  Linux中的可执行文件是ELF(Executable and Linkable Format)文件, 其组成可以分成  ELF文件头 Program Header Table Segment Section   Section Header Table  下面查看的都是该程序的编译后的ELF文件 123456789#include &lt;stdio.h&gt;int data1;int data2 = 1;int main() &#123;        printf(&quot;hello, world&quot;);        return 0;&#125;  ELF文件头记录了整个文件中的属性信息, 可以通过下面的命令查看 1readelf --file-header &lt;file&gt;   可以看到...</div></div></div></a><a class="pagination-related" href="/2025/08/11/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="操作系统进程管理-进程实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">操作系统进程管理-进程实现原理</div></div><div class="info-2"><div class="info-item-1">进程实现原理进程是一个程序运行时的实例, 一个程序要运行起来, 需要硬盘, 内存, CPU, 网络等资源, 如果这些部分都有用户手动来管理, 开发一个程序会变成一个极其繁琐和困难的事情, 操作系统针对这些程序运行时需要的资源抽象出来了进程这个概念. 进程持有并统一管理所有一个程序要运行时需要的资源 对于资源的集合, 在概念中被称为PCB(Process Control Block), 而在Linux中对应的内核对象就是task_struct这个数据结构 123456789101112131415161718192021222324252627282930struct task_struct &#123;    // 1. 进程的状态    volatile long state;        // 2. 进程的pid    pid_t pid;    pid_t tgid;        //3. 和进程树的关系 (父进程, 子进程, 兄弟进程)    struct task_struct __rcu *parent;    struct listhead children; ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8epoll"><span class="toc-number">1.</span> <span class="toc-text">Linux中的同步阻塞IO与多路复用epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO"><span class="toc-number">1.1.</span> <span class="toc-text">Linux中的同步阻塞IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">等待接收消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">软中断模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8Epoll"><span class="toc-number">1.2.</span> <span class="toc-text">多路复用Epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">epoll内核对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BAepoll%E6%B7%BB%E5%8A%A0socket"><span class="toc-number">1.2.2.</span> <span class="toc-text">为epoll添加socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96epitem"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">分配并初始化epitem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEsocket%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">设置socket等待队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">插入红黑树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-wait%E7%AD%89%E5%BE%85%E6%8E%A5%E6%94%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">epoll_wait等待接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9D%A5%E4%BA%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">数据来了</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E6%94%B6%E5%88%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">将数据收到任务队列中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%B0%B1%E7%BB%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">查找就绪回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Csocket%E5%B0%B1%E7%BB%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">执行socket就绪回调函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/23/Architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" title="分布式架构-分布式共识算法">分布式架构-分布式共识算法</a><time datetime="2025-08-23T04:23:26.000Z" title="发表于 2025-08-23 12:23:26">2025-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/22/Architecture/%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式架构-事务-分布式事务">分布式架构-事务-分布式事务</a><time datetime="2025-08-22T05:52:26.000Z" title="发表于 2025-08-22 13:52:26">2025-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/20/Architecture/%E4%BA%8B%E5%8A%A1/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1/" title="分布式架构-事务-本地事务">分布式架构-事务-本地事务</a><time datetime="2025-08-20T11:11:26.000Z" title="发表于 2025-08-20 19:11:26">2025-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/14/computer-fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll">操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll</a><time datetime="2025-08-14T13:54:26.000Z" title="发表于 2025-08-14 21:54:26">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/13/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/" title="操作系统进程加载(ELF)-Linux进程加载启动原理">操作系统进程加载(ELF)-Linux进程加载启动原理</a><time datetime="2025-08-13T09:27:26.000Z" title="发表于 2025-08-13 17:27:26">2025-08-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Function</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"lang":"zh-CN","input_position":"top","emit_metadata":1,"reactions_enabled":1}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'fang-tech/fang-tech.github.io',
      'data-repo-id': 'R_kgDOPJD8XA',
      'data-category-id': 'DIC_kwDOPJD8XM4CswtE',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>