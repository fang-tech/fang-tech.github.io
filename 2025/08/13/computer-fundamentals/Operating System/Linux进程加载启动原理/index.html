<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统进程加载(ELF)-Linux进程加载启动原理 | Function's Blog</title><meta name="author" content="Function"><meta name="copyright" content="Function"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux进程加载启动原理可执行文件格式这里讲的都是linux中的可执行文件的格式, 不同的操作系统中的可执行文件的格式是不一样的, 这也是你在不同的平台上编译出来的可执行文件是不能跨平台执行的. 也是为什么如果要跨平台运行其他平台的可执行文件需要转义中间层.  Linux中的可执行文件是ELF(Executable and Linkable Format)文件, 其组成可以分成  ELF文件头">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统进程加载(ELF)-Linux进程加载启动原理">
<meta property="og:url" content="https://fang-tech.github.io/2025/08/13/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Function&#39;s Blog">
<meta property="og:description" content="Linux进程加载启动原理可执行文件格式这里讲的都是linux中的可执行文件的格式, 不同的操作系统中的可执行文件的格式是不一样的, 这也是你在不同的平台上编译出来的可执行文件是不能跨平台执行的. 也是为什么如果要跨平台运行其他平台的可执行文件需要转义中间层.  Linux中的可执行文件是ELF(Executable and Linkable Format)文件, 其组成可以分成  ELF文件头">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg">
<meta property="article:published_time" content="2025-08-13T09:27:26.000Z">
<meta property="article:modified_time" content="2025-08-16T04:09:34.200Z">
<meta property="article:author" content="Function">
<meta property="article:tag" content="Computer Fundamentals">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="Process">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统进程加载(ELF)-Linux进程加载启动原理",
  "url": "https://fang-tech.github.io/2025/08/13/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/",
  "image": "https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg",
  "datePublished": "2025-08-13T09:27:26.000Z",
  "dateModified": "2025-08-16T04:09:34.200Z",
  "author": [
    {
      "@type": "Person",
      "name": "Function",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><link rel="canonical" href="https://fang-tech.github.io/2025/08/13/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统进程加载(ELF)-Linux进程加载启动原理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> 项目</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Architecture/Distributed-Systems"><i class="fa-fw fa-solid fa-layer-group"></i><span> 分布式架构</span></a></li><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-laptop-code"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-cogs"></i><span> 计算机基础</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm"><i class="fa-fw fas fa-route"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/OS"><i class="fa-fw fas fa-desktop"></i><span> OS</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/Network"><i class="fa-fw fas fa-network-wired"></i><span> 计算机网络</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Function's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统进程加载(ELF)-Linux进程加载启动原理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> 项目</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Architecture/Distributed-Systems"><i class="fa-fw fa-solid fa-layer-group"></i><span> 分布式架构</span></a></li><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-laptop-code"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-cogs"></i><span> 计算机基础</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm"><i class="fa-fw fas fa-route"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/OS"><i class="fa-fw fas fa-desktop"></i><span> OS</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/Network"><i class="fa-fw fas fa-network-wired"></i><span> 计算机网络</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统进程加载(ELF)-Linux进程加载启动原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-13T09:27:26.000Z" title="发表于 2025-08-13 17:27:26">2025-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-16T04:09:34.200Z" title="更新于 2025-08-16 12:09:34">2025-08-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/">Computer Fundamentals</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/OS/">OS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Fundamentals/OS/Process/">Process</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Linux进程加载启动原理"><a href="#Linux进程加载启动原理" class="headerlink" title="Linux进程加载启动原理"></a>Linux进程加载启动原理</h1><h2 id="可执行文件格式"><a href="#可执行文件格式" class="headerlink" title="可执行文件格式"></a>可执行文件格式</h2><p>这里讲的都是linux中的可执行文件的格式, 不同的操作系统中的可执行文件的格式是不一样的, 这也是你在不同的平台上编译出来的可执行文件是不能跨平台执行的. 也是为什么如果要跨平台运行其他平台的可执行文件需要转义中间层.</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250813181241.png"></p>
<p>Linux中的可执行文件是ELF(Executable and Linkable Format)文件, 其组成可以分成</p>
<ul>
<li>ELF文件头</li>
<li>Program Header Table</li>
<li>Segment<ul>
<li>Section</li>
</ul>
</li>
<li>Section Header Table</li>
</ul>
<p>下面查看的都是该程序的编译后的ELF文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> data1;</span><br><span class="line"><span class="type">int</span> data2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ELF文件头"><a href="#ELF文件头" class="headerlink" title="ELF文件头"></a>ELF文件头</h3><p>记录了整个文件中的属性信息, 可以通过下面的命令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf --file-header &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250813175745.png"></p>
<p>可以看到前面的魔数用于标识这个文件是什么格式的文件</p>
<p>对于ELF的整体的描述: </p>
<ul>
<li>Type: 有多种ELF文件, 比如动态链接库等, 其中EXEC格式的才是可执行文件</li>
<li>OS&#x2F;ABI: 记录的操作系统的信息</li>
<li>Machine: 机器的CPU的位数</li>
<li>Entry point address: 程序的入口地址(往往不是main函数的地址), 这里是0x400440</li>
</ul>
<p>关于program headers和section headers的描述</p>
<ul>
<li>Start of program headers: program header的入口地址</li>
<li>Start of section headers: section header的入口地址</li>
<li>Size of this header: ELF文件头的大小</li>
</ul>
<h3 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h3><p>ELF文件中最重要的组成单位是一个个的Section, 每一个Section都是由编译链接器生成的, 都有不同的用处, 编译器会将我们写的代码的编译后放入到.text Section中, 将全局变量放入到 .data Section或者是.bss Section中</p>
<p>但是对于操作系统来说, 它并不关注具体的Section中的内容是什么, 只关注这块内容以何种权限加载到内存中, 读, 写, 执行等权限属性. 因此编译器将具有相同权限的Section组合成一个Segment, 以便操作系统更快的加载</p>
<p>Program Header Table记录了对于Segment的描述, 通过下面的命令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf --program-headers (-l) &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250813175635.png"></p>
<p>通过下面的Section to Segment mapping能查看到为我们的这个程序有9个Segment, 每个Segment里面放了哪些Section</p>
<p>上面的信息记录了每个Segment的一些信息</p>
<ul>
<li>Offset: 该Segment在二进制文件中的起始地址</li>
<li>VirtAddr: 表示加载到虚拟内存中后的地址</li>
<li>FileSiz: 当前段的大小</li>
<li>Flag: 当前段的权限类型, E表示可执行, R表示可读, W表示可写</li>
</ul>
<h3 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h3><p>记录的自然就是Section的一些信息, 通过下面的命令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf --section-headers &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250813175726.png"></p>
<ul>
<li>offset: 当前的Section在二进制文件中的位置</li>
</ul>
<blockquote>
<p>这是权限flag的描述</p>
<p>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>  L (link order), O (extra OS processing required), G (group), T (TLS),<br>  C (compressed), x (unknown), o (OS specific), E (exclude),<br>  l (large), p (processor specific)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250813175926.png">	能看到我们程序中的各种信息放在的位置, 其中.text存放了我们编译后的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未初始化变量放在.bss Section</span></span><br><span class="line"><span class="type">int</span> data1;</span><br><span class="line"><span class="comment">// 初始化变量放在.data Section</span></span><br><span class="line"><span class="type">int</span> data2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> ...</span><br></pre></td></tr></table></figure>

<h3 id="入口进一步查看"><a href="#入口进一步查看" class="headerlink" title="入口进一步查看"></a>入口进一步查看</h3><p>我们前面看到程序的入口是 0x401040, 我们能借助nm命令进一步查看可执行文件中的符号及其地址信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -n &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250813180319.png"></p>
<p>我们能看到0x400440是_start的地址, 并且还能看到data2和data1, 以及main函数的地址</p>
<p>其中_start是glibc的库函数, 是一个汇编函数, 一开始执行了一些寄存器和栈操作, 然后进入到<code>__libc_start_main</code>进行程序的启动</p>
<p>这个函数中做了一些准备工作将argc, argv, 程序的构造函数<code>__libc_csu_init</code>, 析构函数<code>__libc_csu_fini</code>和<code>main</code>函数都通过参数传递给<code>__libc_start_main</code></p>
<p>最后进入到<code>generic_start_main</code>中完成进入main</p>
<h2 id="加载并启动用户进程"><a href="#加载并启动用户进程" class="headerlink" title="加载并启动用户进程"></a>加载并启动用户进程</h2><h3 id="shell启动用户进程"><a href="#shell启动用户进程" class="headerlink" title="shell启动用户进程"></a>shell启动用户进程</h3><p>在编译完程序以后, 下一步就是将这个程序启动起来, 一般来说我们都是通过shell将我们的程序启动, shell启动程序一般来讲是通过fork + execve的形式来加载并运行程序的.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    ...;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>) &#123;</span><br><span class="line">        execve(<span class="string">&quot;helloworld&quot;</span>, argv, envp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过fork创建一个子进程, 然后子进程通过exrcve系统调用启动我们要运行的用户进程</p>
<h3 id="Linux可执行文件加载器"><a href="#Linux可执行文件加载器" class="headerlink" title="Linux可执行文件加载器"></a>Linux可执行文件加载器</h3><p>Linux上并不是只能运行ELF文件, 在启动的时候, Linux会将自己支持的所有可执行文件类型的解析器都加载上, 并使用一个formats双向链表将它们保存起来</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120715.png"></p>
<p>Linux中支持的可执行文件格式有三类</p>
<ul>
<li>ELF</li>
<li>aout: 主要是为了和以前兼容, 不支持动态链接, 被ELF取代</li>
<li>EM86: 主要作用是Alpha主机上运行Intel的二进制文件</li>
</ul>
<p>我们这里主要探讨ELF的加载器elf_format</p>
<p>Linux中每一个加载器都通过一个linux_binfmt结构来表示, 其中规定了load_binary函数指针, 加载崩溃文件的core_dump函数指针等.</p>
<p>然后在elf_format中将这些函数指针指向具体的elf的加载函数, 比如load_binary指向的就是load_elf_binary函数, 这个函数也是ELF加载的入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> (*load_binary)(<span class="keyword">struct</span> linux_binprm *);</span><br><span class="line">    <span class="type">int</span> (*load_shlib)(<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*core_dump)(<span class="keyword">struct</span> coredump_params *cprm);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> =</span> &#123;</span><br><span class="line">    .module = THIS_MODULE,</span><br><span class="line">    .load_binary = load_elf_binary,</span><br><span class="line">    .load_shlib = load_elf_library,</span><br><span class="line">    .core_dump = elf_core_dump,</span><br><span class="line">    .min_coredump = ELF_EXEC_PAGESIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加载器在初始化的时候会通过register_binfmt函数进行注册, 将加载器挂载到全局加载器列表formats全局链表中</p>
<h3 id="execve加载用户程序"><a href="#execve加载用户程序" class="headerlink" title="execve加载用户程序"></a>execve加载用户程序</h3><p><code>execve</code>是一个系统调用, 执行到的核心函数是<code>do_execve(getname(filename), argv, envp);</code>, 其中的filename是要执行的ELF文件的名字, argv是参数列表, envp是环境变量. 在<code>do_execve</code>中进入到<code>do_execve_common</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:fs/exec.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_execveat_common</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> filename *filename, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// linux_binprm 结构⽤于保存加载⼆进制⽂件时使⽤的参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> *<span class="title">bprm</span>;</span></span><br><span class="line">    <span class="comment">// 申请并初始化 brm 对象值</span></span><br><span class="line">    bprm = alloc_bprm(fd, filename);</span><br><span class="line">    bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class="line">    bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class="line">    ...;</span><br><span class="line">    <span class="comment">// 执⾏加载</span></span><br><span class="line">    bprm_execve(bprm, fd, filename, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的核心步骤是</p>
<ol>
<li>申请并初始化linux_brpm对象</li>
<li>然后通过bprm_execve读取可执行文件的文件头128字节, 并选择加载器</li>
</ol>
<h4 id="alloc-brpm初始化linux-binprm对象"><a href="#alloc-brpm初始化linux-binprm对象" class="headerlink" title="alloc_brpm初始化linux_binprm对象"></a>alloc_brpm初始化linux_binprm对象</h4><p>在这个函数中主要做了</p>
<ol>
<li>调用<code>kzalloc</code>为brpm申请内存</li>
<li>然后调用<code>brpm_mm_init</code>对新申请出来的对象进行初始化<ol>
<li>申请一个全新地址空间的mm_struct对象</li>
<li>调用<code>__brpm_mm_init</code>申请一个页的进程栈内存(也就是申请了一个4KB的VMA), 会把栈的指针记录到bprm-&gt;p中</li>
</ol>
</li>
</ol>
<p>这里的linux_binprm bprm内核对象是一个进程加载的过程中的临时对象, 在加载进程的时候保存加载二进制文件使用的参数等信息, 以及保存为新进程申请的虚拟地址空间, 新进程的栈也会在这个时候申请并交给它保存一会儿, 等进程加载就绪的时候, 这个数据结构就没什么用了</p>
<h4 id="bprm-execve执行加载"><a href="#bprm-execve执行加载" class="headerlink" title="bprm_execve执行加载"></a>bprm_execve执行加载</h4><p>会进入到search_binary_handler函数</p>
<ol>
<li>通过文件头, 判断要加载的可执行文件的格式</li>
<li>寻找合适的加载器, 尝试加载</li>
</ol>
<p>这里详细说明下是怎么寻找合适的加载器的, 抽象的来了, Linux是遍历formats链表中所有已经注册的加载器, 尝试对当前文件加载, 如果加载成功了就return, 不然就下一个加载器, 虽然有点低效, 但是确实是这么运行的</p>
<h3 id="ELF文件加载过程"><a href="#ELF文件加载过程" class="headerlink" title="ELF文件加载过程"></a>ELF文件加载过程</h3><p>现在我们已经找到了elf_format加载器, 并且将args和env以及要加载的文件还有mm以及一个栈区都准备好了, 我们要正式开始加载这个文件了.</p>
<p>要执行的核心函数就是load_binary指向的load_elf_binary</p>
<h4 id="读取文件头"><a href="#读取文件头" class="headerlink" title="读取文件头"></a>读取文件头</h4><p>前面do_execve函数的开头调用的do_execve_common中, 已经将ELF文件头 读取到bprm-&gt;buf中了, 所以这里直接拷贝访问这段内存就好了</p>
<p>解析完了以后, 对头部进行一系列的合法性的判断, 如果不合法直接就退出</p>
<p>合法则申请interp_elf_ex对象</p>
<h4 id="读取Progarm-Header"><a href="#读取Progarm-Header" class="headerlink" title="读取Progarm Header"></a>读取Progarm Header</h4><p>读取完文件头以后就是读记录了Segment信息的Program Header</p>
<p>根据文件头的信息, 得出Program Header的数量以及大小, 然后计算出来需要申请多大的内存将program header保存起来并返回, 这里是保存到elf_phdata中(这里是通过kmalloc在伙伴系统中直接分配物理内存, 不会触发缺页中断)</p>
<h4 id="清空父进程继承来的资源"><a href="#清空父进程继承来的资源" class="headerlink" title="清空父进程继承来的资源"></a>清空父进程继承来的资源</h4><p>在fork系统调用创建出来的进程中, 包含了很多原进程的信息, 比如打开的文件描述符, 老的地址空间, 信号表等, 这些在新的程序运行时没有用, 需要清空一下</p>
<p>这里是在load_elf_binary中调用begin_new_exec来清空父进程继承来的资源, 这个函数执行的内容是</p>
<ol>
<li>确保文件表不共享</li>
<li>释放掉所有旧的mmap, 并替换成新的在bprm-&gt;mm</li>
<li>确保信号表不共享</li>
</ol>
<p>然后再将新的栈也设置到新进程上</p>
<h4 id="执行Segment加载"><a href="#执行Segment加载" class="headerlink" title="执行Segment加载"></a>执行Segment加载</h4><p>接下来, 加载器会将ELF文件中LOAD类型的Segment都加载到内存中来, 使用elf_map在虚拟空间中为其分配地址, 等访问的时候发生缺页中断加载磁盘文件中的代码或数据. 计算start_code, start_data等mm_struct所需要的各个的成员地址, 最后设置虚拟地址空间中的代码段.</p>
<blockquote>
<p>只有LOAD类型的Segment是需要被映射到内存中的</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120803.png"></p>
<h4 id="数据内存申请-堆初始化"><a href="#数据内存申请-堆初始化" class="headerlink" title="数据内存申请&amp;堆初始化"></a>数据内存申请&amp;堆初始化</h4><p>在load_elf_binary中调用set_brk为堆申请内存</p>
<p>这个函数做了两件事情</p>
<ol>
<li>为数据段申请虚拟内存</li>
<li>初始化堆的指针, 这个时候因为堆还是空的, brk和start_brk是相同的值</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250816120930.png"></p>
<h4 id="跳转到程序入口执行"><a href="#跳转到程序入口执行" class="headerlink" title="跳转到程序入口执行"></a>跳转到程序入口执行</h4><p>ELF文件头中记录了程序的入口地址, 如果是非动态链接加载的过程, 入口地址就是这个. 如果是动态链接, 由动态链接器先来加载运行, 然后再回调到程序的代码入口地址.</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="可执行文件格式-1"><a href="#可执行文件格式-1" class="headerlink" title="可执行文件格式"></a>可执行文件格式</h2><p>在Linux中可执行文件主要是ELF(Executable and Linkable Format)格式</p>
<p>这个格式由</p>
<ul>
<li>文件头: 记录了整个文件的一些编译的信息, 以及程序的入口地址, Program Header Table以及Section Header Table的大小及开始位置</li>
<li>Section: ELF文件中最基础的单位, 我们的代码中的各个部分最后都会在编译后被放入到某一个Section中, 其中函数会被放入到.text中, 全局变量会被放入到.data, .bss中</li>
<li>Segment: 不同的Section有不同的权限(E, R, W), Linux为了能更快的加载, 将相同权限的Section放在一起组合成了一个Segment</li>
<li>Program Header Table: 记录了每个Segment的类型, 偏移量, 大小, 权限等信息</li>
<li>Section Header Table: 记录了每个Section的类型, 偏移量, 大小, 权限等信息</li>
</ul>
<h2 id="shell是怎么将程序执行起来的"><a href="#shell是怎么将程序执行起来的" class="headerlink" title="shell是怎么将程序执行起来的"></a>shell是怎么将程序执行起来的</h2><p>Linux在初始化的时候, 会将所有的支持的可执行文件的加载器都注册到一个全局链表中, 对于ELF, 它的加载器在内核中定义为elf_format, 它加载二进制文件的入口是load_elf_binary函数</p>
<p>shell进程一般是通过fork + execve的形式来加载并运行新的进程的. 执行fork系统调用会创建出来一个新进程, 不过新的进程和原来的进程几乎一摸一样, 在这个基础上, 我们想让新的进程运行我们ELF文件, 就需要execve系统调用</p>
<p>通过execve系统调用, 我们首先会进入到do_execve函数中, 然后进入到核心函数do_execve_common</p>
<ul>
<li><code>alloc_brpm</code>申请并初始化bprm内核临时对象, 这个对象是加载ELF文件的时候的临时数据结构<ul>
<li>这一步会为bprm内核对象分配物理内存, 然后创建mm_struct, 并创建一个4KB的VMA用作进程栈</li>
</ul>
</li>
<li><code>bprm_execve</code>进入到<code>search_binary_handler</code>, 先通过文件头判断文件的格式, 然后寻找合适的加载器, 并加载文件, 这里我们就进入到了加载器的load_binary函数中了, 对于elf文件, 就进入到了load_elf_binary函数</li>
</ul>
<p>接下来就是加载ELF文件的过程, 基本就是解析并保存ELF文件中的每个部分的过程</p>
<ul>
<li>读取文件头, 这里获取到程序的入口, Program Header, Section Header的位置, 同时会进行文件的合法性检查, 如果不合法直接退出, 会创建内核对象将解析的结果保存起来</li>
<li>然后就是读取Program Header, 并加载到物理内存中</li>
<li>然后清空父进程继承来的资源, 并将bprm中的mm和栈VMA设置到新的进程上</li>
<li>执行Segment加载, 将LOAD类型的Segment建立内存mmap, 将磁盘上的程序文件中映射到虚拟内存空间中, 这里会计算mm_struct中data等段指针的位置, 并设置到mm_struct上, 这里还会为代码段申请VMA</li>
<li>接下来调用<code>set_brk</code>为数据段申请虚拟内存VMA, 并且初始化brk和start_brk这两个堆区的指针(这个时候是相等的, 因为堆还是空的)</li>
<li>最后就是跳转到文件头中的程序的入口地址, 执行程序了</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Computer-Fundamentals/">Computer Fundamentals</a><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/Process/">Process</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/14/computer-fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll</div></div><div class="info-2"><div class="info-item-1">Linux中的同步阻塞IO与多路复用epollLinux中的同步阻塞IO在完成了socket的创建, 三次握手的过程以后, 通信双方建立了连接, 接下来的过程就是通信的过程了, 相互传递数据, 使用同步阻塞进行通信的过程其实就是简单地直接使用recv阻塞式地等待数据发送到来, 发送到了再接收处理  等待接收消息通过strace能发现recv执行的系统调用是recvform, 进入到系统调用以后, 用户进程就进入到了内核态, 执行一系列的内核协议层函数, 然后到socket对象的接收队列中查看是否有数据, 没有数据的话, 就把自己添加到socket对应的等待队列中. 最后让出CPU  这里的关键是recvfrom最后是怎么将自己的进程给阻塞调用的 在recvfrom系统调用中根据fd找到对应的socket对象以后, 调用sock_recvmsg sock_recvmsg -&gt; __sock_recvmsg -&gt; __sock_recvmsg_nosec 在最后的方法中, 调用到了socket-&gt;ops-&gt;recvmsg  由socket对象图, 我们能知道这...</div></div></div></a><a class="pagination-related" href="/2025/08/12/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="操作系统进程管理-Linux进程与线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">操作系统进程管理-Linux进程与线程</div></div><div class="info-2"><div class="info-item-1">进程与线程进程的创建fork函数是linux中创建进程的核心函数, fork的原意是叉子, 也就是分叉. fork调用是程序执行的一个分叉点, 从这里开始, 原本的一个执行流变成了两个独立的执行流 创建的子进程继承了父进程的资源  打开的文件描述符 文件系统信息 …  创建的子进程在创建的时候是和父进程一样的内存空间, 会将父进程的地址空间也就是页表复制, 并复制所有的VMA, 但是标记为只读, 在修改的时候会触发page fault, 分配新的物理页, 复制数据, 更新页表项为可写 值得一提的是这里的继承和复制都是深拷贝, 也就是会将fs_struct, mm_struct, file_struct等资源都是深拷贝, 这里虽然是继承过去了, 但是实际上已经和父进程的资源是隔离的了, 只是在最开始的时候数据是完全相同的 doforkfork函数是以一个系统调用的形式存在的, 这个系统调用执行的内容就是执行dofork 1234SYSCALL_DEFINE0(fork)&#123;	return do_fork(SIGCHLD, 0, 0, NULL, NULL);&#125;  ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/12/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="操作系统进程管理-Linux进程与线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-12</div><div class="info-item-2">操作系统进程管理-Linux进程与线程</div></div><div class="info-2"><div class="info-item-1">进程与线程进程的创建fork函数是linux中创建进程的核心函数, fork的原意是叉子, 也就是分叉. fork调用是程序执行的一个分叉点, 从这里开始, 原本的一个执行流变成了两个独立的执行流 创建的子进程继承了父进程的资源  打开的文件描述符 文件系统信息 …  创建的子进程在创建的时候是和父进程一样的内存空间, 会将父进程的地址空间也就是页表复制, 并复制所有的VMA, 但是标记为只读, 在修改的时候会触发page fault, 分配新的物理页, 复制数据, 更新页表项为可写 值得一提的是这里的继承和复制都是深拷贝, 也就是会将fs_struct, mm_struct, file_struct等资源都是深拷贝, 这里虽然是继承过去了, 但是实际上已经和父进程的资源是隔离的了, 只是在最开始的时候数据是完全相同的 doforkfork函数是以一个系统调用的形式存在的, 这个系统调用执行的内容就是执行dofork 1234SYSCALL_DEFINE0(fork)&#123;	return do_fork(SIGCHLD, 0, 0, NULL, NULL);&#125;  ...</div></div></div></a><a class="pagination-related" href="/2025/08/11/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="操作系统进程管理-进程实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">操作系统进程管理-进程实现原理</div></div><div class="info-2"><div class="info-item-1">进程实现原理进程是一个程序运行时的实例, 一个程序要运行起来, 需要硬盘, 内存, CPU, 网络等资源, 如果这些部分都有用户手动来管理, 开发一个程序会变成一个极其繁琐和困难的事情, 操作系统针对这些程序运行时需要的资源抽象出来了进程这个概念. 进程持有并统一管理所有一个程序要运行时需要的资源 对于资源的集合, 在概念中被称为PCB(Process Control Block), 而在Linux中对应的内核对象就是task_struct这个数据结构 123456789101112131415161718192021222324252627282930struct task_struct &#123;    // 1. 进程的状态    volatile long state;        // 2. 进程的pid    pid_t pid;    pid_t tgid;        //3. 和进程树的关系 (父进程, 子进程, 兄弟进程)    struct task_struct __rcu *parent;    struct listhead children; ...</div></div></div></a><a class="pagination-related" href="/2025/08/14/computer-fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll</div></div><div class="info-2"><div class="info-item-1">Linux中的同步阻塞IO与多路复用epollLinux中的同步阻塞IO在完成了socket的创建, 三次握手的过程以后, 通信双方建立了连接, 接下来的过程就是通信的过程了, 相互传递数据, 使用同步阻塞进行通信的过程其实就是简单地直接使用recv阻塞式地等待数据发送到来, 发送到了再接收处理  等待接收消息通过strace能发现recv执行的系统调用是recvform, 进入到系统调用以后, 用户进程就进入到了内核态, 执行一系列的内核协议层函数, 然后到socket对象的接收队列中查看是否有数据, 没有数据的话, 就把自己添加到socket对应的等待队列中. 最后让出CPU  这里的关键是recvfrom最后是怎么将自己的进程给阻塞调用的 在recvfrom系统调用中根据fd找到对应的socket对象以后, 调用sock_recvmsg sock_recvmsg -&gt; __sock_recvmsg -&gt; __sock_recvmsg_nosec 在最后的方法中, 调用到了socket-&gt;ops-&gt;recvmsg  由socket对象图, 我们能知道这...</div></div></div></a><a class="pagination-related" href="/2025/07/25/computer-fundamentals/Operating%20System/IO-%E9%9B%B6%E6%8B%B7%E8%B4%9D/" title="操作系统I&#x2F;O - 零拷贝"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">操作系统I&#x2F;O - 零拷贝</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O的演进DMA技术在最开始的时候, 读一个文件的过程是   用户进程调用read(), 切换到内核态, CPU向磁盘发起IO请求 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信号给CPU CPU将数据从磁盘数据控制器缓冲区中拷贝到 PageCache CPU将数据从PageCache中拷贝到用户缓冲区 read()调用返回, 切换到用户态  一共发生了两次用户态和内核态的上下文切换, 发生了两次拷贝, 并且数据的搬运也是交给CPU来操作的, 占用了大量的CPU的时间, 导致了CPU吞吐量下降 解决方式就是引入了DMA(Direct Memory Access)直接内存访问技术,  我们将把数据从磁盘控制器缓冲区搬运到PageCache的工作交给了DMA控制器来进行  现在的读一个文件的流程变成了  用户进程调用read(), 切换到内核态, 向操作系统发起IO请求, 将数据读取到自己的内存缓冲区中, 进程进入到了阻塞状态 CPU收到操作系统发送的指令以后, 将请求发送给DMA, DMA再进一步发送给磁盘 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信...</div></div></div></a><a class="pagination-related" href="/2025/08/09/computer-fundamentals/Operating%20System/Linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux物理内存篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-09</div><div class="info-item-2">操作系统内存管理 - Linux物理内存篇</div></div><div class="info-2"><div class="info-item-1">Linux物理内存物理内存检测在物理内存这个硬件和操作系统之间, 还存在着一个固件层(firmware)也叫BIOS. 它负责硬件自检, 初始化所有硬件设备, 加载操作系统引导程序, 将控制权移交给操作系统并提供结构供操作系统读取硬件信息. 操作系统所需的内存等硬件信息都是通过固件来获取的 在固件ACPI接口规范中定义了探测内存的物理分布规范. 内核请求中断15H , 并设置操作码为E820H,  因为操作码是E820, 所以这个机制也被称为E820 会在detect_memory_e820函数发出15号中断并处理所有结果, 把内存地址范围保存到boot_params.e820_table对象中. boot_params只是一个中间数据, 专门还有一个e820_table全局数据结构来保存内存地址范围, 在e820__memory_setup中会将boot_params.e820_table保存到e820_table中, 并打印出来. 服务器能通过mseg命令来查看到实际的物理内存地址. memblock内存分配器的创建在完成了E820机制检测到可用的内存地址范围以后, 调用e8...</div></div></div></a><a class="pagination-related" href="/2025/08/04/computer-fundamentals/Operating%20System/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux虚拟内存管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-04</div><div class="info-item-2">操作系统内存管理 - Linux虚拟内存管理</div></div><div class="info-2"><div class="info-item-1">虚拟内存管理以问题来引入  申请内存申请到的真的是物理内存吗 对虚拟内存的申请如何转化成对物理内存的访问? top命令输出进程的内存指标中VIRT和RES分别是什么含义 堆栈的大小限制是多大, 当堆栈发生溢出以后应用程序会发生什么 进程栈和线程栈是一个东西吗 malloc大概是怎么工作的  虚拟内存和物理页为什么要有虚拟内存 用户进程访问内核数据要加以限制 用户进程之间需要隔离 内存不足的时候swap到硬盘上, 保证系统可正常运行  虚拟地址空间到底是什么在内核中的定义, 每个进程的task_struct都有一个核心对象 - mm_struct类型的mm. 代表的就是进程的虚拟地址空间 1234struct task_struct &#123;    ...        struct mm_struct 	*mm;&#125;  在这个虚拟内存空间里面, 每一段已经分配出去的地址范围都是通过一个个虚拟内存区域VMA来表示, 也就是对应到内核中的数据结构vm_area_struct 12345struct vm_area_struct &#123;	unsigned long v...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Linux进程加载启动原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">可执行文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">ELF文件头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Program-Header-Table"><span class="toc-number">1.1.2.</span> <span class="toc-text">Program Header Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Section-Header-Table"><span class="toc-number">1.1.3.</span> <span class="toc-text">Section Header Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">入口进一步查看</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%B9%B6%E5%90%AF%E5%8A%A8%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">加载并启动用户进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E5%90%AF%E5%8A%A8%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">shell启动用户进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">Linux可执行文件加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execve%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">execve加载用户程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#alloc-brpm%E5%88%9D%E5%A7%8B%E5%8C%96linux-binprm%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">alloc_brpm初始化linux_binprm对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bprm-execve%E6%89%A7%E8%A1%8C%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">bprm_execve执行加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">ELF文件加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">读取文件头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96Progarm-Header"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">读取Progarm Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%BB%A7%E6%89%BF%E6%9D%A5%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">清空父进程继承来的资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8CSegment%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">执行Segment加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7-%E5%A0%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">数据内存申请&amp;堆初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">跳转到程序入口执行</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">2.1.</span> <span class="toc-text">可执行文件格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell%E6%98%AF%E6%80%8E%E4%B9%88%E5%B0%86%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84"><span class="toc-number">2.2.</span> <span class="toc-text">shell是怎么将程序执行起来的</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/23/Architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" title="分布式架构-分布式共识算法">分布式架构-分布式共识算法</a><time datetime="2025-08-23T04:23:26.000Z" title="发表于 2025-08-23 12:23:26">2025-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/22/Architecture/%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式架构-事务-分布式事务">分布式架构-事务-分布式事务</a><time datetime="2025-08-22T05:52:26.000Z" title="发表于 2025-08-22 13:52:26">2025-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/20/Architecture/%E4%BA%8B%E5%8A%A1/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1/" title="分布式架构-事务-本地事务">分布式架构-事务-本地事务</a><time datetime="2025-08-20T11:11:26.000Z" title="发表于 2025-08-20 19:11:26">2025-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/14/computer-fundamentals/Operating%20System/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll">操作系统网络IO-Linux中的同步阻塞IO与多路复用epoll</a><time datetime="2025-08-14T13:54:26.000Z" title="发表于 2025-08-14 21:54:26">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/13/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/" title="操作系统进程加载(ELF)-Linux进程加载启动原理">操作系统进程加载(ELF)-Linux进程加载启动原理</a><time datetime="2025-08-13T09:27:26.000Z" title="发表于 2025-08-13 17:27:26">2025-08-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Function</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"lang":"zh-CN","input_position":"top","emit_metadata":1,"reactions_enabled":1}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'fang-tech/fang-tech.github.io',
      'data-repo-id': 'R_kgDOPJD8XA',
      'data-category-id': 'DIC_kwDOPJD8XM4CswtE',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>