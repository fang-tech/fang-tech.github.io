<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>走难 | 走难</title><meta name="author" content="Func"><meta name="copyright" content="Func"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="应用层2.1 应用层原理C&#x2F;S 结构  不对等的结构, S是核心  随着用户的增加, 达到一定阈值后, 性能会有断崖式的下降   P2P 结构 -&gt; 对等体  关系是对等  随着用户的增加, 性能会能够维持   混合结构  举例说明  注册, 目录等是集中式的  用户的之间的通信是对等的    在对等体的某次通信中, peer可能是充当服务端, 也可能充当客户端  分布式应用进程需">
<meta property="og:type" content="article">
<meta property="og:title" content="走难">
<meta property="og:url" content="https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/Chapter2-Application-layer/index.html">
<meta property="og:site_name" content="走难">
<meta property="og:description" content="应用层2.1 应用层原理C&#x2F;S 结构  不对等的结构, S是核心  随着用户的增加, 达到一定阈值后, 性能会有断崖式的下降   P2P 结构 -&gt; 对等体  关系是对等  随着用户的增加, 性能会能够维持   混合结构  举例说明  注册, 目录等是集中式的  用户的之间的通信是对等的    在对等体的某次通信中, peer可能是充当服务端, 也可能充当客户端  分布式应用进程需">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg">
<meta property="article:published_time" content="2025-07-08T15:02:57.427Z">
<meta property="article:modified_time" content="2024-10-21T14:38:51.282Z">
<meta property="article:author" content="Func">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/Chapter2-Application-layer/",
  "image": "https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg",
  "datePublished": "2025-07-08T15:02:57.427Z",
  "dateModified": "2024-10-21T14:38:51.282Z",
  "author": [
    {
      "@type": "Person",
      "name": "Func",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://raw.githubusercontent.com/fang-tech/Pic/main/img/pngtree-round-logo-with-mountains-and-water-vector-png-image_7031662.png"><link rel="canonical" href="https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/Chapter2-Application-layer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '走难',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">271</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fas fa-music"></i><span> Java</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-video"></i><span> Spring</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/fang-tech/Pic/main/img/psc.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">走难</span></a><a class="nav-page-title" href="/"><span class="site-name">走难</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fas fa-music"></i><span> Java</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-video"></i><span> Spring</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-08T15:02:57.427Z" title="发表于 2025-07-08 23:02:57">2025-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-21T14:38:51.282Z" title="更新于 2024-10-21 22:38:51">2024-10-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="2-1-应用层原理"><a href="#2-1-应用层原理" class="headerlink" title="2.1 应用层原理"></a>2.1 应用层原理</h2><p>C&#x2F;S 结构</p>
<ul>
<li><p>不对等的结构, S是核心</p>
</li>
<li><p>随着用户的增加, 达到一定阈值后, 性能会有断崖式的下降</p>
</li>
</ul>
<p>P2P 结构 -&gt; 对等体</p>
<ul>
<li><p>关系是对等</p>
</li>
<li><p>随着用户的增加, 性能会能够维持</p>
</li>
</ul>
<p>混合结构</p>
<ul>
<li><p>举例说明</p>
<ul>
<li><p>注册, 目录等是集中式的</p>
</li>
<li><p>用户的之间的通信是对等的</p>
</li>
</ul>
</li>
<li><p>在对等体的某次通信中, peer可能是充当服务端, 也可能充当客户端</p>
</li>
<li><p>分布式应用进程需要解决的问题</p>
<ul>
<li>问题一 : 进程标识 (用于标识你的是唯一的, 这样能保证不会发送错位置), 寻址 (别人该怎么找到你, 相当于找到你的住房的地图)</li>
<li>问题二 : 应用层的下层传输层是怎么提供服务的, 从而使应用层之间可以传输信息</li>
<li>问题三 : 怎么定义报文的形式, 接到报文后的行为 -&gt; 协议</li>
</ul>
</li>
<li><p>寻址一个应用进程的三个要素</p>
<ol>
<li>IP地址</li>
<li>TCP还是UDP</li>
<li>TCP或UDP的端口号</li>
</ol>
</li>
<li><p>需要传递的信息</p>
<ul>
<li>发的什么</li>
<li>谁发的</li>
<li>发给谁</li>
</ul>
</li>
<li><p>为了减少层间的信息传输数量, 我们引入了socket, 它在计算计上的物理体现就是一个整数</p>
<ul>
<li>对于TCP : 就会创建一个整数用于映射 (我的主机ip, 端口号, 对方的主机ip. 端口号) 这个四元组</li>
<li>对于UDP : 就是一个(对方的IP, 进程端口号) 这个二元组</li>
<li>这里的机制类似于C语言中传输大型的struct, 比起将整个struct传输进去, 我们更倾向于传输一个地址, 通过这个简短的地址, 我们就能找到那个大的变量</li>
<li>接下来的收发, 我们都只用传递那个socket值</li>
</ul>
</li>
<li><p>TCP socket : 用于指明应用进程会话的本地显示</p>
</li>
<li><p>UDP socket : 仅代表一个端节点, , 是无连接的, 发送的内容里就必须有对方的ip和端口号</p>
</li>
<li><p>应用对于协议的选择的四个考量因素</p>
<ul>
<li>数据丢失率</li>
<li>安全性</li>
<li>吞吐</li>
<li>延迟</li>
<li>举例说明<ul>
<li>文件传输 -&gt; 数据不能有丢失, 对吞吐需求不大, 延迟同样, 安全性可能有要求</li>
<li>交互式游戏 -&gt; 对延迟敏感, 容忍丢失, 吞吐量小</li>
<li>直播 -&gt; 容忍丢失, 对吞吐量的要求高, 同时延迟不能超过0.1s</li>
<li>实时电话 -&gt; 容忍丢失, 对吞吐量要求较高, 延迟要求同上</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>TCP和UDP都是明文传输, 对于安全性没有任何的保证</p>
</li>
</ul>
<h2 id="2-2-Web-and-HTTP-port-80"><a href="#2-2-Web-and-HTTP-port-80" class="headerlink" title="2.2 Web and HTTP : port &#x3D; 80"></a>2.2 Web and HTTP : port &#x3D; 80</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul>
<li><p>Uniform Resource locator 统一资源定位符</p>
</li>
<li><p>格式 : Prot(协议名) : &#x2F;&#x2F;user:<a href="mailto:&#x70;&#x73;&#119;&#x40;&#x77;&#119;&#x77;&#46;&#115;&#x6f;&#109;&#101;&#x53;&#99;&#x68;&#x6f;&#111;&#108;&#x2e;&#x65;&#x64;&#117;">psw@www.someSchool.edu</a>(主机名)&#x2F;someDept(路径名)&#x2F;pic.gitf:port(端口, 因为Web引用有默认的端口号, 一般端口号不需要指定)</p>
</li>
</ul>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="非持久化的HTTP连接"><a href="#非持久化的HTTP连接" class="headerlink" title="非持久化的HTTP连接"></a>非持久化的HTTP连接</h4><ul>
<li><p>非持久化的连接的通讯过程</p>
<ol>
<li><p>C -&gt; S 请求建立连接 (TCP)</p>
</li>
<li><p>S -&gt; C 确认建立连接 (TCP)</p>
</li>
<li><p>C -&gt; S 请求对象 (HTTP)</p>
</li>
<li><p>S -&gt; C 返回对象 (HTTP)</p>
</li>
<li><p>C -&gt; S  关闭连接 (TCP)</p>
</li>
</ol>
</li>
</ul>
<ol>
<li>响应时间模型<ul>
<li>往返时间RTT (round-trip-time) : 一个小的分组从客户端到服务器, 再从服务器返回客户端的时间, 因为分组很小, 传输时间可以忽略不计, 但需要记录传播时间</li>
<li>故一次HTTP通讯, 需要耗费的时间为2 * RTT + 对象的传输时间</li>
<li>第一个RTT 用来发起TCP连接, 第二个RTT 用来发起HTTP请求, 并等待HTTP响应</li>
</ul>
</li>
</ol>
<h4 id="持久化的HTTP连接"><a href="#持久化的HTTP连接" class="headerlink" title="持久化的HTTP连接"></a>持久化的HTTP连接</h4><ul>
<li><p>通讯过程</p>
<pre><code>1. C -&gt; S 请求连接 (TCP)
</code></pre>
<ol start="2">
<li><p>S -&gt; C 确认连接 (TCP)</p>
</li>
<li><p>C -&gt; S 请求获取对象 (HTTP请求报文)</p>
</li>
<li><p>S -&gt; C 发送对象 (HTTP相应报文)</p>
</li>
<li><p>C -&gt; S 请求获取对象2….</p>
</li>
</ol>
</li>
<li><p>非流水线和流水线方式</p>
<ul>
<li>非流水线方式 -&gt; uqi, 流水线方式 -&gt; qi</li>
<li>uqi方式<ul>
<li>是一个对象一个对象获取的, 其中是有阻塞关系的, 下一对象的获取请求需要等待上一个对象获取完毕以后, 才会发送</li>
<li>举例 :<br>C -&gt; S 请求获取对象A<br>S -&gt; C 返回对象 A<br>C -&gt; S 请求获取对象B</li>
</ul>
</li>
<li>qi方式<ul>
<li>分成两部分处理, 首先统一发送所有请求, 再一次接受所有的返回, 实现了并行的收发</li>
<li>举例 :<br>C -&gt; S 请求获取对象A<br>C -&gt; S 请求获取对象B<br>…<br>S -&gt; C 返回对象A<br>S -&gt; C 返回对象B</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ul>
<li>请求报文示例 :</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET(请求方法) ..URL路径.. HTTP/1.1(协议)</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com	// 请求的服务器域名</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0	// 客户端信息</span><br><span class="line"><span class="attribute">Accpet</span><span class="punctuation">: </span>text/html,application/json // 客户端能接受的内容类型</span><br><span class="line"><span class="attribute">Connetion</span><span class="punctuation">: </span>close		// 连接是否建立一次通讯后就关闭</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN	// 接受的语言偏好</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json // 传输的内容的类型</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>128		// 接下来的信息中属于该次请求的内容的长度</span><br><span class="line">...</span><br><span class="line">&lt;Entity-data&gt; // 请求携带的表单 </span><br></pre></td></tr></table></figure>

<ul>
<li>对于Content-Type的解释 : TCP协议是没有维护着边界数这个数据的, 所以需要更上层的协议或应用规定, 以此来区分在同一次的传输中的庞大内容中属于各自通讯的部分<ul>
<li>举例 : 我发送了两个HTTP请求, 各自的长度是15K, 则在TCP中, 一次性传输了30K的数据, 现在我们就需要这个Length划分边界, 以说明这部分内容是属于哪个请求的</li>
</ul>
</li>
<li>提交请求相关的数据的方式 :<ul>
<li>URL方式 : 在URL中写出 (RESTFUL), 例如 : tb.com?username&#x3D;…&amp;password&#x3D;…</li>
<li>表单方式 : 即提交请求中包含请求体, 常见的有json形式的表单</li>
</ul>
</li>
<li>1.1新增的请求方法 : PUT (用于新增数据), DELETE (用于删除数据)</li>
</ul>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul>
<li>响应报文示例 :<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close	// 控制连接状态, close表示服务器处理完请求后关闭连接, </span><br><span class="line">					// 另一个值是 keep-alive</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span> Wed, 21 Oct 2024 07:28:00 GMT // 服务器发送响应</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>	// 服务端的信息</span><br><span class="line"><span class="attribute">Last-Modified</span>:	Wed, 21 Oct 2024 07:28:00 GMT // 用于更新缓存使用, 在接下来的缓存部分会详细说明, 这里显示的是资源最后修改的时间</span><br><span class="line"><span class="attribute">Contenet-Length</span><span class="punctuation">: </span>	// 作用与请求报文中的一致</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>	// 响应报文的类型</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h4><ol>
<li>有状态和无状态<ul>
<li>HTTP是无状态的协议, 服务器不会维护与客户端的通讯历史, 即每一次的交换报文, 都是一次全新的通讯</li>
<li>带来的问题是, 在像电商平台这种网站上, 我们是有需要维护的状态的, 比如用户信息</li>
</ul>
</li>
</ol>
<ul>
<li><p>Cookie就像网站临时给的身份证, 帮助网站记住你是谁, 记住你的偏好设置, 一般会保存在浏览器的某个文件夹下</p>
</li>
<li><p>执行逻辑</p>
<ol>
<li>第一次访问网站的时候, 请求是不会携带cookie的</li>
<li>服务器响应的返回中会携带Set-Cookie响应头</li>
<li>之后的请求中, 都会携带Cookie请求头 (来源于之前获得到的Cookie)</li>
</ol>
</li>
<li><p>举例说明 : (常用但典型的用户信息就不用说明了, 主要说明购物车场景) </p>
<ol>
<li>用户添加第一个商品到购物车的时候 , 请求 : POST &#x2F; cart&#x2F;add</li>
<li>服务器返回 : Set-Cookie: cart_id&#x3D;123456</li>
<li>后续添加商品, 请求自动带上: Cookie: cart_id&#x3D;123456</li>
</ol>
</li>
<li><p>Cookie与隐私 : </p>
<ul>
<li>并不是所有的Cookie都是和上面介绍的一样, 是为了更便捷和传输更少的数据而服务的, 有相当一部分会采集用户的行为数据, Cookie可以算是存放浏览隐私数据的容器</li>
<li>一般来说, Cookie是不会被跨站使用的</li>
</ul>
</li>
</ul>
<h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><ul>
<li><p>优点 : </p>
<ol>
<li>能降低返回的时间</li>
<li>减小服务器的负载</li>
</ol>
</li>
<li><p>Web缓存的两种方式</p>
<ol>
<li><p>本地缓存 : 这个本质上应该算是加载静态资源, 并且保存在本地, 这样就能将以一些常用的数据, 比如Logo保存在本地, 而不是每次访问网站都需要重新获取</p>
</li>
<li><p>proxy代理服务器方式 : </p>
<ul>
<li><p>这种缓存方式更为复杂, 它的核心理念是 “二八定律” ,即80%的人访问了20%的内容, 所以我们可以设置一个服务器, 专门用于承载那个20%被经常访问的数据, 这样, 就不用所有的数据都需要走源服务器并且, 这样即使我们不用提高服务器的带宽, 同样能大幅提高响应速度</p>
</li>
<li><p>举例说明 : 以搜索引擎为例, 原本我们收到所有的数据, 执行的逻辑都是发往源服务器, 再执行搜索, 但是这样会导致导向源服务器的数据量需要随着访问的增加, 一直线性地增加, 这样对于带宽的需求变得极大. </p>
<p>  解决方案 : 将设置proxy服务器, 用于做中间的代理, 其中直接存储了那20%的数据, 则访问者的数据如果 “hit” 中了这20%, 则会走浏览器 -&gt; 代理服务器, 而不会加重源服务器的负担</p>
</li>
</ul>
</li>
<li><p>缓存与Last-Modified以及If-Modified-since字段之间的关系</p>
<ul>
<li><p>本地缓存 : 更加直接, 如果请求头中的If-Modified-since字段和Last-Modified字段的中的时间戳不同, 则会更新本地的数据, 不同时候, 这个请求会返回200, 而在相同的时候则会返回304 Not Modified</p>
</li>
<li><p>proxy代理缓存 : 会变成如图所示的访问路线</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C  -&gt;  proxy  -&gt;  S</span><br><span class="line"> |       |      |</span><br><span class="line"> |-请求-&gt; |      |</span><br><span class="line"> |       |-验证请求-&gt;|</span><br><span class="line"> |       |&lt;-304响应-|</span><br><span class="line"> |&lt;-304响应-|      |</span><br></pre></td></tr></table></figure>
</li>
<li><p>那两个首部行的内容都是timestamp -&gt; 时间</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="2-3-FTP-port-21-RFC-959"><a href="#2-3-FTP-port-21-RFC-959" class="headerlink" title="2.3 FTP : port 21, RFC 959"></a>2.3 FTP : port 21, RFC 959</h2><ul>
<li><p>用于早期的文件共享, 但因为是明文的传输, 后面应该是被替代了的</p>
</li>
<li><p>以TCP作为传输协议</p>
</li>
</ul>
<h4 id="通讯流程"><a href="#通讯流程" class="headerlink" title="通讯流程"></a>通讯流程</h4><ol>
<li>建立TCP连接 : <strong>21端口 -&gt; 控制连接</strong></li>
<li>身份认证 (用户名, 密码, …)</li>
<li>C端向客户端发送控制指令查看文件list</li>
<li>接收到要下载文件的指令, 服务器打开另一个到客户端的20端口的连接, 用于数据传输</li>
<li>一个文件传输完毕以后, 关闭数据连接</li>
</ol>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>是带外  ( out of band ) 传送</li>
<li>FTP协议是有状态的, FTP服务器需要维护用户的状态信息, 当前路径, 用户账户与控制连接对应</li>
</ul>
<h4 id="命令与响应-响应不赘述-有需要时自行查找"><a href="#命令与响应-响应不赘述-有需要时自行查找" class="headerlink" title="命令与响应 : (响应不赘述, 有需要时自行查找)"></a>命令与响应 : (响应不赘述, 有需要时自行查找)</h4><ul>
<li>USER username</li>
<li>PASS password</li>
<li>LIST 请服务器返回远程主机当前目录的文件列表</li>
<li>RETR filename 从远程主机当前下载文件</li>
<li>STOR filename 向远程主机上传文件</li>
</ul>
<h2 id="2-4-SMTP-port-25"><a href="#2-4-SMTP-port-25" class="headerlink" title="2.4 SMTP : port 25"></a>2.4 SMTP : port 25</h2><h4 id="Email的组成"><a href="#Email的组成" class="headerlink" title="Email的组成"></a>Email的组成</h4><ol>
<li>用户代理 : <ul>
<li>一般是用户的C端, 比如, Gmail就是我和谷歌邮箱服务器之间的用户代理, 使得通讯的过程可以被隐藏而变成面向最终用户的操作端</li>
</ul>
</li>
<li>邮件服务器 : 用于收发邮件</li>
<li>简单的邮件传输协议 : SMTP</li>
<li>邮件访问协议 : POP3, IMAP, HTTP</li>
</ol>
<h4 id="邮件的收发的过程举例说明-A-要向-B发送邮件"><a href="#邮件的收发的过程举例说明-A-要向-B发送邮件" class="headerlink" title="邮件的收发的过程举例说明 (A 要向 B发送邮件)"></a>邮件的收发的过程举例说明 (A 要向 B发送邮件)</h4><ol>
<li><p>发送邮件(SMTP) : A 通过用户代理 -&gt; 邮件服务器a</p>
</li>
<li><p>发送邮件(SMTP) : A发送的邮件被邮件服务器a -&gt; 邮件服务器b</p>
</li>
<li><p>接受邮件(POP3…) : B 通过用户代理从服务器b拉取邮件A</p>
</li>
</ol>
<h4 id="SMTP协议特性"><a href="#SMTP协议特性" class="headerlink" title="SMTP协议特性 :"></a>SMTP协议特性 :</h4><ol>
<li>message全部内容都必须是7位的ASCII码, 不遵从这个规定是无法传输的</li>
<li>是持久连接, 并不是发送了一个邮件就会关闭, 一个TCP连接可以发送多个邮件</li>
<li>报文内容用CRLF做结尾符</li>
<li>一次传输的报文里, 是可以有多个对象的, 比如, 我这封邮件里有正文, 还有我的附件, 都会一同传输</li>
</ol>
<h4 id="文本报文"><a href="#文本报文" class="headerlink" title="文本报文 :"></a>文本报文 :</h4><ul>
<li><p>RFC 822 : 文本报文标准</p>
</li>
<li><p>首部行 : </p>
<ul>
<li>To : 收件人</li>
<li>From : 发件人</li>
<li>Subject :</li>
</ul>
</li>
<li><p>现在就有问题是, 如何只通过ASCII码传输所有内容, 比如有中文, 很容易会出现在ASCII码编码内容之外的内容</p>
<ul>
<li>解决方法 : 做映射编码, 常见的方式有Base64编码模式</li>
</ul>
</li>
</ul>
<h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p>我们发送了邮件以后, 另一个人还需要收到和查看邮件, 这个时候就需要用到邮件访问协议</p>
<ul>
<li><p>常用的协议 : 均为明文协议</p>
<ul>
<li><p>POP3 : 较简陋的协议, 仅支持本地管理文件夹</p>
</li>
<li><p>IMAP : 对比POP3更复杂, 是有状态的协议, 支持远程管理文件夹</p>
</li>
<li><p>HTTP : 易用</p>
</li>
</ul>
</li>
</ul>
<h5 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h5><p><strong>无状态</strong></p>
<p>通讯过程 : </p>
<pre><code>1. 用户确认阶段
- 用户名
- 密码
2. 服务器响应
- +OK
- -ERR
3. 事务处理阶段 (拉取邮件的阶段)
- 客户端 -&gt; 服务器
- list -&gt; 获取报文号列表
- retr 报文号 -&gt; 拉取对应报文号的报文
- dele 报文号 -&gt; 删除对应的报文
- quit -&gt; 关闭连接
</code></pre>
<h5 id="下载并删除与下载并保留"><a href="#下载并删除与下载并保留" class="headerlink" title="下载并删除与下载并保留"></a>下载并删除与下载并保留</h5><ul>
<li>下载并删除 -&gt;  将邮件下载到客户端以后, 会将服务器上的邮件dele<ul>
<li>能减小服务器的负载</li>
<li>如果改变了客户机, 就不能阅读邮件了</li>
</ul>
</li>
<li>下载并保留 -&gt; 留在云端, 即使下载到本地后, 也不会删除</li>
<li>POP3的默认模式是下载并删除, 但是也可以通过设置DELE标志为false, 使得下载并保留</li>
</ul>
<h5 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h5><p><strong>有状态</strong>(会话状态, 邮件的状态和标记, 目录的访问权限)的协议, IMAP服务器会将每个报文和一个文件夹关联起来, 这样就能构建一个远程的文件系统</p>
<p>, 并通过这个远程的文件系统, 远程的管理邮件</p>
<ul>
<li>允许用户通过目录组织访问</li>
<li>允许用户之拉去报文的组件 (只拉取报文的一部分, 比如我只获取这个封邮件中的附件)</li>
<li>在会话过程中始终保持用户状态, 会维护持续的会话状态, 而POP3每一次的连接都是新会话<ul>
<li>用户名, 邮件ID和目录之间映射</li>
</ul>
</li>
</ul>
<h2 id="2-5-DNS"><a href="#2-5-DNS" class="headerlink" title="2.5 DNS"></a>2.5 DNS</h2><p>提供域名, 并做域名到IP地址之间的转换</p>
<ul>
<li><p>如何命名设备</p>
<ul>
<li>平面化会有重名</li>
<li>分层式的命名</li>
</ul>
</li>
<li><p>如何做转换</p>
<ul>
<li>不可能由一台设备集中式解决, 不可行</li>
<li>分布式的解析</li>
</ul>
</li>
<li><p>对域名的管理, 对域名的维护问题</p>
<ul>
<li>对域名的增删</li>
</ul>
</li>
<li><p>DNS</p>
<ul>
<li>除了能提供域名到IP地址的转换, 还有别名到规范名字的转换</li>
<li>能做到负载均衡</li>
</ul>
</li>
<li><p>问题一 : 层次化树状的结构的命名方法</p>
<ul>
<li><p>Internet根被划分为几百个顶级域</p>
<ul>
<li><p>通用的(generic)</p>
<p>.com; .edu; .gov; .int; .mil; .net …. </p>
</li>
<li><p>国家的(countries)</p>
<p>.cn; .us; .nl; .jp</p>
</li>
</ul>
</li>
<li><p>根据这种划分方法, 最末端的树叶就是一台主机, 而每条树枝都是一个子域</p>
</li>
<li><p>有13个根名字服务器</p>
</li>
<li><p>域名是从树叶往上走, 用逗点间隔</p>
</li>
<li><p>域的划分是逻辑的, 不是物理的</p>
</li>
</ul>
</li>
<li><p>分布式解决</p>
<ul>
<li><p>一个名字服务器的问题 </p>
<ul>
<li><p>可靠性 : 单点故障</p>
</li>
<li><p>拓展性 : 通信容量</p>
</li>
<li><p>维护问题 : 远程维护集中的服务区</p>
</li>
</ul>
</li>
<li><p>将命名空间划分为若干区域zone</p>
</li>
<li><p>权威</p>
</li>
<li><p>TLD服务器 : 顶级域服务器 : 负责顶级域名和所有国家级的域名</p>
</li>
<li><p>区域名字服务器维护资源记录</p>
<ul>
<li>Domain_name : 域名</li>
<li>ttl : time to live  生存时间<ul>
<li>可以是长期的 -&gt; 权威记录, 长时间保持不变的记录</li>
<li>也可以短期的 -&gt; 缓存记录, 缓存下来某个域名和ip之间的对应关系, 缓存 -&gt; 性能, 删除 -&gt; 一致性, 这个对应关系是可能会发生变化的</li>
</ul>
</li>
<li>Class : 类别, 互联网中所有都是IN (internet)</li>
<li>Value : ip地址</li>
<li>Type : <ul>
<li>现在还需要关注提供的服务还有, 机器别名到正规名字的转换, 邮件服务器别名到正规名字的准换 , 域名到IP之间的转换, 下面的子域是怎么划分的</li>
<li>DNS的资源记录(RR)</li>
<li>RR的格式 : (name, value, type, ttl)</li>
<li>Type &#x3D; A : Name -&gt; 主机的名字, Value -&gt; IP地址</li>
<li>Type &#x3D; NS  : Name -&gt; 域名, Value -&gt; 域名对应的权威服务器的域名<ul>
<li>用于供上层域找到下层域, 那么就携带两组信息<ul>
<li>子域的命名, 权威服务器的命名</li>
<li>权威服务器的IP</li>
</ul>
</li>
</ul>
</li>
<li>Type &#x3D; CNAME : Name为规范名字的别名, Value为规范名字</li>
<li>Type &#x3D; MX : Value为name对应的邮件服务器的名字</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS (Domain Name System) 工作流程</p>
<ol>
<li><p>应用 -&gt; 解析器 (resolver)</p>
</li>
<li><p>解析器作为客户 -&gt; Name Server发出查询报文(UDP)</p>
</li>
<li><p>Name Server返回响应报文 (name&#x2F;ip)</p>
</li>
</ol>
</li>
<li><p>递归查询, 从叶向根逐步走</p>
</li>
<li><p>迭代查询</p>
</li>
<li><p>DNS 请求和响应</p>
<ul>
<li>其中的id用于统一查询和应答</li>
</ul>
</li>
<li><p>维护 -&gt; 新增一个域</p>
<ul>
<li><p>简单来说, 就是上层服务器维护一个指针(资源记录的一个组合)</p>
</li>
<li><p>举例, 我现在要新增一个uptopic.com的域名</p>
<ol>
<li><p>到注册登记机构注册域名uptopic.com</p>
</li>
<li><p>向该机构提供权威DNS服务器 (基本的, 辅助的) 的名字和IP地址</p>
</li>
<li><p>登记机构在com  TLD服务器插入两条RR记录</p>
<p>(uptopic.com, dns1.uptopic.com, NS)<br>(dns1.uptopic.com, 212.212.212.1, A)</p>
</li>
</ol>
</li>
<li><p>在权威服务器中保有</p>
<ul>
<li>用于web的类型为A的记录</li>
<li>用于邮件服务器的类型为MX的记录</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS泄露</p>
</li>
</ul>
<h2 id="2-6-纯P2P架构"><a href="#2-6-纯P2P架构" class="headerlink" title="2. 6 纯P2P架构"></a>2. 6 纯P2P架构</h2><ul>
<li><p>非结构化P2P</p>
<ul>
<li>将peer视作一个节点, peer和peer之间的会话视作一条边, 那么非结构化的P2P, 则以刚刚的方法构建出来的图是没有任何结构的, 是一个松散的, 随机的图</li>
</ul>
</li>
<li><p>DHT结构化的P2P</p>
<ul>
<li>采用刚刚的构建方式, 最后构建的图, 形成了树, 环等结构</li>
</ul>
</li>
<li><p>P2P: 集中式的目录</p>
<ul>
<li>peer节点上线后, 向目录服务器提供ip和自己拥有的资源的目录</li>
<li>peer可以通过目录服务器检索和找到该去哪下文件</li>
</ul>
</li>
<li><p>完全分布式 :</p>
<ul>
<li>泛洪式查询 (flooding), 不断向邻居发起查询, 邻居也向它的邻居发送查询</li>
<li>overlay覆盖式网络的维护<ul>
<li>上线 : 上线后, 通过客户端提供的在线的ip发出ping, 收到的节点返回response, 从而建立起了邻居关系</li>
<li>下线 : 下线的时候, 向它的邻居发送请求说明自己下线, 邻居再随机获取一个节点作为节点以维持网络强度</li>
</ul>
</li>
</ul>
</li>
<li><p>混合体 : 存在组长和组员</p>
</li>
<li><p>P2P文件分发 : BitTorrent</p>
<ul>
<li>将一个文件和一组描述以及hash值关联<ul>
<li>描述用于索引, hash值用于唯一标识文件以定位文件</li>
</ul>
</li>
<li>和完全分布式类似, 上下线建立洪流的方式相同</li>
<li>采用bit map的方式<ul>
<li>假设现在我有诺干个文件块每个256k, 为其建立散列表, 每个peer维护一个bit map, 具有的文件标识为1, 其余的为0</li>
<li>现在加入了一个新的用户, 这个用户的bit map就全部为0, 这个时候, 开始会随机地向其他节点请求, 在获取四个块之后, 后续就只会请求稀缺的块, 来防止拥有稀缺快的用户下线后, 其他用户难以获取这些稀缺的块</li>
<li>并且对于一个peer, 它的下载的优先级, 会按照它对这个洪流的贡献分配</li>
<li>现在有80个人向A发起下载请求, A不可能全部都满足, 他在前两个周期, 会只去查看在之前为他提供了更大贡献的节点发起的请求, 第三个周期会随机获取队列中的节点, 提供一个振荡的机会</li>
</ul>
</li>
</ul>
</li>
<li><p>结构化的P2P系统</p>
<ul>
<li>为每个内容计算哈希</li>
<li>按照哈希值将文件进行排序, 并维持一定的结构(树, 图), 能够一定程度上提高查询的性能, 可以减少副本的数量的同时保障查询的性能</li>
</ul>
</li>
</ul>
<h2 id="2-7-CDN"><a href="#2-7-CDN" class="headerlink" title="2.7 CDN"></a>2.7 CDN</h2><ul>
<li><p>视频的码率压缩</p>
</li>
<li><p>多媒体流化服务 : DASH</p>
<ul>
<li>将一段视频, 切分为一个一个块, 并将每一块并行处理成高码率, 中码率, 低码率等份</li>
<li>给出告示文件, 用于说明某个块的信息 : 码率, URL..</li>
<li>客户端会根据用户的能力和需求, 动态地变化块的码率</li>
</ul>
</li>
<li><p>CDN -&gt; 加速服务</p>
<ul>
<li><p>数量取胜 enter deep : 将CDN服务器深入到许多的接入网</p>
<ul>
<li>部署非常多的缓存加速节点服务器, 由租用节点的运营商决定将哪些内容缓存在CSN中, 然后用户发起请求的时候, 会做域名的重定向到最近的CDN服务器</li>
<li>离用户近, 但由于数量多 -&gt; 管理困难</li>
<li>Akamai</li>
</ul>
</li>
<li><p>bring home </p>
<ul>
<li>部署在少数关键位置, 如将服务器簇安装于POP附近 (离若干$1^{st}$ISP POP附近)</li>
<li>利用租用线路将服务器簇连接起来</li>
<li>Limelight</li>
</ul>
</li>
</ul>
</li>
<li><p>CDN的流程</p>
<ol>
<li><p>应用提供方提前部署内容到CND节点</p>
</li>
<li><p>用户从源服务器获取manifest文件(告示文件) -&gt; 用于指示播放流</p>
</li>
<li><p>用户根据告示文件向提供的URL请求获取IP</p>
</li>
<li><p>icp的权威服务器再返回CDN的权威服务器的域名到本地的DNS服务器, 供其重新解析</p>
</li>
<li><p>重新解析后, 访问向CDN的权威服务器, 其再返回的根据它判断后, 返回一个离用户较近的IP地址</p>
</li>
<li><p>用户从那个IP地址获取视频流</p>
</li>
</ol>
</li>
</ul>
<h2 id="2-8-TCP套接字编程"><a href="#2-8-TCP套接字编程" class="headerlink" title="2.8 TCP套接字编程"></a>2.8 TCP套接字编程</h2><ul>
<li><p>TCP -&gt; 可靠的, 字节流的服务, 面向连接</p>
<ul>
<li>by the stream, 但是保证报文之间的界限</li>
</ul>
</li>
<li><p>运行流程</p>
<ol>
<li><p>服务器首先运行</p>
<ul>
<li><p><strong>创建</strong>欢迎socket -&gt; 一个值</p>
</li>
<li><p>和本地端口<strong>捆绑</strong></p>
</li>
<li><p>在欢迎socket上阻塞式<strong>等待接收</strong>用户的连接 accept()</p>
</li>
</ul>
</li>
<li><p>客户端主动和服务器建立连接</p>
<ul>
<li><p><strong>创建</strong>本地客户端的套接字, 隐式捆绑到本地的port</p>
</li>
<li><p>指定服务器进程的IP端口, 和服务器<strong>连接</strong></p>
</li>
</ul>
</li>
<li><p>客户端连接到来的时候</p>
<ul>
<li><strong>接受</strong>来自用户端的请求, 解除阻塞式的等待, 等待的一个新的socket (connection socket)</li>
</ul>
</li>
<li><p>连接API调用有效的时候, 连接的就建立起来了</p>
</li>
</ol>
</li>
<li><p>数据结构 sockaddr_in : IP地址和port绑定关系的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockadrr_in</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> sin_family; <span class="comment">// 地址簇</span></span><br><span class="line">    u_short sin_port; <span class="comment">// port</span></span><br><span class="line">    u_long sin_addr; <span class="comment">// IP地址</span></span><br><span class="line">    <span class="type">char</span> si n_zero[<span class="number">8</span>]; <span class="comment">// 别名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据结构 host_ent : 域名和IP地址相对应的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *h_name; <span class="comment">// 主机的域名</span></span><br><span class="line">    <span class="type">char</span> ** h_aliases; <span class="comment">// 主机的别名</span></span><br><span class="line">    <span class="type">int</span> h_length; <span class="comment">// 地址的长度</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list; <span class="comment">// IP的列表</span></span><br><span class="line">    <span class="type">int</span> h_addrtype; <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行流程</p>
<h2 id="2-9-UDP"><a href="#2-9-UDP" class="headerlink" title="2.9 UDP"></a>2.9 UDP</h2><p>通信过程</p>
</li>
</ul>
<p>​	</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io">Func</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/Chapter2-Application-layer/">https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/Chapter2-Application-layer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fang-tech.github.io" target="_blank">走难</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/08/Computer_Science/Computer_network/Chapter4-Network-layer/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">网络层: 数据平面4.1 导论转发从合适的端口从哪个端口出  是个局部的功能 类比于旅行是决定了单个路口我该怎么走  路由由算法决定分组从发送主机到目标接收主机的路径  是个全局的功能 规划了从源地点到目的地的整体的路径  数据平面 本地, 每个路由器的功能 通过路由表得出输入端口到达的分组该如何转发到输出端口 转发功能 传统方法 : 基于目标的地址ip + 转发表实现 SDN方式 : 基于多个字段 + 流表 &#x3D;&gt; 能对分组做出的行为是更多的, 转发, 泛洪, 阻塞, 修改某些字段等动作 流表则由远程服务器实现, 通过SDN方式, 网络变得可编程了      控制平面 网络范围内的逻辑 计算出来的路由表的是控制平面 传统的控制平面, 路由器算法是在路由器内实现 SDN方式(software-defined networking)      传统方式下, 控制平面和数据平面紧耦合在一台设备上, 同时是分布式的, 每个路由器独立完成工作 很难改动   SDN方式 : 逻辑集中的控制平面, 通过远程控制器与本地的控制代理交互 (CAs), 给分组交换器计算出不同的流表,...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Computer_Science/Algorithm/out/production/Algorithm/%E5%91%A8%E8%B5%9B/452/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">Q1等积子集的划分方案给你一个整数数组 nums，其中包含的正整数 互不相同 ，另给你一个整数 target。 请判断是否可以将 nums 分成两个 非空、互不相交 的 子集 ，并且每个元素必须  恰好 属于 一个 子集，使得这两个子集中元素的乘积都等于 target。 如果存在这样的划分，返回 true；否则，返回 false。 子集 是数组中元素的一个选择集合。 示例 1： 输入： nums &#x3D; [3,1,6,8,4], target &#x3D; 24 输出： true **解释：**子集 [3, 8] 和 [1, 6, 4] 的乘积均为 24。因此，输出为 true 。 示例 2： 输入： nums &#x3D; [2,5,3,7], target &#x3D; 15 输出： false 解释 无法将 nums 划分为两个非空的互不相交子集，使得它们的乘积均为 15。因此，输出为 false。 提示：  3 &lt;= nums.length &lt;= 12 1 &lt;= target &lt;= 1015 1 &lt;= nums[i] &lt;= 100...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Func</div><div class="author-info-description">Func的个人博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">271</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fang-tech"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 应用层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Web-and-HTTP-port-80"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 Web and HTTP : port &#x3D; 80</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL"><span class="toc-number">1.2.1.</span> <span class="toc-text">URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84HTTP%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">非持久化的HTTP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84HTTP%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">持久化的HTTP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">响应报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookies"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">cookies</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">Web缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-FTP-port-21-RFC-959"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 FTP : port 21, RFC 959</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">通讯流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%93%8D%E5%BA%94-%E5%93%8D%E5%BA%94%E4%B8%8D%E8%B5%98%E8%BF%B0-%E6%9C%89%E9%9C%80%E8%A6%81%E6%97%B6%E8%87%AA%E8%A1%8C%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">命令与响应 : (响应不赘述, 有需要时自行查找)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-SMTP-port-25"><span class="toc-number">1.4.</span> <span class="toc-text">2.4 SMTP : port 25</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Email%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">Email的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%AE%E4%BB%B6%E7%9A%84%E6%94%B6%E5%8F%91%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-A-%E8%A6%81%E5%90%91-B%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">邮件的收发的过程举例说明 (A 要向 B发送邮件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SMTP%E5%8D%8F%E8%AE%AE%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">SMTP协议特性 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%8A%A5%E6%96%87"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">文本报文 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%AE%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">邮件访问协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#POP3%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.0.5.1.</span> <span class="toc-text">POP3协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%88%A0%E9%99%A4%E4%B8%8E%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BF%9D%E7%95%99"><span class="toc-number">1.4.0.5.2.</span> <span class="toc-text">下载并删除与下载并保留</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IMAP"><span class="toc-number">1.4.0.5.3.</span> <span class="toc-text">IMAP</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-DNS"><span class="toc-number">1.5.</span> <span class="toc-text">2.5 DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%BA%AFP2P%E6%9E%B6%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">2. 6 纯P2P架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-CDN"><span class="toc-number">1.7.</span> <span class="toc-text">2.7 CDN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="toc-number">1.8.</span> <span class="toc-text">2.8 TCP套接字编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-UDP"><span class="toc-number">1.9.</span> <span class="toc-text">2.9 UDP</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/9.%20%E4%BD%BF%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%A4%84%E7%90%86%E6%8A%BD%E5%A5%96%E8%A7%84%E5%88%99/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.855Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/8.%20%E6%8A%BD%E5%A5%96%E4%B8%AD%E7%BD%AE%E8%A7%84%E5%88%99%E8%BF%87%E6%BB%A4/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.854Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/7.%20%E6%8A%BD%E5%A5%96%E5%89%8D%E7%BD%AE%E8%A7%84%E5%88%99%E8%BF%87%E6%BB%A4/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.853Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/6.%20%E6%9D%83%E9%87%8D%E8%A3%85%E9%85%8D%E5%A4%84%E7%90%86/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.852Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/26.%20%E7%A7%AF%E5%88%86%E9%A2%86%E5%9F%9F%E8%B0%83%E9%A2%9D%E6%9C%8D%E5%8A%A1/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.847Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/fang-tech/Pic/main/img/psc.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Func</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23li4bXLe7MUGkzYiL',
      clientSecret: '6e07175d5780251b166904c518448940a5214fb1',
      repo: 'fang-tech.github.io',
      owner: 'fang-tech',
      admin: ['fang-tech'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'cba1cd25c21ebf86eaf4ac68961fa7f4'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>