<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>走难 | 走难</title><meta name="author" content="Func"><meta name="copyright" content="Func"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="如何基于UDP实现可靠传输为什么需要基于UDP实现的可靠传输(在我们使用TCP能保证可靠传输的前提下)TCP有四大缺点  TCP的升级很困难 TCP存在队头堵塞 TCP建立连接的延迟 网络迁移需要重建TCP连接  QUIC协议的实现, 也是主要聚焦于解决这些问题 QUIC是怎么实现可靠传输的拿HTTP3举例说明, 在UDP报文和HTTP消息之间, 有三层协议   Packet Header QUI">
<meta property="og:type" content="article">
<meta property="og:title" content="走难">
<meta property="og:url" content="https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/2_TCP/4_UDP_QUIC/index.html">
<meta property="og:site_name" content="走难">
<meta property="og:description" content="如何基于UDP实现可靠传输为什么需要基于UDP实现的可靠传输(在我们使用TCP能保证可靠传输的前提下)TCP有四大缺点  TCP的升级很困难 TCP存在队头堵塞 TCP建立连接的延迟 网络迁移需要重建TCP连接  QUIC协议的实现, 也是主要聚焦于解决这些问题 QUIC是怎么实现可靠传输的拿HTTP3举例说明, 在UDP报文和HTTP消息之间, 有三层协议   Packet Header QUI">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg">
<meta property="article:published_time" content="2025-07-08T15:02:57.447Z">
<meta property="article:modified_time" content="2025-06-06T15:37:36.970Z">
<meta property="article:author" content="Func">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/2_TCP/4_UDP_QUIC/",
  "image": "https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg",
  "datePublished": "2025-07-08T15:02:57.447Z",
  "dateModified": "2025-06-06T15:37:36.970Z",
  "author": [
    {
      "@type": "Person",
      "name": "Func",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/2_TCP/4_UDP_QUIC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '走难',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">271</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fas fa-music"></i><span> Java</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-video"></i><span> Spring</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/fang-tech/Pic/main/img/psc.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">走难</span></a><a class="nav-page-title" href="/"><span class="site-name">走难</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fas fa-music"></i><span> Java</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-video"></i><span> Spring</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-08T15:02:57.447Z" title="发表于 2025-07-08 23:02:57">2025-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-06T15:37:36.970Z" title="更新于 2025-06-06 23:37:36">2025-06-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="如何基于UDP实现可靠传输"><a href="#如何基于UDP实现可靠传输" class="headerlink" title="如何基于UDP实现可靠传输"></a>如何基于UDP实现可靠传输</h1><h2 id="为什么需要基于UDP实现的可靠传输-在我们使用TCP能保证可靠传输的前提下"><a href="#为什么需要基于UDP实现的可靠传输-在我们使用TCP能保证可靠传输的前提下" class="headerlink" title="为什么需要基于UDP实现的可靠传输(在我们使用TCP能保证可靠传输的前提下)"></a>为什么需要基于UDP实现的可靠传输(在我们使用TCP能保证可靠传输的前提下)</h2><p>TCP有四大缺点</p>
<ul>
<li>TCP的升级很困难</li>
<li>TCP存在队头堵塞</li>
<li>TCP建立连接的延迟</li>
<li>网络迁移需要重建TCP连接</li>
</ul>
<p>QUIC协议的实现, 也是主要聚焦于解决这些问题</p>
<h2 id="QUIC是怎么实现可靠传输的"><a href="#QUIC是怎么实现可靠传输的" class="headerlink" title="QUIC是怎么实现可靠传输的"></a>QUIC是怎么实现可靠传输的</h2><p>拿HTTP3举例说明, 在UDP报文和HTTP消息之间, 有三层协议</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/http3-over-quic-protocol-works.png"></p>
<ul>
<li>Packet Header</li>
<li>QUIC Frame Header</li>
<li>HTTP3 Frame Header</li>
</ul>
<h3 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h3><p>Packet Header细分成两种</p>
<ul>
<li>Long Packet Header 用于首次建立连接<ul>
<li>源连接ID长度, 源连接ID</li>
<li>目标连接ID长度, 目标连接ID</li>
</ul>
</li>
<li>Short Packet Header 用于日常传输数据<ul>
<li>目标连接ID</li>
<li>编号 Packet Number</li>
<li>负载数据</li>
</ul>
</li>
</ul>
<p><code>Packet Number</code>是每个报文独一无二的编号, 是严格递增的, 也就是如果Packet N丢失了, 重传的Packet N的<code>Packet Number</code>也不是N了, 而是一个比N大的值</p>
<p>这样设计的原因, 主要是为了解决TCP协议中, 发生超时重传以后, 客户端无法判断出来是原始报文的响应还是重传报文的响应, 会导致RTT的计算不准(解决方案是忽略被重传过的报文的RTT值)</p>
<p>同时还能使QUIC支持乱序确认</p>
<p>所以Packet Number严格递增的好处有</p>
<ul>
<li>可以更加精确计算出来RTT, 没有TCP重传的歧义性</li>
<li>可以支持乱序确认</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/7e4e778413c1452bb6d58ec3d5452316.png" alt="TCP 重传的歧义问题"></p>
<p><img src="https://img-blog.csdnimg.cn/ca91985c9a94487a8a29db1249109717.png"></p>
<blockquote>
<p> 维护连接状态的意义, 为什么要维护连接, 明明四元组不是已经能唯一确定传输的对象</p>
</blockquote>
<p>面向连接可以理解为, 这个协议是会维护连接双方的一些<strong>状态信息</strong>的, 比如<strong>序列号</strong>, <strong>窗口大小</strong>等, TCP正是通过面向连接, 才实现了可靠的保序的传输, 像HTTP就不是一个面向连接的协议, 因为它一个<strong>无状态的协议</strong></p>
<p>而对于QUIC, 双端通过目标连接的ID来唯一映射到一条连接上</p>
<p>通过这个连接状态, QUIC实现了</p>
<ul>
<li>真正的<strong>连接迁移</strong>, 因为连接的映射不再依赖于四元组, 而是依赖于更加抽象的目标连接ID, 每一个UDP数据段都能通过目标连接ID来找到自己的连接</li>
<li><strong>状态恢复与0-RTT重连</strong>, 会在更快的连接建立说明</li>
</ul>
<blockquote>
<p>使用QUIC协议通信的双方是怎么协商出目标连接ID的</p>
</blockquote>
<p>在初始建立连接的阶段, 发起方会随机生成一个连接ID(源连接ID, Source Connection ID SCID), 并且会在发送初始包的时候携带这个ID</p>
<p>被动方接收到这个初始包以后, 也会生成自己的SCID, 并且在回复客户端的时候附带这个ID, 被动方将发起方的SCID作为自己的目标连接ID(Destination Connection ID DCID)放入到回复包中</p>
<p>最后发起方接收到回复包以后, 就会将被动方的SCID当作自己的DCID</p>
<p>接下来两者之间的通信就只会有DCID, 用于确认这条消息属于哪个连接</p>
<h3 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h3><p>一个Packer 报文里面可以有多个QUIC Frame报文</p>
<p><img src="https://img-blog.csdnimg.cn/6a94d41ef3d14cb6b7846e73da6c3104.png"></p>
<p>Frame有很多种, 这里讨论Stream类型的Frame格式</p>
<ul>
<li>Stream ID : 多个并发传输的HTTP消息, 通过Stream ID加以区别, 和HTTP&#x2F;2的Stream ID类似</li>
<li>Offset : 类似于TCP协议中的Seq序号, 保证数据的顺序性和可靠性</li>
<li>Length : 指明了Frame数据的长度</li>
<li>负载数据</li>
</ul>
<p>如果数据包 Packet N丢失了, 那么我们是怎么确认重传的Packet N+M是同一个数据包呢</p>
<p>通过Stream ID + offset, 如果两个数据包的Stream ID + offset都是一致的, 说明就是同一个数据包</p>
<p><strong>QUIC通过单向递增的Packet Number配合Stream ID 和offset字段信息, 可以支持乱序确认而不影响数据包的正确组装</strong></p>
<h3 id="QUIC的乱序确认"><a href="#QUIC的乱序确认" class="headerlink" title="QUIC的乱序确认"></a>QUIC的乱序确认</h3><p>首先我们得看到TCP的累计确认机制</p>
<ul>
<li>只确认连续序列, 发送方收到ACK 3, 说明接收方收到了1, 2, 3但是不能说明没有收到4,5,…</li>
<li>缓存失序数据</li>
<li>确认号表示期望, 表示的是期望收到的下一个TCP段的序列号</li>
</ul>
<p>QUIC支持乱序确认</p>
<p>发送方按序发送(按offset的顺序发送)发送窗口中的缓冲区中的30~36数据包(这里的数字是Packet Number)</p>
<p>31, 32数据包首先被确认(QUIC支持乱序确认, 不需要等待Packet 30被确认)</p>
<p>在30被接收到以后, 缓冲区收缩为33 ~ 36, 这个时候缓冲区收缩到了阈值, 接收方发送MAX_STREAM_DATA Frame (协商缓存大小的特定帧), 请求增大最大绝对字节偏移量(就是缓冲区最右边的offset, 其实就是在请求发送缓冲区的右边界向右滑动)</p>
<p>发送缓冲区的右边界向右滑动</p>
<p>将超时的Packet 33重新变成Packet 42重新发送</p>
<blockquote>
<p>为什么能通过Packet Number配合Stream ID和offset来支持乱序确认, 但是TCP却不行呢</p>
</blockquote>
<ul>
<li><p>Packet Number是连接级别的序列号空间(位于传输层, 用于标识每个UDP数据包), offset是Stream级别的序列号空间</p>
<ul>
<li><p>QUIC协议通过ACK帧来选择性确认Packet Number, 如果重传了以后出现了重复(通过Stream ID  + offset判断, 会直接丢弃就行)</p>
</li>
<li><p>举例说明一个ACK帧：</p>
<ul>
<li>最大确认号：100 (已经收到的最大包序号)</li>
<li>第一个ACK范围：30（表示包70-100已收到）</li>
<li>间隙1: 10 (与前一个范围间隔10个)</li>
<li>ACK范围1：15（表示包45-59已收到）</li>
<li>间隙2: 5 (与前一个范围间隔5个)</li>
<li>ACK范围2：10（表示包30-39已收到）</li>
</ul>
<p>这表示接收方已收到的包序号为：30-39、45-59和70-100，而40-44、60-69的包尚未收到。</p>
</li>
</ul>
</li>
<li><p>通过选择性确认实现了对于UDP包的乱序确认以及可靠传输</p>
</li>
<li><p>通过StreamID + offset实现了数据包的正确组装</p>
</li>
</ul>
<h2 id="QUIC是如何解决TCP队头堵塞的问题的"><a href="#QUIC是如何解决TCP队头堵塞的问题的" class="headerlink" title="QUIC是如何解决TCP队头堵塞的问题的?"></a>QUIC是如何解决TCP队头堵塞的问题的?</h2><h3 id="什么是TCP的队头堵塞问题"><a href="#什么是TCP的队头堵塞问题" class="headerlink" title="什么是TCP的队头堵塞问题"></a>什么是TCP的队头堵塞问题</h3><p><strong>发送窗口只有窗口中的已发送未收到ACK确认的数据被确认了, 窗口的左边界才会向右滑动, 但是如果其中有一个数据丢失了, 左边界就会阻塞在丢失的数据上, 因为它一直得不到确认</strong></p>
<p><strong>接收窗口中某个低序号的数据丢失了, 即使高序号的数据接收到了, 窗口的左边界也会被这个丢失的数据阻塞住, 同时也不会将数据交付给应用层, 缓冲区就会被一直占用着</strong></p>
<h3 id="HTTP-2的队头阻塞"><a href="#HTTP-2的队头阻塞" class="headerlink" title="HTTP&#x2F;2的队头阻塞"></a>HTTP&#x2F;2的队头阻塞</h3><p>HTTP&#x2F;2抽象出来了Stream概念, 实现了HTTP的并发传输, 一个Stream就代表HTTP&#x2F;1.1中的一个请求和响应(在HTTP&#x2F;1.1中, 如果有一个HTTP请求阻塞了, 因为HTTP的请求-响应模型, 会导致所有的HTTP请求都被阻塞住)</p>
<p>在HTTP&#x2F;2中, 不同Stream的帧是可以乱序发送的, 每个帧的头部都会携带Stream ID信息, 但是一个Stream内部的帧必须是严格有序的</p>
<p>但是HTTP&#x2F;2还是在传输层的TCP协议上实现的应用层协议, 虽然在应用层上解决了不同HTTP请求之间的队头堵塞问题, 但是受限于TCP的队头堵塞问题</p>
<p><strong>如果有一个Stream中的一个数据丢失了, 会阻塞所有的Stream</strong></p>
<h3 id="没有队头堵塞的QUIC"><a href="#没有队头堵塞的QUIC" class="headerlink" title="没有队头堵塞的QUIC"></a>没有队头堵塞的QUIC</h3><p><strong>QUIC为每个Stream都分配了一个独立的滑动窗口</strong>, 完全解决了队头堵塞问题</p>
<p>如果Stream 2丢失了一个数据包, 也只会影响Stream 2</p>
<h2 id="QUIC是怎么做流量控制的"><a href="#QUIC是怎么做流量控制的" class="headerlink" title="QUIC是怎么做流量控制的"></a>QUIC是怎么做流量控制的</h2><p>TCP的流量控制是让接收方告诉发送方, 自己的接收窗口有多大, 从而让发送方根据接收方的实际接收能力控制发送的数量</p>
<p>QUIC实现流量控制的方式</p>
<ul>
<li>通过window_update帧告诉对方自己可以接收的字节数, 这样发送方就不会发送超过这个字节数的数据</li>
<li>通过BlockFrame告诉对端由于流量控制被阻塞了, 无法发送数据</li>
</ul>
<h3 id="Stream级别的流量控制"><a href="#Stream级别的流量控制" class="headerlink" title="Stream级别的流量控制"></a>Stream级别的流量控制</h3><p>QUIC的接收窗口的<strong>左边界滑动条件取决于接收到的最大偏移字节数</strong></p>
<p><code>接收窗口 = 最大窗口数 - 接收到的最大偏移数</code></p>
<p><strong>右边界的滑动条件是接受窗口内的已收到并被上层读取的数据超过接收窗口的一半</strong>(应用层读取的数据一定是保序的,  所以这部分数据一定是连续的都收到了的)</p>
<p><strong>如果中途丢失了数据包, 会导致已收到并被上层读取到的数据没有超过接收窗口的一半, 最终右边界无法滑动, 造成阻塞</strong></p>
<h3 id="Connection级的流量控制"><a href="#Connection级的流量控制" class="headerlink" title="Connection级的流量控制"></a>Connection级的流量控制</h3><p>整个Connection的可用窗口 &#x3D; 所有Stream的可用窗口大小之和</p>
<h2 id="QUIC对拥塞控制的改进"><a href="#QUIC对拥塞控制的改进" class="headerlink" title="QUIC对拥塞控制的改进"></a>QUIC对拥塞控制的改进</h2><p>简单来说就是, QUIC支持很多的拥塞控制算法, 同时因为它更新很方便, 能有比较快的迭代速度迭代拥塞控制算法</p>
<p>甚至可以根据不同应用设置不同的拥塞控制算法</p>
<h2 id="QUIC更快的连接建立"><a href="#QUIC更快的连接建立" class="headerlink" title="QUIC更快的连接建立"></a>QUIC更快的连接建立</h2><p>对于HTTP&#x2F;1.1或者HTTP&#x2F;2, TCP和TLS是分层的, 分别属于内核的传输层和openssl库实现的表示层, 因此很难被合并在一起, 需要分批次来握手, 先TCP握手(1RTT), 再TLS握手(2RTT), 所以需要3RTT的延迟才能传输数据, 就算Session会话复用, 也需要至少2RTT</p>
<p>但是在HTTP&#x2F;3的QUIC协议并不是与TLS分层,而是<strong>在QUIC内部包含了TLS, 在自己的帧中携带TLS里的记录, 再加上QUIC使用的是TLS1.3, 仅需要1个RTT就能同时建立连接和密钥协商, 在第二次连接的时候, 应用数据包可以和QUIC握手信息(连接信息 + TLS信息)一起发送, 达到0-RTT的效果</strong></p>
<p><img src="https://img-blog.csdnimg.cn/4cad213f5125432693e0e2a512c2d1a1.png"></p>
<h2 id="QUIC迁移连接"><a href="#QUIC迁移连接" class="headerlink" title="QUIC迁移连接"></a>QUIC迁移连接</h2><p>QUIC协议中的连接不依赖于四元组来确认, 而是依赖于连接ID这个再度抽象了一层的状态来确认连接, 所以在IP切换了以后, 只要仍然有连接ID, TLS密钥等, 依然可以无缝复用原连接, 连接随便迁移</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io">Func</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/2_TCP/4_UDP_QUIC/">https://fang-tech.github.io/2025/07/08/Computer_Science/Computer_network/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/2_TCP/4_UDP_QUIC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fang-tech.github.io" target="_blank">走难</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/08/Computer_Science/Computer_network/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/2_TCP/5_Socket/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">Socket编程针对TCP如何进行socket编程  服务端和客户端初始化socket, 得到文件描述符 服务端调用bind将socket绑定监听IP和端口, 调用listen监听该端口 服务端调用accept等待客户端连接 客户端调用connect, 向服务端的地址和端口发起连接请求 服务端accept返回用于传输的socket的文件描述符 客户端调用write写入数据, 服务端调用read读取数据 客户端断开连接, 调用close, 服务端read数据的时候, 就会读取到EOF, 处理完数据以后, 服务端就会调用close  服务端调用accept时, 返回的时一个已经完成连接的socket, 后续用来传输数据 所以用于监听端口的socket和真正用来传输数据的socket是两个socket, 一个叫做监听socket, 一个叫做已完成连接socket listen的时候参数backlog参数的意义1int listen(int socketfd, int backlog)  在早期的linux内核中, backlog是SYN队列的大小 在Linux内核2.2以后, back...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Computer_Science/Computer_network/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/2_TCP/3_TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">TCP重传, 滑动窗口, 流量控制, 拥塞控制常见的重传机制TCP会在以下两种情况触发重传机制  数据包丢失, 通过序列号判断出来消息丢失了 确认应答丢失, 通过没有收到ACK来判断消息丢失了  超时重传RTT (Round-Trip Time往返时延)  RTT是数据发送时刻到接受到确认的时刻的差值 超时重传时间用RTO(Retransmission Timeout 超时重传时间) 表示 如果超时时间设置得过大或者过小  RTO过大, 重发就慢, 丢了很久才重发, 没有效率 RTP过小, 会导致可能没有丢失, 只是ACK晚了一点到, 就触发了重发机制, 增加网络拥塞, 导致更多的超时, 导致更多的重发, 最后直接堵死了  在Linux中RTO的计算  需要采样RTT的时间, 然后进行加权平均, 算出来一个平滑RTT值, 而且这个值还是动态变化的, 因为网络状况也是在动态地变化 除了采用RTT, 还需要采样RTT的波动范围, 避免RTT有一个大的波动的话很难被发现的情况   根据这个公式, 越早之前的SRTT, DevRTT, RTT对RTO的影响呈指数级变化(每次变为原来的al...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Func</div><div class="author-info-description">Func的个人博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">271</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fang-tech"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EUDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">1.</span> <span class="toc-text">如何基于UDP实现可靠传输</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9F%BA%E4%BA%8EUDP%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-%E5%9C%A8%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8TCP%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">为什么需要基于UDP实现的可靠传输(在我们使用TCP能保证可靠传输的前提下)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84"><span class="toc-number">1.2.</span> <span class="toc-text">QUIC是怎么实现可靠传输的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Packet-Header"><span class="toc-number">1.2.1.</span> <span class="toc-text">Packet Header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC-Frame-Header"><span class="toc-number">1.2.2.</span> <span class="toc-text">QUIC Frame Header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC%E7%9A%84%E4%B9%B1%E5%BA%8F%E7%A1%AE%E8%AE%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">QUIC的乱序确认</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3TCP%E9%98%9F%E5%A4%B4%E5%A0%B5%E5%A1%9E%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-number">1.3.</span> <span class="toc-text">QUIC是如何解决TCP队头堵塞的问题的?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%9A%84%E9%98%9F%E5%A4%B4%E5%A0%B5%E5%A1%9E%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">什么是TCP的队头堵塞问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">1.3.2.</span> <span class="toc-text">HTTP&#x2F;2的队头阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E9%98%9F%E5%A4%B4%E5%A0%B5%E5%A1%9E%E7%9A%84QUIC"><span class="toc-number">1.3.3.</span> <span class="toc-text">没有队头堵塞的QUIC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84"><span class="toc-number">1.4.</span> <span class="toc-text">QUIC是怎么做流量控制的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E7%BA%A7%E5%88%AB%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">Stream级别的流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Connection%E7%BA%A7%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">Connection级的流量控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC%E5%AF%B9%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">1.5.</span> <span class="toc-text">QUIC对拥塞控制的改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.6.</span> <span class="toc-text">QUIC更快的连接建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC%E8%BF%81%E7%A7%BB%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.7.</span> <span class="toc-text">QUIC迁移连接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/9.%20%E4%BD%BF%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%A4%84%E7%90%86%E6%8A%BD%E5%A5%96%E8%A7%84%E5%88%99/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.855Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/8.%20%E6%8A%BD%E5%A5%96%E4%B8%AD%E7%BD%AE%E8%A7%84%E5%88%99%E8%BF%87%E6%BB%A4/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.854Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/7.%20%E6%8A%BD%E5%A5%96%E5%89%8D%E7%BD%AE%E8%A7%84%E5%88%99%E8%BF%87%E6%BB%A4/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.853Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/6.%20%E6%9D%83%E9%87%8D%E8%A3%85%E9%85%8D%E5%A4%84%E7%90%86/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.852Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/26.%20%E7%A7%AF%E5%88%86%E9%A2%86%E5%9F%9F%E8%B0%83%E9%A2%9D%E6%9C%8D%E5%8A%A1/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.847Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/fang-tech/Pic/main/img/psc.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Func</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>