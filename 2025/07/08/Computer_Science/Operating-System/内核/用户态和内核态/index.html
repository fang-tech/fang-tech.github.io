<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>窄门 | 窄门</title><meta name="author" content="Fun"><meta name="copyright" content="Fun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OS什么是用户态和内核态 这个概念是以进程访问资源的特点为依据进行的划分, 将进程在操作系统上的运行分为两个级别, 是为了安全和管理而设计   用户态(User Mode) : 用户态运行的程序能直接读取用户程序的数据, 拥有较低的权限. 不能直接访问内核数据和程序 操作系统在执行用户程序时, 主要工作在用户态, 只有在执行没有权限完成的任务的时候才会切换到内核态 访客模式   内核态(Kerne">
<meta property="og:type" content="article">
<meta property="og:title" content="窄门">
<meta property="og:url" content="https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E6%A0%B8/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/index.html">
<meta property="og:site_name" content="窄门">
<meta property="og:description" content="OS什么是用户态和内核态 这个概念是以进程访问资源的特点为依据进行的划分, 将进程在操作系统上的运行分为两个级别, 是为了安全和管理而设计   用户态(User Mode) : 用户态运行的程序能直接读取用户程序的数据, 拥有较低的权限. 不能直接访问内核数据和程序 操作系统在执行用户程序时, 主要工作在用户态, 只有在执行没有权限完成的任务的时候才会切换到内核态 访客模式   内核态(Kerne">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fang-tech.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-07-08T15:02:57.496Z">
<meta property="article:modified_time" content="2025-03-17T03:30:25.596Z">
<meta property="article:author" content="Fun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fang-tech.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E6%A0%B8/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/",
  "image": "https://fang-tech.github.io/img/butterfly-icon.png",
  "datePublished": "2025-07-08T15:02:57.496Z",
  "dateModified": "2025-03-17T03:30:25.596Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fun",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E6%A0%B8/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '窄门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">窄门</span></a><a class="nav-page-title" href="/"><span class="site-name">窄门</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-08T15:02:57.496Z" title="发表于 2025-07-08 23:02:57">2025-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-17T03:30:25.596Z" title="更新于 2025-03-17 11:30:25">2025-03-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h2 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h2><blockquote>
<p>这个概念是以进程访问资源的特点为依据进行的划分, 将进程在操作系统上的运行分为两个级别, <strong>是为了安全和管理而设计</strong></p>
</blockquote>
<ul>
<li><strong>用户态(User Mode) :</strong> 用户态运行的程序能直接读取用户程序的数据, 拥有较低的权限.<ul>
<li>不能直接访问内核数据和程序</li>
<li>操作系统在执行用户程序时, <strong>主要</strong>工作在用户态, 只有在执行没有权限完成的任务的时候才会切换到内核态</li>
<li>访客模式</li>
</ul>
</li>
<li><strong>内核态(Kernel Mode) :</strong> 内核态运行的进程几乎可以访问计算机中的任何资源, 不受控制, 拥有非常高的权限<ul>
<li>可以访问任何有效的地址</li>
<li>管理员模式</li>
</ul>
</li>
</ul>
<h2 id="为什么要区分内核态和用户态"><a href="#为什么要区分内核态和用户态" class="headerlink" title="为什么要区分内核态和用户态"></a>为什么要区分内核态和用户态</h2><ol>
<li>安全性 : 内核程序和用户程序的运行环境分隔, 有助于防止用户程序对系统造成不可修复的破坏, 会对系统的正常运行造成灾难性的影响.<ul>
<li>这些危险指令智能在内核态运行, 这些只能由操作系统内核执行的指令也被叫做 <strong>特权指令</strong></li>
</ul>
</li>
<li>稳定性 : 应用程序错误只会影响到该程序本身, 而不会导致整个系统崩坏</li>
</ol>
<h2 id="用户态和内核态是如何切换的"><a href="#用户态和内核态是如何切换的" class="headerlink" title="用户态和内核态是如何切换的"></a>用户态和内核态是如何切换的</h2><ol>
<li><strong>系统调用</strong> : 用户态进程 <strong>主动</strong> 要求切换到内核态的一种方式, 主要是为了使用内核态才能做的事情, 比如读取磁盘资源. <ul>
<li>实现 : 操作系统为用户特别开放了一个中断</li>
<li>比如用户态程序发起 <code>read()</code> 请求读取硬盘数据, 就会从用户态切换到内核态</li>
</ul>
</li>
<li><strong>中断</strong> : 当外围设备完成用户请求的操作后, 会向CPU发出相应的中断信号, 这个时候CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序<ul>
<li>如果之前执行的是用户态, 而中断处理程序执行的内容是内核态的程序, 这个时候, 我们就发生了从用户态到内核态的切换. </li>
<li>我们完成了对磁盘数据的读取的时候, 操作系统就会向cpu发送一个中断, 让cpu能继续运行原先的等待的用户程序</li>
</ul>
</li>
<li><strong>异常</strong> : 当CPU在执行运行在用户态下的程序时, 发生了某些事先不可知的异常, 这时就会触发由当前运行进程切换到处理此异常的内核相关程序中<ul>
<li>比如缺页异常</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io">Fun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E6%A0%B8/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/">https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E6%A0%B8/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fang-tech.github.io" target="_blank">窄门</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E6%A0%B8/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">OS什么是系统调用 ? 操作系统为了用户态的程序能过够调用操作系统提供的内核态级别的子功能而创建的接口   凡是与系统态级别的资源有关的操作, 都必须通过系统调用方式向操作系统提出服务请求 文件管理 进程控制 内存管理    系统调用的分类 ? 设备管理: 完成设备 (输入输出设备和外部存储设备等) 的请求或释放, 以及设备启动等功能 文件管理: 完成对文件的CRUD 进程管理: 进程的创建, 撤销, 阻塞, 唤醒, 进程间的通信等功能 内存管理: 完成内存的分配, 回收以及获取作业占用内存区大小及地址等功能  系统调用的过程了解吗 ? 用户态的程序发起系统调用, 因为系统调用中涉及到一些特权指令 (只能由操作系统内核态才能运行的指令), 用户态程序权限不足, 因此会中断执行, 也就是Trap (Trap是一种中断) 中断发生以后, 当前CPU执行的程序会中断, 跳转到中断处理程序. 内核程序开始执行, 也就是开始处理系统调用 当系统调用处理完毕以后, 操作系统再调用特权指令切换回用户态 (iret, sysret eret), 恢复用户态的上下文, 继续执行用户态程序  </div></div></div></a><a class="pagination-related" href="/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.5%20%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">页面置换算法页面置换 swap在发生缺页中断以后, 如果这个时候物理内存已经申请满了, 我们就会触发页面置换, 我们将不常用的页置换到硬盘中, 从而空出申请需要的内存, 这里有个问题是我们怎么选出来不常用的页面呢? 页面置换算法这就是页面置换算法做得事 最佳页面置换算法我们计算出来现在被使用的物理页中, 需要经过最长时间才会迎来下一次使用的页, 然后将这个页置换出去 这个算法是一个理想的算法, 因为我们是无法得知某个页下一次使用的时间 这个算法也是效率最高的算法, 所以常用来衡量页面置换算法, 页面置换算法离最佳页面置换算法越近, 效率越高 FIFO先进先出页面置换算法, 维护一个全局队列, 最先被被使用的页, 最先被淘汰 LRU最近最久未使用置换算法 使用LRU维护全局链表, 每次淘汰最久不被使用的页 但是这个实现方法存在着每次访问页都需要更新链表, 成本高, 所以同样不常被作为页面置换算法来实现 CLOCK时钟页面置换算法就是用来解决上面LRU的问题的 我们维护一个所有物理页的环形队列, 让一个指针开始的时候指向某个页面, 然后在需要页面置换的时候,  沿环形队列扫描, 如果...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fun</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">239</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OS"><span class="toc-number">1.</span> <span class="toc-text">OS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">什么是用户态和内核态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">为什么要区分内核态和用户态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%9A%84"><span class="toc-number">1.3.</span> <span class="toc-text">用户态和内核态是如何切换的</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/wrench/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/3-%E5%8A%A8%E6%80%81%E9%99%90%E6%B5%81/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.870Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/wrench/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/1-DCC/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.868Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%9C%AA%E7%90%86%E8%A7%A3%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.857Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/deployment/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.856Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/9.%20%E4%BD%BF%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%A4%84%E7%90%86%E6%8A%BD%E5%A5%96%E8%A7%84%E5%88%99/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.855Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Fun</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>