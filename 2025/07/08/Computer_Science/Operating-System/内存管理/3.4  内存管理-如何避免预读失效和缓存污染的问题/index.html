<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>走难 | 走难</title><meta name="author" content="Func"><meta name="copyright" content="Func"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内存管理-如何避免预读失效和缓存污染的问题其实这两个问题都是在问如何改进LRU算法 Redis通过实现LFU算法来避免缓存污染而导致缓存命中率下降的问题 MySQL和Linux操作系统通过改进LRU算法来避免预读失效和缓存污染 Linux和MySQL的缓存机制Linux的page cache和MySQL的Buffer Pool缓存的基本数据单位都是页 Linux的缓存在应用程序读取文件的数据的时候">
<meta property="og:type" content="article">
<meta property="og:title" content="走难">
<meta property="og:url" content="https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.4%20%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="走难">
<meta property="og:description" content="内存管理-如何避免预读失效和缓存污染的问题其实这两个问题都是在问如何改进LRU算法 Redis通过实现LFU算法来避免缓存污染而导致缓存命中率下降的问题 MySQL和Linux操作系统通过改进LRU算法来避免预读失效和缓存污染 Linux和MySQL的缓存机制Linux的page cache和MySQL的Buffer Pool缓存的基本数据单位都是页 Linux的缓存在应用程序读取文件的数据的时候">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg">
<meta property="article:published_time" content="2025-07-08T15:02:57.492Z">
<meta property="article:modified_time" content="2025-07-03T03:22:40.040Z">
<meta property="article:author" content="Func">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.4%20%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/",
  "image": "https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg",
  "datePublished": "2025-07-08T15:02:57.492Z",
  "dateModified": "2025-07-03T03:22:40.040Z",
  "author": [
    {
      "@type": "Person",
      "name": "Func",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.4%20%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '走难',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">271</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fas fa-music"></i><span> Java</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-video"></i><span> Spring</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/fang-tech/Pic/main/img/psc.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">走难</span></a><a class="nav-page-title" href="/"><span class="site-name">走难</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fas fa-music"></i><span> Java</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-video"></i><span> Spring</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-08T15:02:57.492Z" title="发表于 2025-07-08 23:02:57">2025-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-03T03:22:40.040Z" title="更新于 2025-07-03 11:22:40">2025-07-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="内存管理-如何避免预读失效和缓存污染的问题"><a href="#内存管理-如何避免预读失效和缓存污染的问题" class="headerlink" title="内存管理-如何避免预读失效和缓存污染的问题"></a>内存管理-如何避免预读失效和缓存污染的问题</h1><p>其实这两个问题都是在问如何改进LRU算法</p>
<p>Redis通过实现LFU算法来避免缓存污染而导致缓存命中率下降的问题</p>
<p>MySQL和Linux操作系统通过改进LRU算法来避免预读失效和缓存污染</p>
<h2 id="Linux和MySQL的缓存机制"><a href="#Linux和MySQL的缓存机制" class="headerlink" title="Linux和MySQL的缓存机制"></a>Linux和MySQL的缓存机制</h2><p>Linux的page cache和MySQL的Buffer Pool缓存的基本数据单位都是页</p>
<h3 id="Linux的缓存"><a href="#Linux的缓存" class="headerlink" title="Linux的缓存"></a>Linux的缓存</h3><p>在应用程序读取文件的数据的时候, Linux操作系统会对读取的文件数据进行缓存, 缓存在文件系统的Page Cache中</p>
<h3 id="MySQL的缓存"><a href="#MySQL的缓存" class="headerlink" title="MySQL的缓存"></a>MySQL的缓存</h3><p>读取的数据时, 如果数据存在于Buffer Pool 中时, 客户端会直接读取缓存中的数据, 否则从磁盘中读取</p>
<p>修改数据的时候, 首先修改Buffer Pool中的数据, 然后将页设置为脏页, 最后由后台线程将脏页写入到磁盘中</p>
<h2 id="解决预读失效"><a href="#解决预读失效" class="headerlink" title="解决预读失效"></a>解决预读失效</h2><h3 id="什么是预读机制"><a href="#什么是预读机制" class="headerlink" title="什么是预读机制"></a>什么是预读机制</h3><p>Linux操作系统为基于Page Cache的读缓存机制提供预读机制</p>
<ul>
<li>应用程序只想读取磁盘文件A的offset为0 ~ 3KB范围内的数据, 但是磁盘的基本读写单位时block(4KB), 所以操作系统至少会读取0~4KB的内容</li>
<li>同时操作系统出于空间局部性原理, 会将磁盘块 offset [4KB, 8KB), [8KB, 12KB), [12KB, 16KB)都加载到内存中, 额外申请了3个page</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ae8252378169c8c14b8b9907983f7d8b.png"></p>
<p>MySQL Innodb存储引擎的Buffer Pool也有类似的预读机制, MySQL从磁盘中加载页的时候, 会提前将它相邻的一页一并加载进来</p>
<h3 id="预读失效会带来什么问题"><a href="#预读失效会带来什么问题" class="headerlink" title="预读失效会带来什么问题"></a>预读失效会带来什么问题</h3><p>如果预读的时候提前加载进来的页没有被访问, 就是预读失效</p>
<p>如果使用传统的LRU算法, 就会把预读页放到LRU链表头部, 内存空间不够的时候就将末尾淘汰掉</p>
<p>如果这些预读页不会被访问到, 就会出现, 不会被访问的预读页却占据了LRU的前排的位置, 而末尾淘汰的页, 可能是热点数据, 这样就大大降低了缓存命中率 </p>
<h3 id="如何避免预读失效造成的影响"><a href="#如何避免预读失效造成的影响" class="headerlink" title="如何避免预读失效造成的影响"></a>如何避免预读失效造成的影响</h3><p>让预读页停留在内存里的时间要尽可能的短, 让真正被访问的页才移动到LRU链表的头部, 从而保证真正被读取的热点数据停留在内存里的时间尽可能长</p>
<ul>
<li>Linux操作系统实现了两个LRU链表, <strong>活跃LRU (active_list), 非活跃LRU(inactive_list)</strong></li>
<li>MySQL地Innodb存储引擎是在LRU链表上划分来2个区域: <strong>young区域和old区域</strong></li>
</ul>
<p>这两种解决方案都是为了将数据分为冷数据和热数据, 分别LRU</p>
<blockquote>
<p>Linux如何避免预读失效带来的影响</p>
</blockquote>
<ul>
<li>预读页就会被加入到 inactive list区域的头部</li>
<li>访问inactive_list中的数据, inactive_list中的数据会<strong>升级</strong>到active_list的头部, 然后将active_list的末尾数据<strong>降级</strong>到inactive_list的头部</li>
</ul>
<blockquote>
<p>MySQL Innodb如何避免预读失效</p>
</blockquote>
<p>其实是基本类似的设计, 只不过Linux分成了两个链表, 而MySQL一个链表, 但是划分成了两部分</p>
<p><strong>预读的页只加入到old区域的头部, 当页被真正访问的时候, 才会将页插入到young区域的头部, 并将young区域的最后一个元素顺位到old区域的头部</strong></p>
<h2 id="解决缓存污染"><a href="#解决缓存污染" class="headerlink" title="解决缓存污染"></a>解决缓存污染</h2><h3 id="什么是缓存污染"><a href="#什么是缓存污染" class="headerlink" title="什么是缓存污染"></a>什么是缓存污染</h3><p>如果还是使用 [只要数据被访问一次, 就将数据加入到活跃LRU链表头部, 这种方式的话, 就还存在着缓存污染的问题]</p>
<p>在我们批量读取数据的时候, 由于数据被读取了一次, 这些大量数据都会被加入到[活跃LRU链表]里, 然后真正的热点数据就全被淘汰了, 如果这些大量的数据不是热点数据的话, 那么整个活跃LRU链表都被污染了</p>
<h3 id="如何解决缓存污染"><a href="#如何解决缓存污染" class="headerlink" title="如何解决缓存污染"></a>如何解决缓存污染</h3><p>其实我们对于这个问题有个很奇妙的切入点在于, 解决缓存污染的核心在于识别出热点数据, 我们可以通过识别出来这个数据是不是由局部性带来的访问, 而是跨越时间的热点数据</p>
<ul>
<li><strong>Linux操作系统</strong> : 在内存页被<strong>第二次</strong>访问的时候, 才将页<strong>升级</strong></li>
<li>MySQL Innodb : 在内存页被<strong>第二次</strong>访问的时候, 还会进一步判断停留在old区域的时间<ul>
<li>如果第二次<strong>访问时间</strong>与第一次访问的时间在<strong>1s内</strong>, 就<strong>不会</strong>被升级</li>
<li>如果停留时间<strong>超过1s</strong>就会升级</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io">Func</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.4%20%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/">https://fang-tech.github.io/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.4%20%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fang-tech.github.io" target="_blank">走难</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.5%20%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">页面置换算法页面置换 swap在发生缺页中断以后, 如果这个时候物理内存已经申请满了, 我们就会触发页面置换, 我们将不常用的页置换到硬盘中, 从而空出申请需要的内存, 这里有个问题是我们怎么选出来不常用的页面呢? 页面置换算法这就是页面置换算法做得事 最佳页面置换算法我们计算出来现在被使用的物理页中, 需要经过最长时间才会迎来下一次使用的页, 然后将这个页置换出去 这个算法是一个理想的算法, 因为我们是无法得知某个页下一次使用的时间 这个算法也是效率最高的算法, 所以常用来衡量页面置换算法, 页面置换算法离最佳页面置换算法越近, 效率越高 FIFO先进先出页面置换算法, 维护一个全局队列, 最先被被使用的页, 最先被淘汰 LRU最近最久未使用置换算法 使用LRU维护全局链表, 每次淘汰最久不被使用的页 但是这个实现方法存在着每次访问页都需要更新链表, 成本高, 所以同样不常被作为页面置换算法来实现 CLOCK时钟页面置换算法就是用来解决上面LRU的问题的 我们维护一个所有物理页的环形队列, 让一个指针开始的时候指向某个页面, 然后在需要页面置换的时候,  沿环形队列扫描, 如果...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Computer_Science/Operating-System/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86,%20%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">内存管理-内存满了会发生什么内存分配的过程 在CPU第一次访问虚拟地址的时候, 发现这个虚拟内存没有映射到实际的物理内存, 这个时候就会触发缺页中断, 将中断交给缺页中断函数处理 中断函数判断是否有空闲的物理内存 有则直接分配内存, 并建立物理内存和虚拟内存之间的映射关系 没有则会开始回收内存的工作   后台内存回收 : 唤醒kswapd内核线程来回收内存, 这个过程是 异步 的 直接内存回收 : 后台异步回收内存跟不上进程内存申请的速度, 就会直接开始回收, 这个回收的过程是同步的, 也就是会阻塞进程的运行 直接内存回收后, 空闲的物理内存仍然无法满足这次的物理内存的申请, 就会触发 OOM 机制, OOM Killer 机制会根据算法选择一个占用物理内存较高的进程, 并将其杀死, 直到释放足够的内存, 这个时候内存分配函数也会返回失败, 同时在释放的过程中申请内存的进程如果分数过高, 也可能被杀掉   可回收的内存类型主要是两类内存  文件页 : 内核缓存的磁盘数据和内核缓存的文件数据都叫做文件页. 将文件页释放是件安全风险很低的事情, 大不了以后再从磁盘中读取就是了. 回收...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/fang-tech/Pic/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250709003827.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Func</div><div class="author-info-description">Func的个人博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">271</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fang-tech"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">内存管理-如何避免预读失效和缓存污染的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%92%8CMySQL%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">Linux和MySQL的缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">Linux的缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">MySQL的缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88"><span class="toc-number">1.2.</span> <span class="toc-text">解决预读失效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E8%AF%BB%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是预读机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">预读失效会带来什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E9%80%A0%E6%88%90%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">如何避免预读失效造成的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="toc-number">1.3.</span> <span class="toc-text">解决缓存污染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="toc-number">1.3.1.</span> <span class="toc-text">什么是缓存污染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">如何解决缓存污染</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/9.%20%E4%BD%BF%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%A4%84%E7%90%86%E6%8A%BD%E5%A5%96%E8%A7%84%E5%88%99/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.855Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/8.%20%E6%8A%BD%E5%A5%96%E4%B8%AD%E7%BD%AE%E8%A7%84%E5%88%99%E8%BF%87%E6%BB%A4/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.854Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/7.%20%E6%8A%BD%E5%A5%96%E5%89%8D%E7%BD%AE%E8%A7%84%E5%88%99%E8%BF%87%E6%BB%A4/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.853Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/6.%20%E6%9D%83%E9%87%8D%E8%A3%85%E9%85%8D%E5%A4%84%E7%90%86/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.852Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/26.%20%E7%A7%AF%E5%88%86%E9%A2%86%E5%9F%9F%E8%B0%83%E9%A2%9D%E6%9C%8D%E5%8A%A1/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.847Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/fang-tech/Pic/main/img/psc.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Func</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>