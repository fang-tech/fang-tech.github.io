<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>窄门 | 窄门</title><meta name="author" content="Fun"><meta name="copyright" content="Fun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 继承的基础使用1public class Son extends Father&#123;&#125;    成员变量访问特点 : 看等号左边是谁, 先调用谁中的变量 成员方法访问特点: 看new的是谁, 先调用谁的方法 java不支持多继承   2. 方法的重写需要在重写的方法上加上@Override注解   子类重写父类方法之后, 权限必须要保证大于等于父类权限\  public &amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="窄门">
<meta property="og:url" content="https://fang-tech.github.io/2025/07/08/Java/JavaSE/javaAdvance/index.html">
<meta property="og:site_name" content="窄门">
<meta property="og:description" content="1. 继承的基础使用1public class Son extends Father&#123;&#125;    成员变量访问特点 : 看等号左边是谁, 先调用谁中的变量 成员方法访问特点: 看new的是谁, 先调用谁的方法 java不支持多继承   2. 方法的重写需要在重写的方法上加上@Override注解   子类重写父类方法之后, 权限必须要保证大于等于父类权限\  public &amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fang-tech.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-07-08T15:02:58.765Z">
<meta property="article:modified_time" content="2024-12-28T10:05:07.859Z">
<meta property="article:author" content="Fun">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fang-tech.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://fang-tech.github.io/2025/07/08/Java/JavaSE/javaAdvance/",
  "image": "https://fang-tech.github.io/img/butterfly-icon.png",
  "datePublished": "2025-07-08T15:02:58.765Z",
  "dateModified": "2024-12-28T10:05:07.859Z",
  "author": [
    {
      "@type": "Person",
      "name": "Fun",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fang-tech.github.io/2025/07/08/Java/JavaSE/javaAdvance/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '窄门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">窄门</span></a><a class="nav-page-title" href="/"><span class="site-name">窄门</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-08T15:02:58.765Z" title="发表于 2025-07-08 23:02:58">2025-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-28T10:05:07.859Z" title="更新于 2024-12-28 18:05:07">2024-12-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-继承的基础使用"><a href="#1-继承的基础使用" class="headerlink" title="1. 继承的基础使用"></a>1. 继承的基础使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>成员变量访问特点 : 看等号左边是谁, 先调用谁中的变量</li>
<li>成员方法访问特点: 看new的是谁, 先调用谁的方法</li>
<li>java不支持多继承</li>
</ol>
</blockquote>
<h2 id="2-方法的重写"><a href="#2-方法的重写" class="headerlink" title="2. 方法的重写"></a>2. 方法的重写</h2><p>需要在重写的方法上加上@Override注解</p>
<blockquote>
<ol>
<li><p>子类重写父类方法之后, 权限必须要保证大于等于父类权限\</p>
<ul>
<li>public &gt; protected -&gt; 默认 -&gt; private</li>
</ul>
</li>
<li><p>私有方法不能重写, 构造方法不能重写, 静态方法不能重写</p>
</li>
<li><p>子类重写父类方法方法以后, 返回的类型, 必须是父类方法返回类型的子类(原类型)</p>
</li>
</ol>
</blockquote>
<h2 id="3-super和this"><a href="#3-super和this" class="headerlink" title="3. super和this"></a>3. super和this</h2><ol>
<li>new子类对象时, 会先调用父类的构造函数</li>
<li>原因: 每个构造方法的第一行,默认都会有一行super(), 不写jvm会自动提供一个, super()代表的是父类无参构造</li>
</ol>
<h2 id="4-super的具体使用"><a href="#4-super的具体使用" class="headerlink" title="4. super的具体使用"></a>4. super的具体使用</h2><ol>
<li>调用父类的构造方法</li>
</ol>
<ul>
<li><code>super()/super(params)</code></li>
</ul>
<ol start="2">
<li>调用父类成员变量<ul>
<li><code>super.成员变量</code></li>
</ul>
</li>
<li>调用父类成员方法<ul>
<li><code>super.成员方法(params)</code></li>
</ul>
</li>
</ol>
<h2 id="5-this的具体使用"><a href="#5-this的具体使用" class="headerlink" title="5. this的具体使用"></a>5. this的具体使用</h2><ol>
<li>调用子类的构造方法</li>
</ol>
<ul>
<li><code>this()/this(params)</code></li>
</ul>
<ol start="2">
<li>调用子类成员变量<ul>
<li><code>this.成员变量</code></li>
</ul>
</li>
<li>调用子类成员方法<ul>
<li><code>this.成员方法(params)</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>无论是this()还是super()都只能在第一行调用, 所以两个是不能同时使用的</p>
</blockquote>
<h2 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6. 抽象类"></a>6. 抽象类</h2><ol>
<li>关键字 : abstract</li>
<li>定义抽象方法<ul>
<li>修饰符 abstract 返回值类型 方法名(参数);</li>
</ul>
</li>
<li>抽象类:<ul>
<li>public abstract class 类名{}</li>
</ul>
</li>
</ol>
<blockquote>
<ol>
<li>抽象类中不一定有抽象方法</li>
<li>抽象方法所在的类一定是抽象类  </li>
<li>抽象类的子类必须重写抽象类中的所有抽象方法, 除非该子类同样是抽象类</li>
</ol>
</blockquote>
<h2 id="7-接口和抽象类的区别"><a href="#7-接口和抽象类的区别" class="headerlink" title="7. 接口和抽象类的区别"></a>7. 接口和抽象类的区别</h2><ol>
<li><p>接口的特点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 接口可以多继承 -&gt; 一个接口可以继承多个接口</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceA</span> <span class="keyword">extends</span> <span class="title class_">InterfaceB</span>, InterfaceC&#123;&#125;</span><br><span class="line"><span class="number">2.</span> 接口可以多实现 -&gt; 一个类可以同时实现一个或多个接口</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>, InterfaceB&#123;&#125;</span><br><span class="line"><span class="number">3.</span> 一个子类可以继承一个父类的同时实现一个或多个接口 -&gt; 一个类可以同时extends 和<span class="keyword">implements</span></span><br><span class="line">    <span class="title class_">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImpl</span> <span class="keyword">extends</span> <span class="title class_">Father</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>, InterfaceB&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 无论是接口还是抽象类, 父类中的抽象方法, 子类都必须重写</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>当一个接口实现多个接口时, 如果接口中的抽象方法有重命名且参数一样的时候吗, 只需要重写一次, 就会重载所有的父类的方法</p>
</blockquote>
<ol start="2">
<li><p>接口中的成员</p>
<ol>
<li><p>抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Type <span class="title function_">method</span><span class="params">(params)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不写public abstract 默认也有</p>
</blockquote>
</li>
<li><p>默认方法与静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> Type <span class="title function_">method</span><span class="params">(params)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title function_">method</span><span class="params">(params)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">name</span> <span class="operator">=</span> ?;</span><br><span class="line"></span><br><span class="line">不写<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 默认也有</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>接口和抽象类的使用情况对比</p>
<ul>
<li>当只需要定义一组无关实现的行为, 这个时候可以使用接口</li>
<li>有一部分通用的实现已经完成, 还有一部分的行为需要实现的时候</li>
</ul>
</li>
</ol>
<h2 id="8-多态"><a href="#8-多态" class="headerlink" title="8. 多态"></a>8. 多态</h2><ul>
<li><p>能使用多态的前提是有继承和重写</p>
</li>
<li><p>最核心的写法就是用父类的指针new子类, 调用公共方法</p>
<ul>
<li><pre><code class="language-java">Fu fu = new Zi();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &gt; 看new的是谁, 就先调用谁那里的方法, 如果子类没有就去父类寻找</span><br><span class="line"></span><br><span class="line">## 9. 多态的向下转型</span><br><span class="line"></span><br><span class="line">向下转型之前需要先进行类型判断</span><br><span class="line"></span><br><span class="line">`if (animal instanceof Dog)&#123;&#125;`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 10. 权限修饰符</span><br><span class="line"></span><br><span class="line">1. 不同权限的访问能力</span><br><span class="line"></span><br><span class="line">   |                | public | protected | default | private |</span><br><span class="line">   | -------------- | ------ | --------- | ------- | ------- |</span><br><span class="line">   | 同类           | yes    | yes       | yes     | yes     |</span><br><span class="line">   | 同包不同类     | yes    | yes       | yes     | no      |</span><br><span class="line">   | 不同包父子类   | yes    | yes       | no      | no      |</span><br><span class="line">   | 不同包非父子类 | yes    | no        | no      | no      |</span><br><span class="line"></span><br><span class="line">&gt; 编写代码的时候, 如果没有特殊的考虑, 只需要简单遵循下面的三条准则就行</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 属性 : private</span><br><span class="line">&gt; 2. 成员方法 : public</span><br><span class="line">&gt; 3. 构造方法 : public </span><br><span class="line"></span><br><span class="line">## 11. final修饰符</span><br><span class="line"></span><br><span class="line">1. final class -&gt; 不能被继承</span><br><span class="line">2. final 方法 -&gt; 不能被重写</span><br><span class="line">3. final 局部变量 -&gt; 值不能二次赋值</span><br><span class="line">4. final 修饰对象 -&gt; 地址不能改变, 但是对象的属性值可以改变</span><br><span class="line">5.  final 成员变量 -&gt; 需要有初始值, 并且不能二次赋值</span><br><span class="line"></span><br><span class="line">&gt; final和abstract不能同时修饰一个方法</span><br><span class="line"></span><br><span class="line">## 12. 代码块</span><br><span class="line"></span><br><span class="line">- 只需要关注静态代码块</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  static&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>静态代码块中的代码会最先执行, 并且只会执行一次, 可以用于构建链接这类只需要执行一次且需要最先执行的代码</p>
</blockquote>
</li>
</ul>
<h2 id="13-静态成员内部类"><a href="#13-静态成员内部类" class="headerlink" title="13. 静态成员内部类"></a>13. 静态成员内部类</h2><ol>
<li><p>格式 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点 : </p>
<blockquote>
<p>静态内部类不能调用外部的非静态成员</p>
</blockquote>
</li>
</ol>
<h2 id="14-匿名内部类"><a href="#14-匿名内部类" class="headerlink" title="14. 匿名内部类"></a>14. 匿名内部类</h2><blockquote>
<p>没有显式声明出类名的内部类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">interface</span>/abstractClass()&#123;</span><br><span class="line">    重写方法</span><br><span class="line">&#125;.重写的方法(); </span><br></pre></td></tr></table></figure>



<h2 id="15异常处理与finally"><a href="#15异常处理与finally" class="headerlink" title="15异常处理与finally"></a>15异常处理与finally</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>finally里面的代码是一定会执行的代码, 一般用于释放内存(释放GC不会自动回收的内存, 比如Socket, IO流)</li>
<li>执行的顺序 : try{…} -&gt; finally{…} -&gt; catch{…}</li>
<li>如果在finally, 我们的代码直接返回了, 那么代码就会无法执行catch中的内容</li>
</ol>
</blockquote>
<h2 id="16-Object类中的方法"><a href="#16-Object类中的方法" class="headerlink" title="16. Object类中的方法"></a>16. Object类中的方法</h2><p>Object是所有类的根类, 其中有<code>toString()</code>, <code>equeals()</code>, <code>clone()</code>三个方法和<code>compareTo</code>, <code>Comparetor</code>两个接口需要注意</p>
<ol>
<li><p>toString()方法 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法相当于python中的_str_字段</span></span><br><span class="line"><span class="comment">// 直接打印出来一个类, 它的值就是你在toString定义的返回</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这是Object的实现</span></span><br><span class="line">    <span class="comment">// 默认的时候返回的是对象地址</span></span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Interger.toHexString(hasCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>equals()方法 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object中的实现, 比较的是地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">this</span> == o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>clone()方法 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现的步骤 :</span></span><br><span class="line"><span class="comment">1. 需要实现的类, implements Cloneable接口</span></span><br><span class="line"><span class="comment">2. 重写clone()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throw</span> ...&#123;</span><br><span class="line">    <span class="built_in">super</span>.cone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>compareTo接口 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">conpareTo</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ComparaTor接口 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">    <span class="comment">//剩下的和compareTo相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="17-String基础知识"><a href="#17-String基础知识" class="headerlink" title="17. String基础知识"></a>17. String基础知识</h2><ol>
<li><p>String的不可变性 :</p>
<ul>
<li>String类一旦创建就是个不可变的变量, 一旦String类进行了改变就会新建一个String用于承载新的字符串</li>
<li>这种设计的优点<ol>
<li>线程安全性, 因为是不可变的, 所以在共享数据的时候是线程安全的</li>
<li>安全性, 防止了恶意的篡改</li>
<li>字符串常量池, Java使用字符串常量池来管理, 池内相同内容的字符串共享一个对象</li>
</ol>
</li>
</ul>
</li>
<li><p>何时创建了新的对象?</p>
<ol>
<li>直接new了一个对象的时候</li>
<li>&#x3D; 右边的字符串拼接式中有变量存在</li>
<li>&#x3D; 右边的字符串常量没有被创建过</li>
</ol>
</li>
</ol>
<h2 id="18-StringBuilder"><a href="#18-StringBuilder" class="headerlink" title="18. StringBuilder"></a>18. StringBuilder</h2><p>StringBuider就像是CPP中的正常的String一样的使用方法, 底层维护的是一个非final的byte数组, 因为是可变的, 所以在拼接这个操作上的性能高于String, 所以它是高效的, 但也正因为它的可修改性, 它也是线程不安全的, 扩容机制和CPP中的vector类似, 不过每次扩容的规模是*2+2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">sb.append(String...);</span><br></pre></td></tr></table></figure>

<h2 id="19-Math工具类"><a href="#19-Math工具类" class="headerlink" title="19. Math工具类 :"></a>19. Math工具类 :</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span> -&gt; 绝对值</span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> a)</span> -&gt; 向上取整</span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> a)</span> -&gt; 向下取整</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> a)</span> -&gt; 四舍五入</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> max/min(<span class="type">int</span> a, <span class="type">int</span> b) -&gt; 取最大或最小</span><br></pre></td></tr></table></figure>

<h2 id="20-BigInteger-大数"><a href="#20-BigInteger-大数" class="headerlink" title="20. BigInteger : 大数"></a>20. BigInteger : 大数</h2><p>处理long都无法处理的大数, 可以使用整型构造, 也可以选用String构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Biginteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>();</span><br><span class="line"><span class="comment">// 转化相关的函数</span></span><br><span class="line">b.intValue();</span><br><span class="line">b.longValue();</span><br><span class="line">b.floatValue();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="21-BigDecimal-准确的小数"><a href="#21-BigDecimal-准确的小数" class="headerlink" title="21. BigDecimal : 准确的小数"></a>21. BigDecimal : 准确的小数</h2><p>直接使用double或者float计算, 会有精度的损失, 并且无法精确表达像0.2这样的数字, 比如钱等数字, 带有小数位, 同时我们不能让它的计算有精度的损失且显示多个小数位, 所以我们构建了一个这样的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种构建方法</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(String / <span class="type">double</span>)</span><br><span class="line"><span class="comment">// 使用String的构建方式是完全可预期的, 但是使用double的构建方式是无法预期的, 因为传进去的double不一定能准确表达那个数字, 比如0.1, 实际上可能是0.100000123123</span></span><br><span class="line"><span class="comment">//它同样具有转化相关的函数, 这里不赘述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它的除法是特殊的</span></span><br><span class="line">divide(BigDecimal divisor, <span class="type">int</span> scale, RoundingMode roundingMode)</span><br><span class="line">    divisor -&gt; 除号后的数据</span><br><span class="line">    scale   -&gt; 保留的小数位数</span><br><span class="line">    roundingMode -&gt; 取舍的模式 (四舍五入这种), 常用的有</span><br><span class="line">                        UP, -&gt; 直接+!</span><br><span class="line">                        DOWN -&gt; 直接舍去</span><br><span class="line">                        HALF_UP -&gt; 四舍五入</span><br></pre></td></tr></table></figure>

<h2 id="22-Calendar-日历类"><a href="#22-Calendar-日历类" class="headerlink" title="22. Calendar 日历类"></a>22. Calendar 日历类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 声明日历类</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);</span><br><span class="line">System.out.println(calendar.get(Calendar.DATE));</span><br><span class="line"></span><br><span class="line">calendar.add(Calendar.YEAR, <span class="number">1</span>); =&gt; 年份加一</span><br><span class="line">    </span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">calendar.set(year, <span class="number">2</span>, <span class="number">1</span>); -&gt; 设置为三月一号</span><br></pre></td></tr></table></figure>

<h2 id="23-SimpleDateFormat-格式化输入输出日期"><a href="#23-SimpleDateFormat-格式化输入输出日期" class="headerlink" title="23. SimpleDateFormat : 格式化输入输出日期"></a>23. SimpleDateFormat : 格式化输入输出日期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">System.out.println(<span class="string">&quot;date = &quot;</span> + date);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="string">&quot;2000-12-06 12:12:12&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> sdf.parse(date2);</span><br><span class="line">    System.out.println(<span class="string">&quot;date3 = &quot;</span> + date3);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-JDK8新增日期类"><a href="#24-JDK8新增日期类" class="headerlink" title="24. JDK8新增日期类"></a>24. JDK8新增日期类</h2><ol>
<li>LocalDate 和 LocalDateTime</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calendar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(localDate);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">    System.out.println(localDate1);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2021</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">    System.out.println(localDateTime1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>get()方法和with()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">with</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDate.withYear(<span class="number">2021</span>).minusMonths(<span class="number">2</span>).withDayOfYear(<span class="number">1</span>);</span><br><span class="line">    System.out.println(localDate1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> localDateTime.getYear();</span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> localDateTime.getMonthValue();</span><br><span class="line">    <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> localDateTime.getDayOfMonth();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> localDateTime.getHour();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> localDateTime.getMinute();</span><br><span class="line">    <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> localDateTime.getSecond();</span><br><span class="line">    System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span> + hour + <span class="string">&quot;时&quot;</span> + minute + <span class="string">&quot;分&quot;</span> + second + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>plusAndMinus</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">plusAndMinus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDate.plusYears(<span class="number">1</span>).minusMonths(<span class="number">2</span>).plusDays(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDate1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>PeriodAndDuration</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">PeriodAndDuration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2022</span>, <span class="number">11</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate1, localDate);</span><br><span class="line">    System.out.println(period.getYears());</span><br><span class="line">    System.out.println(period.getMonths());</span><br><span class="line">    System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2022</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line"></span><br><span class="line">    System.out.println(duration.toDays());</span><br><span class="line">    System.out.println(duration.toHours());</span><br><span class="line">    System.out.println(duration.toMinutes());</span><br><span class="line">    System.out.println(duration.toMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>DateTimeFormatter</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">DataTimeFormatter</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> dtf.format(localDateTime); <span class="comment">// format是将时间转换为字符串</span></span><br><span class="line">    System.out.println(time);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">time1</span> <span class="operator">=</span> <span class="string">&quot;2021-12-31 23:59:59&quot;</span>;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.parse(time1, dtf); <span class="comment">// parse是将字符串转换为时间</span></span><br><span class="line">    System.out.println(localDateTime1);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;SHABI FANGTIANYU&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-System类"><a href="#25-System类" class="headerlink" title="25. System类"></a>25. System类</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static long currentTimeMillis()</td>
<td align="center">返回以毫秒为单位的当前时间, 可以测效率</td>
</tr>
<tr>
<td align="center">static void exit(int status)</td>
<td align="center">终止当前正在运行的java虚拟机</td>
</tr>
<tr>
<td align="center">static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</td>
<td align="center">数组复制<br />stc:源数组<br />srcPos:从源数组的哪个索引开始复制<br/>dest:目标数组<br>destPos:从目标数组的哪个索引开始粘贴<br />Ilength : 复制多少个元素<br/></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.exit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APIModule</span>.Demo02System &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        system();</span></span><br><span class="line"><span class="comment">//    exit();</span></span><br><span class="line">    arrayCopy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arrayCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dest = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy(src, <span class="number">1</span>, dest, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : dest) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.exit(0);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">system</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前时间的毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;now = &quot;</span> + now);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (end - start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-Arrays数组工具类"><a href="#26-Arrays数组工具类" class="headerlink" title="26. Arrays数组工具类"></a>26. Arrays数组工具类</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static String toString(int[] a)</td>
<td align="center">按照格式打印数组元素</td>
</tr>
<tr>
<td align="center">static void sort(int[] a)</td>
<td align="center">升序排序</td>
</tr>
<tr>
<td align="center">static int binarySearch(int[] a, int key)</td>
<td align="center">二分查找</td>
</tr>
<tr>
<td align="center">static int[] copyOf(int[] original, int newLength)</td>
<td align="center">数组扩容</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arrayDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">numsString</span> <span class="operator">=</span> Arrays.toString(numbers);</span><br><span class="line">    System.out.println(<span class="string">&quot;numsString = &quot;</span> + numsString);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(numbers);</span><br><span class="line">    System.out.println(<span class="string">&quot;Sorted numbers = &quot;</span> + Arrays.toString(numbers));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Index of 3 = &quot;</span> + index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] copy = Arrays.copyOf(numbers, numbers.length + <span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Copy of numbers = &quot;</span> + Arrays.toString(copy));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-包装类"><a href="#27-包装类" class="headerlink" title="27. 包装类"></a>27. 包装类</h2><table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Charactor</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<ol>
<li><p>装箱 : 将基本类型转换为对应的包装类</p>
</li>
<li><p><code>static Integer valueOf(int i)/(String s)</code></p>
</li>
<li><p>拆箱 : 将包装类转成基本类型</p>
</li>
<li><p><code>int intValue();</code></p>
</li>
<li><p>多数情况装箱和拆箱是自动的, 无需在意</p>
</li>
</ol>
<blockquote>
<p>有个机制, 如果给的值是-128 ~ 127之间的数字, 会直接给一个已经创建好的Integer对象, 该类预先存储了这个范围内的Integer类, 超出了这个范围才会创建新的类</p>
</blockquote>
<h2 id="28-String和基本类型之间的转换"><a href="#28-String和基本类型之间的转换" class="headerlink" title="28. String和基本类型之间的转换"></a>28. String和基本类型之间的转换</h2><ol>
<li><p>将基本类型转成String</p>
<ul>
<li>+ 拼接</li>
<li><code>static String valueOf(int i)</code></li>
</ul>
</li>
<li><p>将String转成基本类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;String&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>每个包装类中都有一个类似的方法 : parseXXX</p>
</blockquote>
<h2 id="29-javabean和包装类"><a href="#29-javabean和包装类" class="headerlink" title="29. javabean和包装类"></a>29. javabean和包装类</h2><blockquote>
<p>定义javabean的时候一般会将基本类型的属性定义成包装类型的属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>举例:如果uid为Integer型,默认值是<span class="literal">null</span></span><br><span class="line"><span class="number">2.</span>将来javabean中的数据都是和数据库表联系起来的,我们可以将javabean中的数据添加到表中</span><br><span class="line">如果表中的uid为主键自增的,此时添加语句时uid中的数据不用我们单独维护赋值了,添加语句的sql语句就可以这样写:</span><br><span class="line">insert into <span class="title function_">user</span><span class="params">(uid,username,password)</span> values (NULL,<span class="string">&#x27;金莲&#x27;</span>,<span class="string">&#x27;36666&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>到时候,我们需要将javabean中封装的数据获取出来放到sql语句中,如果uid为主键自增,而且javabean中的uid为包装类型,默认值为NULL,这样就不用单独维护uid的值了,也不用先给javabean中的uid赋值,然后在保存到数据库中了,咱们就可以直接使用uid的默认值,将默认值放到sql语句的uid列中</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>而且将javabean中的属性变成包装类,还可以使用包装类中的方法去操作此属性值    </span><br></pre></td></tr></table></figure>

<h2 id="30-创建线程"><a href="#30-创建线程" class="headerlink" title="30. 创建线程"></a>30. 创建线程</h2><h3 id="第一种方式-extends-Thread"><a href="#第一种方式-extends-Thread" class="headerlink" title="第一种方式 extends Thread"></a>第一种方式 extends Thread</h3><ol>
<li>定义一个类, 继承Thread</li>
<li>重写run方法, 在run方法中设置线程任务</li>
<li>创建自定义线程类的对象</li>
<li>调用Thread中的start方法, jvm自动启动其中的run方法</li>
</ol>
<h4 id="Thread类中的方法"><a href="#Thread类中的方法" class="headerlink" title="Thread类中的方法"></a>Thread类中的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> -&gt; 开启线程,jvm自动调用run方法</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>  -&gt; 设置线程任务,这个run方法是Thread重写的接口Runnable中的run方法</span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>  -&gt; 获取线程名字</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> -&gt; 给线程设置名字</span><br><span class="line"><span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span> -&gt; 获取正在执行的线程对象(此方法在哪个线程中使用,获取的就是哪个线程对象)   </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span>-&gt;线程睡眠,超时后自动醒来继续执行,传递的是毫秒值    </span><br></pre></td></tr></table></figure>

<h4 id="Thread中其他的方法"><a href="#Thread中其他的方法" class="headerlink" title="Thread中其他的方法"></a>Thread中其他的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span>   -&gt; 设置线程优先级,优先级越高的线程,抢到CPU使用权的几率越大,但是不是每次都先抢到</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span>  -&gt; 获取线程优先级</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span>  -&gt; 设置为守护线程,当非守护线程执行完毕,守护线程就要结束,但是守护线程也不是立马结束,当非守护线程结束之后,系统会告诉守护线程人家结束了,你也结束吧,在告知的过程中,守护线程会执行,只不过执行到半路就结束了</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span> -&gt; 礼让线程,让当前线程让出CPU使用权</span><br><span class="line">   </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> -&gt; 插入线程或者叫做插队线程    </span><br></pre></td></tr></table></figure>

<h3 id="第二种方式-实现Runnable接口"><a href="#第二种方式-实现Runnable接口" class="headerlink" title="第二种方式 实现Runnable接口"></a>第二种方式 实现Runnable接口</h3><p>为方法实现Runnable接口, 然后<code>Thread t1 = new Thread(myRunnable)</code>, 接下来就当线程对象正常使用</p>
<h3 id="第三种方式-匿名内部类创建多线程"><a href="#第三种方式-匿名内部类创建多线程" class="headerlink" title="第三种方式  匿名内部类创建多线程"></a>第三种方式  匿名内部类创建多线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;阿庆&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<h2 id="31-解决线程安全问题"><a href="#31-解决线程安全问题" class="headerlink" title="31. 解决线程安全问题"></a>31. 解决线程安全问题</h2><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><blockquote>
<p>相当于有一个大家共享的代码块, 同一时间只有一个线程正在运行这部分的代码, 我们在声明一个同步代码块的时候传进去的对象就是一个锁, 抢到了锁的线程才能进入到同步代码块中执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(100L);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    // 同步代码块</span><br><span class="line">    synchronized (obj) &#123;</span><br><span class="line">        if (ticket &gt; 0) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;正在卖第&quot; + ticket + &quot;张票&quot;);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><h4 id="普通同步方法-非静态"><a href="#普通同步方法-非静态" class="headerlink" title="普通同步方法 : 非静态"></a>普通同步方法 : 非静态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:</span><br><span class="line">  修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数)&#123;</span><br><span class="line">      方法体</span><br><span class="line">      <span class="keyword">return</span> 结果</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2.</span>默认锁:<span class="built_in">this</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>+<span class="string">&quot;..............&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        ticket--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:</span><br><span class="line">  修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(参数)&#123;</span><br><span class="line">      方法体</span><br><span class="line">      <span class="keyword">return</span> 结果</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2.</span>默认锁:class对象</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        ticket--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">method01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (MyTicket04.class) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="32-死锁"><a href="#32-死锁" class="headerlink" title="32. 死锁"></a>32. 死锁</h2><p>在锁存在嵌套的时候会出现, 锁的嵌套 : 获取锁1后再获取锁2, 即一个线程在持有一个锁的前提下等待获取零一个锁, 这个时候就可能出现死锁</p>
<ul>
<li>A持有锁1, 现在想同时获取锁2</li>
<li>而B持有锁2, 现在想同时获取锁1</li>
<li>两个线程, 现在相互等待获取对方持有的锁, 如果没有外力作用, 将永远阻塞</li>
</ul>
<p>死锁的形式化定义 : </p>
<ul>
<li>指的是两个或者两个以上的线程在执行的过程中由于竞争同步锁而产生的一种阻塞现象;如果没有外力的作用,他们将无法继续执行下去,这种情况称之为死锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">LockA</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockA</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">LockB</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockB</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DieLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DieLock</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockA.lockA)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;if...lockA&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (LockB.lockB)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;if...lockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockB.lockB)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;else...lockB&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (LockA.lockA)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;else...lockA&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DieLock</span> <span class="variable">dieLock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DieLock</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">DieLock</span> <span class="variable">dieLock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DieLock</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(dieLock1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(dieLock2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为操作系统或者说java总是倾向于为每个线程分配同等的运行时间, 所以一般不会出现一个线程直接获取到所有的锁的情况, 而是先各自获取到lockA, lockB, 然后出现死锁</p>
</blockquote>
<h2 id="33-线程状态"><a href="#33-线程状态" class="headerlink" title="33. 线程状态"></a>33. 线程状态</h2><table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>NEW(新建)</td>
<td>线程刚被创建，但是并未启动。还没调用start方法。</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td>
</tr>
<tr>
<td>Timed Waiting(计时等待)</td>
<td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td>
</tr>
<tr>
<td>Terminated(被终止)</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。或者调用过时方法stop()</td>
</tr>
</tbody></table>
<img src="E:\Desktop\Github\java\线程状态图.png" alt="线程状态图" style="zoom:60%;" />

<h2 id="34-wait和notify"><a href="#34-wait和notify" class="headerlink" title="34. wait和notify"></a>34. wait和notify</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line"><span class="comment">/// 需要同步的代码</span></span><br><span class="line">lock.unlock(); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>锁是一种更简洁的实现多线程加锁的方式</p>
</blockquote>
<h2 id="35-Callable接口-有返回的值的线程"><a href="#35-Callable接口-有返回的值的线程" class="headerlink" title="35. Callable接口 : 有返回的值的线程"></a>35. Callable接口 : 有返回的值的线程</h2><p>和Runnable接口的区别就是在于实现的run方法上, Callable接口实现的线程call方法是可以有返回值的, 并且可以throws</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用了Callable接口的call()方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"></span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="36-线程池"><a href="#36-线程池" class="headerlink" title="36. 线程池"></a>36. 线程池</h2><p>用来循环利用已经创建好了的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">Future&lt;String&gt; fs = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">System.out.println(fs.get());</span><br></pre></td></tr></table></figure>

<h2 id="37-Timer-定时器"><a href="#37-Timer-定时器" class="headerlink" title="37. Timer - 定时器"></a>37. Timer - 定时器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:定时器</span><br><span class="line"><span class="number">2.</span>构造:</span><br><span class="line">  Timer()</span><br><span class="line"><span class="number">3.</span>方法:</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, Date firstTime, <span class="type">long</span> period)</span>  </span><br><span class="line">                task:抽象类,是Runnable的实现类</span><br><span class="line">                firstTime:从什么时间开始执行</span><br><span class="line">                period: 每隔多长时间执行一次,设置的是毫秒值    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Timer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;金莲对涛哥说:涛哥,快起床了~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">new</span> <span class="title class_">Date</span>(),<span class="number">2000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="38-集合"><a href="#38-集合" class="headerlink" title="38. 集合"></a>38. 集合</h2><h3 id="各个集合的顶级接口-Collection接口"><a href="#各个集合的顶级接口-Collection接口" class="headerlink" title="各个集合的顶级接口 : Collection接口"></a>各个集合的顶级接口 : Collection接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">Collection&lt;E&gt; 对象名 = <span class="keyword">new</span> 实现类对象&lt;E&gt;();</span><br><span class="line">&lt;E&gt;: 泛型, 只能写引用数据类型;</span><br><span class="line"><span class="comment">// 泛型的细节 : 等号前面的泛型必须写, 但是等号后面的泛型可以不写, jvm会自动推导</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>常用方法:</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> : 将给定的元素添加到当前集合中(我们一般调add时,不用<span class="type">boolean</span>接收,因为add一定会成功)</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> :将另一个集合元素添加到当前集合中 (集合合并)</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>:清除集合中所有的元素</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>  :判断当前集合中是否包含指定的元素</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> : 判断当前集合中是否有元素-&gt;判断集合是否为空</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>:将指定的元素从集合中删除</span><br><span class="line">  <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> :返回集合中的元素个数。</span><br><span class="line">  Object[] toArray(): 把集合中的元素,存储到数组中 </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">collection.add(<span class="number">1</span>);</span><br><span class="line">collection.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(collection);<span class="comment">//   [1, 2]</span></span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; collection1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">collection1.add(<span class="number">3</span>);</span><br><span class="line">collection1.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">collection.addAll(collection1);</span><br><span class="line">System.out.println(collection);<span class="comment">//  [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">collection.remove(<span class="number">1</span>);</span><br><span class="line">System.out.println(collection);<span class="comment">//   [2, 3, 4]</span></span><br><span class="line">System.out.println(collection.size());<span class="comment">//    3</span></span><br><span class="line">System.out.println(collection.isEmpty());<span class="comment">//     false</span></span><br><span class="line">System.out.println(collection.contains(<span class="number">123</span>));<span class="comment">//     false</span></span><br><span class="line">System.out.println(collection.contains(<span class="number">2</span>));<span class="comment">//       true</span></span><br><span class="line">collection.clear();</span><br><span class="line">System.out.println(collection);<span class="comment">//  []</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol>
<li>主要作用 : 遍历集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(e);<span class="comment">// 1 2 3 4 5</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽量不要一次性next两次, 会有空指针的问题出现</p>
</blockquote>
<h4 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单来说就是, 在遍历的途中, 为集合多加或删除了元素, </span></span><br><span class="line"><span class="comment">// 这个时候就会报ConcurrentModificationException的并发修改异常错误</span></span><br><span class="line"><span class="comment">// 这个报错源于, 迭代器实际操作次数和预期操作次数不同</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">3</span>) &#123;</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(e);<span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Iterator&lt;Integer&gt; iterator = list.iterator();</span></span><br><span class="line">ListIterator&lt;Integer&gt; iterator = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">3</span>) &#123;</span><br><span class="line">        iterator.add(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(e);<span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>概括的说, 就是直接给迭代器添加元素就不会产生歧义</p>
</blockquote>
<h3 id="ArrayList-底层分析"><a href="#ArrayList-底层分析" class="headerlink" title="ArrayList 底层分析"></a>ArrayList 底层分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:ArrayList是List接口的实现类</span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.元素有序-&gt; 按照什么顺序存的,就按照什么顺序取</span><br><span class="line">  b.元素可重复</span><br><span class="line">  c.有索引-&gt; 可以利用索引去操作元素</span><br><span class="line">  d.线程不安全</span><br><span class="line">      </span><br><span class="line"><span class="number">3.</span>数据结构:数组       </span><br><span class="line"><span class="number">4.</span>常用方法:</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>  -&gt; 将元素添加到集合中-&gt;尾部(add方法一定能添加成功的,所以我们不用<span class="type">boolean</span>接收返回值)</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> -&gt;在指定索引位置上添加元素</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> -&gt;删除指定的元素,删除成功为<span class="literal">true</span>,失败为<span class="literal">false</span></span><br><span class="line">  E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> -&gt; 删除指定索引位置上的元素,返回的是被删除的那个元素</span><br><span class="line">  E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> -&gt; 将指定索引位置上的元素,修改成后面的element元素</span><br><span class="line">  E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> -&gt; 根据索引获取元素</span><br><span class="line">  <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>  -&gt; 获取集合元素个数</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>ArrayList构造方法:</span><br><span class="line">  a.ArrayList() 构造一个初始容量为十的空列表</span><br><span class="line">  b.ArrayList(<span class="type">int</span> initialCapacity) 构造具有指定初始容量的空列表 </span><br><span class="line">      </span><br><span class="line"><span class="number">2.</span>ArrayList源码总结:</span><br><span class="line">  a.不是一<span class="keyword">new</span>底层就会创建初始容量为<span class="number">10</span>的空列表,而是第一次add的时候才会创建初始化容量为<span class="number">10</span>的空列表</span><br><span class="line">  b.ArrayList底层是数组,那么为啥还说集合长度可变呢?</span><br><span class="line">    ArrayList底层会自动扩容-&gt; Arrays.copyOf    </span><br><span class="line">  c.扩容多少倍?</span><br><span class="line">    <span class="number">1.5</span>倍</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ArrayList() 构造一个初始容量为十的空列表</span><br><span class="line">=========================================</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">Object[] elementData; -&gt;ArrayList底层的那个数组</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);<span class="comment">// e-&gt;要存的元素  elementData-&gt;集合数组,长度开始为0,size-&gt;0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e-&gt;元素, Object[] elementData-&gt;集合数组, <span class="type">int</span> s-&gt;<span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity-&gt;<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY-&gt;<span class="number">10</span>, minCapacity-&gt;<span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==========================================</span><br><span class="line">假设ArrayList中存了第<span class="number">11</span>个元素,会自动扩容-&gt; Arrays.copyOf</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;<span class="comment">//11</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//10</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="number">15</span>)</span> = ArraysSupport.newLength(oldCapacity-&gt;<span class="number">10</span>,</span><br><span class="line">                minCapacity - oldCapacity-&gt;<span class="number">1</span>, <span class="comment">/* minimum growth */</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span> -&gt;<span class="number">5</span>          <span class="comment">/* preferred growth */</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength-&gt;<span class="number">10</span>, <span class="type">int</span> minGrowth-&gt;<span class="number">1</span>, <span class="type">int</span> prefGrowth-&gt;<span class="number">5</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">        <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">        <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// 15</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> prefLength;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// put code cold in a separate method</span></span><br><span class="line">            <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ArrayList<String>  list &#x3D; new  ArrayList<String>() -&gt; 现在我们想用都是new</p>
<p>但是将来开发不会想使用就new集合,都是调用一个方法,查询出很多数据来,此方法返回一个集合,自动将查询出来的数据放到集合中,我们想在页面上展示数据,遍历集合</p>
<p>而且将来调用方法,返回的集合类型,一般都是接口类型</p>
<p>List&lt;泛型&gt; list &#x3D; 对象.查询方法()</p>
</blockquote>
<h3 id="linkedList"><a href="#linkedList" class="headerlink" title="linkedList"></a>linkedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:LinkedList是List接口的实现类</span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.元素有序</span><br><span class="line">  b.元素可重复</span><br><span class="line">  c.有索引 -&gt; 这里说的有索引仅仅指的是有操作索引的方法,不代表本质上具有索引</span><br><span class="line">  d.线程不安全</span><br><span class="line">      </span><br><span class="line"><span class="number">3.</span>数据结构:双向链表      </span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>方法:有大量直接操作首尾元素的方法</span><br><span class="line">  - <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span><br><span class="line">  - <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span><br><span class="line">  - <span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span><br><span class="line">  - <span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span><br><span class="line">  - <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span><br><span class="line">  - <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。</span><br><span class="line">  - <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>:从此列表所表示的堆栈处弹出一个元素。</span><br><span class="line">  - <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>:将元素推入此列表所表示的堆栈。</span><br><span class="line">  - <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：如果列表没有元素，则返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure>

<h3 id="Collection集合工具类"><a href="#Collection集合工具类" class="headerlink" title="Collection集合工具类"></a>Collection集合工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:集合工具类</span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.构造私有</span><br><span class="line">  b.方法都是静态的</span><br><span class="line">      </span><br><span class="line"><span class="number">3.</span>使用:类名直接调用</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>方法:</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span>-&gt;批量添加元素 </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span> -&gt;将集合中的元素顺序打乱</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span> -&gt;将集合中的元素按照默认规则排序</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>-&gt;将集合中的元素按照指定规则排序 </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list1);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>方法:<span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>-&gt;将集合中的元素按照指定规则排序</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>Comparator比较器</span><br><span class="line">  a.方法:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1,T o2)</span></span><br><span class="line">                o1-o2 -&gt; 升序</span><br><span class="line">                o2-o1 -&gt; 降序    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getScore()-o.getScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays中的静态方法:</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T...a)</span> -&gt; 直接指定元素,转存到list集合中</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Collections</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">     System.out.println(list);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义:</span><br><span class="line">   <span class="keyword">public</span> class 类名&lt;E&gt;&#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>什么时候确定类型</span><br><span class="line">  <span class="keyword">new</span>对象的时候确定类型  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span> &lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">//定义一个数组,充当ArrayList底层的数组,长度直接规定为10</span></span><br><span class="line">    Object[] obj = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//定义size,代表集合元素个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个add方法,参数类型需要和泛型类型保持一致</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 数据类型为E  变量名随便取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        obj[size] = e;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个get方法,根据索引获取元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) obj[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:</span><br><span class="line">  修饰符 &lt;E&gt; 返回值类型 方法名(E e)</span><br><span class="line">      </span><br><span class="line"><span class="number">2.</span>什么时候确定类型</span><br><span class="line">  调用的时候确定类型</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListUtils</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个静态方法addAll,添加多个集合的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(ArrayList&lt;E&gt; list,E...e)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E element : e) &#123;</span><br><span class="line">            list.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:</span><br><span class="line">  <span class="keyword">public</span> interface 接口名&lt;E&gt;&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2.</span>什么时候确定类型:</span><br><span class="line">  a.在实现类的时候还没有确定类型,只能在<span class="keyword">new</span>实现类的时候确定类型了 -&gt;比如 ArrayList</span><br><span class="line">  b.在实现类的时候直接确定类型了 -&gt; 比如Scanner    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyList</span> &lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>作用:可以规定泛型的范围</span><br><span class="line"><span class="number">2.</span>上限:</span><br><span class="line">  a.格式:&lt;? extends 类型&gt;</span><br><span class="line">  b.含义:?只能接收extends后面的本类类型以及子类类型    </span><br><span class="line"><span class="number">3.</span>下限:</span><br><span class="line">  a.格式:&lt;? <span class="built_in">super</span> 类型&gt;</span><br><span class="line">  b.含义:?只能接收<span class="built_in">super</span>后面的本类类型以及父类类型  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上限  ?只能接收extends后面的本类类型以及子类类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">get1</span><span class="params">(Collection&lt;? extends Number&gt; collection)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下限  ?只能接收super后面的本类类型以及父类类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">get2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; collection)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:HashSet是Set接口的实现类</span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.元素唯一</span><br><span class="line">  b.元素无序</span><br><span class="line">  c.无索引</span><br><span class="line">  d.线程不安全</span><br><span class="line"><span class="number">3.</span>数据结构:哈希表</span><br><span class="line">  a.jdk8之前:哈希表 = 数组+链表</span><br><span class="line">  b.jdk8之后:哈希表 = 数组+链表+红黑树</span><br><span class="line">            加入红黑树目的:查询快</span><br><span class="line"><span class="number">4.</span>方法:和Collection一样</span><br><span class="line"><span class="number">5.</span>遍历:</span><br><span class="line">  a.增强<span class="keyword">for</span></span><br><span class="line">  b.迭代器</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:LinkedHashSet <span class="keyword">extends</span> <span class="title class_">HashSet</span></span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.元素唯一</span><br><span class="line">  b.元素有序</span><br><span class="line">  c.无索引</span><br><span class="line">  d.线程不安全</span><br><span class="line"><span class="number">3.</span>数据结构:</span><br><span class="line">  哈希表+双向链表</span><br><span class="line"><span class="number">4.</span>使用:和HashSet一样</span><br></pre></td></tr></table></figure>

<h3 id="HashSet的去重复过程"><a href="#HashSet的去重复过程" class="headerlink" title="HashSet的去重复过程"></a>HashSet的去重复过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 先比较哈希值, 如果不一样, 存;</span><br><span class="line"><span class="number">2.</span> 如果哈希值一样, 再比较内容, 如果不一样, 存</span><br></pre></td></tr></table></figure>

<h3 id="HashSet存储自定义类型如何去重复"><a href="#HashSet存储自定义类型如何去重复" class="headerlink" title="HashSet存储自定义类型如何去重复"></a>HashSet存储自定义类型如何去重复</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 重写hashCode方法 : 让HashSet比较属性的哈希值;</span><br><span class="line"><span class="number">2.</span> 重写equeals方法 : 让HashSet比较属性的内容</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不重写equals方法, 那么不同的对象, 他们的哈希值肯定是不一样的, 但是比较内容的时候, equals调用的是Object的默认实现, 在比较的是两个对象的地址值, 所以即时对象的属性值一样, 也不能去重复</p>
</blockquote>
<h2 id="39-Map集合"><a href="#39-Map集合" class="headerlink" title="39. Map集合"></a>39. Map集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:HashMap是Map的实现类</span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.key唯一,value可重复 -&gt; 如果key重复了,会发生value覆盖</span><br><span class="line">  b.无序</span><br><span class="line">  c.无索引</span><br><span class="line">  d.线程不安全</span><br><span class="line">  e.可以存<span class="literal">null</span>键<span class="literal">null</span>值</span><br><span class="line"><span class="number">3.</span>数据结构:</span><br><span class="line">  哈希表</span><br><span class="line"><span class="number">4.</span>方法:</span><br><span class="line">  V <span class="title function_">put</span><span class="params">(K key, V value)</span>  -&gt; 添加元素,返回的是</span><br><span class="line">  V <span class="title function_">remove</span><span class="params">(Object key)</span>  -&gt;根据key删除键值对,返回的是被删除的value</span><br><span class="line">  V <span class="title function_">get</span><span class="params">(Object key)</span> -&gt; 根据key获取value</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>  -&gt; 判断集合中是否包含指定的key</span><br><span class="line">  Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> -&gt; 获取集合中所有的value,转存到Collection集合中</span><br><span class="line">      </span><br><span class="line">  Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>-&gt;将Map中的key获取出来,转存到Set集合中  </span><br><span class="line">  Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()-&gt;获取Map集合中的键值对,转存到Set集合中</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">Ret</span> <span class="operator">=</span> map.put(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Ret: &quot;</span> + Ret);<span class="comment">// Ret: null</span></span><br><span class="line">Ret = map.put(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Ret: &quot;</span> + Ret);<span class="comment">// Ret: Tom</span></span><br><span class="line"><span class="comment">// key 重复，返回被覆盖的值</span></span><br><span class="line"></span><br><span class="line">map.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line">Ret = map.put(<span class="literal">null</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Ret: &quot;</span> + Ret);<span class="comment">// Ret: null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">//        Ret = map.remove(&quot;001&quot;);</span></span><br><span class="line">System.out.println(<span class="string">&quot;Ret: &quot;</span> + Ret);<span class="comment">// Ret: Jerry</span></span><br><span class="line"><span class="comment">// key 存在，返回被删除的值</span></span><br><span class="line"></span><br><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">System.out.println(values);<span class="comment">// [null, Jerry] </span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:LinkedHashMap <span class="keyword">extends</span> <span class="title class_">HashMap</span></span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.key唯一,value可重复 -&gt; 如果key重复了,会发生value覆盖</span><br><span class="line">  b.有序</span><br><span class="line">  c.无索引</span><br><span class="line">  d.线程不安全</span><br><span class="line">  e.可以存<span class="literal">null</span>键<span class="literal">null</span>值</span><br><span class="line"><span class="number">3.</span>数据结构:</span><br><span class="line">  哈希表+双向链表</span><br><span class="line"><span class="number">4.</span>使用:和HashMap一样      </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02LinkedHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;八戒&quot;</span>,<span class="string">&quot;嫦娥&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;涛哥&quot;</span>,<span class="string">&quot;金莲&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;涛哥&quot;</span>,<span class="string">&quot;三上&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;唐僧&quot;</span>,<span class="string">&quot;女儿国国王&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map遍历的方式"><a href="#Map遍历的方式" class="headerlink" title="Map遍历的方式"></a>Map遍历的方式</h3><h4 id="获取key-再根据key获取value"><a href="#获取key-再根据key获取value" class="headerlink" title="获取key, 再根据key获取value"></a>获取key, 再根据key获取value</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 遍历</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String Key : set) &#123;</span><br><span class="line">    System.out.println(Key + <span class="string">&quot; : &quot;</span> + map.get(Key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接获取键值对"><a href="#直接获取键值对" class="headerlink" title="直接获取键值对"></a>直接获取键值对</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 Entry 遍历</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map存储自定义对象时如何去重复"><a href="#Map存储自定义对象时如何去重复" class="headerlink" title="Map存储自定义对象时如何去重复"></a>Map存储自定义对象时如何去重复</h3><blockquote>
<p>和Set一样, 重新实现equals和hashCode方法</p>
</blockquote>
<h3 id="HashSet需要注意的点"><a href="#HashSet需要注意的点" class="headerlink" title="HashSet需要注意的点"></a>HashSet需要注意的点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.在不指定长度时,哈希表中的数组默认长度为<span class="number">16</span>,HashMap创建出来,一开始没有创建长度为<span class="number">16</span>的数组;</span><br><span class="line">b.什么时候创建的长度为<span class="number">16</span>的数组呢?在第一次put的时候,底层会创建长度为<span class="number">16</span>的数组</span><br><span class="line">c.哈希表中有一个数据加[加载因子]-&gt;默认为<span class="number">0.75</span>(加载因子)-&gt;代表当元素存储到百分之<span class="number">75</span>的时候要扩容了-&gt;<span class="number">2</span>倍</span><br><span class="line">d.如果对个元素出现了哈希值一样,内容不一样时,就会在同一个索引上以链表的形式存储,当链表长度达到<span class="number">8</span>并且当前数组长度&gt;=<span class="number">64</span>时,链表就会改成使用红黑树存储</span><br><span class="line">如果后续删除元素,那么在同一个索引位置上的元素个数小于<span class="number">6</span>,红黑树会变回链表</span><br><span class="line">e.加入红黑树目的:查询快</span><br></pre></td></tr></table></figure>

<h3 id="外面笔试时可能会问到的变量"><a href="#外面笔试时可能会问到的变量" class="headerlink" title="外面笔试时可能会问到的变量"></a>外面笔试时可能会问到的变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default_initial_capacity:HashMap默认容量  <span class="number">16</span></span><br><span class="line">default_load_factor:HashMap默认加载因子   <span class="number">0.75f</span></span><br><span class="line">threshold:扩容的临界值   等于   容量*<span class="number">0.75</span> = <span class="number">12</span>  第一次扩容</span><br><span class="line">treeify_threshold:链表长度默认值,转为红黑树:<span class="number">8</span></span><br><span class="line">min_treeify_capacity:链表被树化时最小的数组容量:<span class="number">64</span></span><br></pre></td></tr></table></figure>

<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:TreeSet是Set的实现类</span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.对元素进行排序</span><br><span class="line">  b.无索引</span><br><span class="line">  c.不能存<span class="literal">null</span></span><br><span class="line">  d.线程不安全</span><br><span class="line">  e.元素唯一</span><br><span class="line"><span class="number">3.</span>数据结构:红黑树      </span><br></pre></td></tr></table></figure>

<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:TreeMap是Map的实现类</span><br><span class="line"><span class="number">2.</span>特点:</span><br><span class="line">  a.对key进行排序</span><br><span class="line">  b.无索引</span><br><span class="line">  c.key唯一</span><br><span class="line">  d.线程不安全</span><br><span class="line">  e.不能存<span class="literal">null</span></span><br><span class="line"><span class="number">3.</span>数据结构:红黑树      </span><br></pre></td></tr></table></figure>

<h2 id="40-File类"><a href="#40-File类" class="headerlink" title="40. File类"></a>40. File类</h2><h4 id="File静态成员"><a href="#File静态成员" class="headerlink" title="File静态成员"></a>File静态成员</h4><p>这两个静态成员是为了解决Window系统和Linux系统中, 路径的分隔符不同的问题 ( 分别为’\‘ 和 ‘&#x2F;‘), 在两个系统中路径分隔符都是 ‘ ; ‘ 但是我们同样给了一个静态变量用于表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String pathSeparator:与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</span><br><span class="line"><span class="keyword">static</span> String separator:与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">file02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path1</span> <span class="operator">=</span> <span class="string">&quot;E:\\Idea\\io&quot;</span>;</span><br><span class="line">        System.out.println(path1);</span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要求代码写完,一次编写,到处运行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path2</span> <span class="operator">=</span> <span class="string">&quot;E:&quot;</span>+File.separator+<span class="string">&quot;Idea&quot;</span>+File.separator+<span class="string">&quot;io&quot;</span>;</span><br><span class="line">        System.out.println(path2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">file01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//static String pathSeparator:与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pathSeparator</span> <span class="operator">=</span> File.pathSeparator;</span><br><span class="line">        System.out.println(<span class="string">&quot;pathSeparator = &quot;</span> + pathSeparator); <span class="comment">//  ;</span></span><br><span class="line">        <span class="comment">//static String separator:与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">separator</span> <span class="operator">=</span> File.separator;</span><br><span class="line">        System.out.println(<span class="string">&quot;separator = &quot;</span> + separator); <span class="comment">//  \</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="File的构造方法"><a href="#File的构造方法" class="headerlink" title="File的构造方法"></a>File的构造方法</h4><blockquote>
<p>简单来说, 三种构造方法就是</p>
<ol>
<li>(文件夹路径, 文件名)</li>
<li>(写入了文件夹路径的File对象, 文件名)</li>
<li>(文件路径)</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File(String parent, String child) 根据所填写的路径创建File对象</span><br><span class="line">     parent:父路径</span><br><span class="line">     child:子路径</span><br><span class="line">File(File parent, String child)  根据所填写的路径创建File对象</span><br><span class="line">     parent:父路径,是一个File对象</span><br><span class="line">     child:子路径</span><br><span class="line">File(String pathname)  根据所填写的路径创建File对象</span><br><span class="line">     pathname:直接指定路径   </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//File(String parent, String child) 根据所填写的路径创建File对象</span></span><br><span class="line">        <span class="comment">//parent:父路径</span></span><br><span class="line">        <span class="comment">//child:子路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Idea\\io&quot;</span>, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;file1 = &quot;</span> + file1);</span><br><span class="line">        <span class="comment">//File(File parent, String child)  根据所填写的路径创建File对象</span></span><br><span class="line">        <span class="comment">//parent:父路径,是一个File对象</span></span><br><span class="line">        <span class="comment">//child:子路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Idea\\io&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;file2 = &quot;</span> + file2);</span><br><span class="line">        <span class="comment">//File(String pathname)  根据所填写的路径创建File对象</span></span><br><span class="line">        <span class="comment">//pathname:直接指定路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Idea\\io\\1.jpg&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;file3 = &quot;</span> + file3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节:</p>
<p>我们创建File对象的时候,传递的路径可以是不存在的,但是传递不存在的路径后, 在执行操作的(比如写入)时候会报错</p>
</blockquote>
<h4 id="File的获取方法"><a href="#File的获取方法" class="headerlink" title="File的获取方法"></a>File的获取方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getAbsolutePath</span><span class="params">()</span> -&gt; 获取File的绝对路径-&gt;带盘符的路径</span><br><span class="line">String <span class="title function_">getPath</span><span class="params">()</span> -&gt;获取的是封装路径-&gt;<span class="keyword">new</span> <span class="title class_">File</span>对象的时候写的啥路径,获取的就是啥路径</span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>  -&gt; 获取的是文件或者文件夹名称</span><br><span class="line"><span class="type">long</span> <span class="title function_">length</span><span class="params">()</span> -&gt; 获取的是文件的长度 -&gt; 文件的字节数   </span><br></pre></td></tr></table></figure>

<h4 id="File的创建方法"><a href="#File的创建方法" class="headerlink" title="File的创建方法"></a>File的创建方法</h4><blockquote>
<p>讲的是使用File类创建文件夹或者文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span>  -&gt; 创建文件</span><br><span class="line">        如果要创建的文件之前有,创建失败,返回<span class="literal">false</span></span><br><span class="line">        如果要创建的文件之前没有,创建成功,返回<span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span> -&gt; 创建文件夹(目录)既可以创建多级文件夹,还可以创建单级文件夹</span><br><span class="line">        如果要创建的文件夹之前有,创建失败,返回<span class="literal">false</span></span><br><span class="line">        如果要创建的文件夹之前没有,创建成功,返回<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*boolean createNewFile()  -&gt; 创建文件</span></span><br><span class="line"><span class="comment">        如果要创建的文件之前有,创建失败,返回false</span></span><br><span class="line"><span class="comment">        如果要创建的文件之前没有,创建成功,返回true*/</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Idea\\io\\1.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;file1.createNewFile() = &quot;</span> + file1.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*boolean mkdirs() -&gt; 创建文件夹(目录)既可以创建多级文件夹,还可以创建单级文件夹</span></span><br><span class="line"><span class="comment">        如果要创建的文件夹之前有,创建失败,返回false</span></span><br><span class="line"><span class="comment">        如果要创建的文件夹之前没有,创建成功,返回true*/</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Idea\\io\\haha\\heihei\\hehe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;file2.mkdirs() = &quot;</span> + file2.mkdirs());</span><br></pre></td></tr></table></figure>

<h4 id="File类的删除方法"><a href="#File类的删除方法" class="headerlink" title="File类的删除方法"></a>File类的删除方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>-&gt;删除文件或者文件夹</span><br><span class="line">    -&gt; 返回的是否删除成功</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">  <span class="number">1.</span>如果删除文件,不走回收站</span><br><span class="line">  <span class="number">2.</span>如果删除文件夹,必须是空文件夹,而且也不走回收站    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">file03</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//boolean delete()-&gt;删除文件或者文件夹</span></span><br><span class="line">    <span class="comment">//File file1 = new File(&quot;E:\\Idea\\io\\1.txt&quot;);</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Idea\\io\\haha&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;file1.delete() = &quot;</span> + file1.delete());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File类的判断方法"><a href="#File类的判断方法" class="headerlink" title="File类的判断方法"></a>File类的判断方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span> -&gt; 判断是否为文件夹 </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>  -&gt; 判断是否为文件</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>  -&gt; 判断文件或者文件夹是否存在    </span><br></pre></td></tr></table></figure>

<h4 id="File的遍历方法"><a href="#File的遍历方法" class="headerlink" title="File的遍历方法"></a>File的遍历方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] list() -&gt; 遍历指定的文件夹,返回的是String数组 </span><br><span class="line">File[] listFiles()-&gt; 遍历指定的文件夹,返回的是File数组 -&gt;这个推荐使用</span><br><span class="line">    </span><br><span class="line">细节:listFiles方法底层还是list方法</span><br><span class="line">     调用list方法,遍历文件夹,返回一个Stirng数组,遍历数组,将数组中的内容一个一个封装到File对象中,然后再将File对象放到File数组中</span><br></pre></td></tr></table></figure>

<h4 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h4><ul>
<li>在idea中写的相对路径,其实就是从模块名开始写</li>
</ul>
<h2 id="41-IO流"><a href="#41-IO流" class="headerlink" title="41. IO流"></a>41. IO流</h2><h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字节流:万能流,一切皆字节    </span><br><span class="line">	字节输出流:  OutputStream 抽象类</span><br><span class="line">    字节输入流:  InputStream 抽象类</span><br><span class="line"></span><br><span class="line">字符流:专门操作文本文档</span><br><span class="line">    字符输出流:Writer 抽象类</span><br><span class="line">    字符输入流:Reader 抽象类</span><br></pre></td></tr></table></figure>

<h3 id="OutputStream中的子类-FileOutputStream"><a href="#OutputStream中的子类-FileOutputStream" class="headerlink" title="OutputStream中的子类[FileOutputStream]"></a>OutputStream中的子类[FileOutputStream]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:字节输出流,OutputStream 是一个抽象类</span><br><span class="line">       子类: FileOutputStream</span><br><span class="line"><span class="number">2.</span>作用:往硬盘上写数据</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>构造:</span><br><span class="line">  FileOutputStream(File file) </span><br><span class="line">  FileOutputStream(String name)</span><br><span class="line">      </span><br><span class="line"><span class="number">4.</span>特点:</span><br><span class="line">  a.指定的文件如果没有,输出流会自动创建</span><br><span class="line">  b.每执行一次,默认都会创建一个新的文件,覆盖老文件 </span><br><span class="line">      </span><br><span class="line"><span class="number">5.</span>方法:</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>  一次写一个字节</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span>  一次写一个字节数组</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>  一次写一个字节数组一部分 </span><br><span class="line">            b:写的数组</span><br><span class="line">            off:从数组的哪个索引开始写</span><br><span class="line">            len:写多少个</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  -&gt; 关闭资源              </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>字节流的续写追加:</span><br><span class="line">  FileOutputStream(String name, <span class="type">boolean</span> append) </span><br><span class="line">                   append:<span class="literal">true</span> -&gt; 会实现续写追加,文件不覆盖了</span><br><span class="line">                       </span><br><span class="line"><span class="number">2.</span>换行:</span><br><span class="line">  a.windows: \r\n -&gt; 占<span class="number">2</span>个字节   \n</span><br><span class="line">  b.linux: \n</span><br><span class="line">  c.mac os : \r</span><br></pre></td></tr></table></figure>

<h3 id="InputStream子类-FileInputStream-的介绍以及方法的使用"><a href="#InputStream子类-FileInputStream-的介绍以及方法的使用" class="headerlink" title="InputStream子类[FileInputStream]的介绍以及方法的使用"></a>InputStream子类[FileInputStream]的介绍以及方法的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:字节输入流 InputStream ,是一个抽象类</span><br><span class="line">      子类:FileInputStream</span><br><span class="line">          </span><br><span class="line"><span class="number">2.</span>作用:读数据,将数据从硬盘上读到内存中来</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>构造:</span><br><span class="line">  FileInputStream(File file)</span><br><span class="line">  FileInputStream(String path)  </span><br><span class="line">      </span><br><span class="line"><span class="number">4.</span>方法:</span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>   一次读一个字节,返回的是读取的字节</span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span>  一次读取一个字节数组,返回的是读取的字节个数</span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>  一次读取一个字节数组一部分,返回的是读取的字节个数</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  关闭资源        </span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题1:一个流对象,读完之后,就不要再读了;除非重新new一个新的对象</p>
<p>问题2:流关闭之后,流对象不能继续使用了</p>
</blockquote>
<h3 id="读取-1的问题"><a href="#读取-1的问题" class="headerlink" title="读取-1的问题"></a>读取-1的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个文件末尾都有一个 <span class="string">&quot;结束标志&quot;</span></span><br><span class="line">    </span><br><span class="line">read()方法读到了文件的结束标志, 会返回-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="字节流实现图片复制代码实现"><a href="#字节流实现图片复制代码实现" class="headerlink" title="字节流实现图片复制代码实现"></a>字节流实现图片复制代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单来说就是边read, 边write</span><br></pre></td></tr></table></figure>

<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="字节流的问题"><a href="#字节流的问题" class="headerlink" title="字节流的问题"></a>字节流的问题</h4><p>不适用边读边看的情景,  实时显示中文字符流, 因为一个中文有多个字节, 会出现错误显示的情况</p>
<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><blockquote>
<p> 字符流主要是用来操作的文本文档, 但是复制操作不要用字符流, 使用字节流</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:字符输入流 -&gt; Reader -&gt; 是一个抽象类</span><br><span class="line">      子类:FileReader</span><br><span class="line"><span class="number">2.</span>作用:将文本文档中的内容读取到内存中来</span><br><span class="line"><span class="number">3.</span>构造:</span><br><span class="line">  FileReader(File file)</span><br><span class="line">  FileReader(String path)</span><br><span class="line"><span class="number">4.</span>方法:</span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> -&gt; 一次读取一个字符,返回的是读取字符对应的<span class="type">int</span>值 </span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf)</span> -&gt; 一次读取一个字符数组,返回的是读取个数  </span><br><span class="line">  <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span> -&gt; 一次读取一个字符数组一部分,返回的是读取个数</span><br><span class="line">           cbuf:读取的数组</span><br><span class="line">           off:从数组的哪个索引开始读</span><br><span class="line">           len:读多少个</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> -&gt; 关闭资源    </span><br></pre></td></tr></table></figure>

<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>概述:字符输出流 -&gt; Writer -&gt; 抽象类</span><br><span class="line">  子类:FileWriter</span><br><span class="line"><span class="number">2.</span>作用:将数据写到文件中</span><br><span class="line"><span class="number">3.</span>构造:</span><br><span class="line">  FileWriter(File file) </span><br><span class="line">  FileWriter(String fileName)     </span><br><span class="line">  FileWriter(String fileName, <span class="type">boolean</span> append) -&gt; 追加,续写 </span><br><span class="line"><span class="number">4.</span>方法:</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> -&gt; 一次写一个字符 </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf)</span> 一次写一个字符数组 </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span> 一次写一个字符数组一部分  </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> 直接写一个字符串</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>  :将缓冲区中的数据刷到文件中    </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  关流</span><br><span class="line">      </span><br><span class="line"><span class="number">5.</span>注意:FileWriterr底层自带一个缓冲区,我们写的数据会先保存到缓冲区中,所以我们需要将缓冲区中的数据刷到文件中      </span><br></pre></td></tr></table></figure>

<blockquote>
<p>flush():将缓冲区中的数据刷到文件中,后续流对象还能继续使用<br>close():先刷新后关闭,后续流对象不能使用了</p>
</blockquote>
<h4 id="IO异常的处理方式"><a href="#IO异常的处理方式" class="headerlink" title="IO异常的处理方式"></a>IO异常的处理方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;module21\\3.txt&quot;</span>);</span><br><span class="line">    fw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//如果fw不为null,证明new出来了所以需要close;相反不需要close</span></span><br><span class="line">    <span class="keyword">if</span> (fw!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的点, 就在finally中close, 但是需要先判断是不是null, 也就是对象有没有成功new出来的情况</p>
</blockquote>
<h4 id="JDK7之后io异常处理方式"><a href="#JDK7之后io异常处理方式" class="headerlink" title="JDK7之后io异常处理方式"></a>JDK7之后io异常处理方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>格式:</span><br><span class="line">  <span class="keyword">try</span>(IO对象)&#123;</span><br><span class="line">      可能出现异常的代码</span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 对象名)&#123;</span><br><span class="line">      处理异常</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2.</span>注意:</span><br><span class="line">  以上格式处理IO异常,会自动关流</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;module21\\4.txt&quot;</span>);)&#123;</span><br><span class="line">            fw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="缓冲字节流"><a href="#缓冲字节流" class="headerlink" title="缓冲字节流"></a>缓冲字节流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">出现的理由</span><br><span class="line">	1. FileInputStream和FileOutputSream读取和写入字节流, 都是直接在内存的读写</span><br><span class="line">	获取到了就会读取/写入 -&gt; 造成了频繁的IO</span><br><span class="line">	2. 而Buffer会在读/写的时候, 将字节流先存储在缓冲区数组(8192), 过程变成了</span><br><span class="line">	读 : 磁盘 -&gt; 内存</span><br><span class="line">	写 : 获取 -&gt; 内存 -&gt; 磁盘</span><br><span class="line">	最后一次性将内容IO出去</span><br><span class="line">创建方法</span><br><span class="line">	1. 先new FileinputStream fis</span><br><span class="line">	2. new BufferedInputStream(fis)</span><br><span class="line">    </span><br><span class="line">使用方法</span><br><span class="line">	和基本流一样使用</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> IOBufferModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        method1();</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"><span class="comment">//         使用缓冲流</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;com.java.advanced/src/IOBufferModule/1.html&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;com.java.advanced/src/IOBufferModule/2.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//        使用基本流</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;com.java.advanced/src/IOBufferModule/1.html&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;com.java.advanced/src/IOBufferModule/2.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(end - start);</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节:</p>
<p>​	1. 使用缓冲流的时候最后为什么不需要关闭基本流</p>
<p>​		缓冲流的close底层会自动关闭基本流</p>
<ol start="2">
<li><p>缓冲流底层有数组, 都是在内存之间进行读写, 那么缓冲流读写的过程是怎么样的</p>
<p>硬盘 -&gt; 输入流缓冲区 -&gt; len变量 -&gt; 输出流缓冲区 -&gt; 磁盘</p>
</li>
</ol>
</blockquote>
<h3 id="字符缓冲输入流-BufferedReader"><a href="#字符缓冲输入流-BufferedReader" class="headerlink" title="字符缓冲输入流_BufferedReader"></a>字符缓冲输入流_BufferedReader</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Reader : </span><br><span class="line">创建 :</span><br><span class="line">	和BufferedInputStream一样, 通过传递子类, new出来的</span><br><span class="line">使用 : 和FileReader一样. 多了个特殊方法</span><br><span class="line">特殊方法 : readLine() -&gt; 读取一行</span><br><span class="line"></span><br><span class="line">Writer : </span><br><span class="line">创建 :</span><br><span class="line">	和BufferedInputStream一样, 通过传递子类, new出来的</span><br><span class="line">使用 : 和FileWriter一样. 多了个特殊方法</span><br><span class="line">特殊方法 : newLine() -&gt; 换行</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoBufferedWriter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        write();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;module01/src/com/java/buffer/1.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            line = br.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;module01/src/com/java/buffer/1.txt&quot;</span>));</span><br><span class="line">        writer.write(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">        writer.newLine();</span><br><span class="line">        writer.write(<span class="string">&quot;疑是地上霜&quot;</span>);</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p><strong>InputStreamReader</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">和FileReader一样使用, 可以按照指定的编码规则去读数据</span><br><span class="line">构造:</span><br><span class="line">	InputStreamReader(InputStream in, String charsetName)</span><br><span class="line">											charsetName:指定编码, 不区分大小写</span><br></pre></td></tr></table></figure>

<p><strong>OutputStreamWriter</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">和FileWriter一样使用, 可以按照指定的编码规则去读数据</span><br><span class="line">构造:</span><br><span class="line">	OutputStreamWriter(OutputStream out,String charsetName)</span><br><span class="line">											charsetName:指定编码, 不区分大小写</span><br></pre></td></tr></table></figure>

<h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><ol>
<li><p>作用</p>
<ul>
<li>我们想让数据存储以后不是可以直接读, 比如用户信息, 我们并不希望可以直接通过点开文件就能直接读, 于是我们需要一种加密手段, 就像C中的二进制文件一样</li>
<li>这种加密手段就是序列化</li>
</ul>
</li>
<li><p>序列化</p>
<ul>
<li><p>序列化 -&gt; <code>ObjectOutputStream</code>, 反序列化 -&gt; <code>ObjectInputStream</code></p>
</li>
<li><p>想要将对象序列化的文件中, 被序列化的对象需要实现Serializable接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.objectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoObjectOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">//        method01();</span></span><br><span class="line">        method02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method02</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;module01/src/com/java/objectOutputStream/demoObjectOutputStream.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;module01/src/com/java/objectOutputStream/demoObjectOutputStream.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        oos.writeObject(p1);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化时出现的问题"><a href="#反序列化时出现的问题" class="headerlink" title="反序列化时出现的问题"></a>反序列化时出现的问题</h3><ol>
<li><p>序列化之后, 修改了对象, 但是没有重新序列化, 直接反序列化了, 就会出现了序列号冲突的问题, 本质上是一种不匹配的问题, 修改前和修改后的对象, 系统分配的序列号不同</p>
<ul>
<li>解决方法 -&gt; 直接在对象里指定序列号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为对象加上属性</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">43L</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>这样只能解决由访问权限发生变化带来的序列号变化</p>
</blockquote>
</li>
<li><p>循环获取多个序列化对象的时候循环次数和序列化的对象的个数不同的问题</p>
<ul>
<li>解决方法 : 将数据打包 -&gt; 将数据放在集合中, 再将整个集合序列化 -&gt; 将集合反序列化, 从集合中获取对象</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="42-Junit"><a href="#42-Junit" class="headerlink" title="42. Junit"></a>42. Junit</h1><h2 id="42-1-各个注解的运行时机与限制"><a href="#42-1-各个注解的运行时机与限制" class="headerlink" title="42.1 各个注解的运行时机与限制"></a>42.1 各个注解的运行时机与限制</h2><ul>
<li><code>@Test</code> : <ul>
<li>限制<ul>
<li>只能修饰无参无返回方法</li>
<li>不能修饰静态方法</li>
</ul>
</li>
</ul>
</li>
<li><code>@Before</code><ul>
<li>时机 <ul>
<li>每个<code>@Test</code>方法运行前都会运行一次的代码块</li>
</ul>
</li>
<li>限制<ul>
<li>和<code>@Test</code>一致</li>
</ul>
</li>
</ul>
</li>
<li><code>@After</code><ul>
<li>时机<ul>
<li>每个<code>@Test</code>方法运行后都会运行一次的代码块</li>
</ul>
</li>
</ul>
</li>
<li><code>@BeforeClass</code><ul>
<li>时机<ul>
<li>所有<code>@Test</code>运行之前, 会运行一次的代码块</li>
</ul>
</li>
<li>限制<ul>
<li>只能修饰静态方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="42-2-对于限制的解释"><a href="#42-2-对于限制的解释" class="headerlink" title="42.2 对于限制的解释"></a>42.2 对于限制的解释</h2><ul>
<li><p>为什么要有这些修饰的限制, 可以从生命周期和修饰的级别的角度说明</p>
</li>
<li><p>修饰的级别</p>
<ul>
<li><pre><code>|-@BeforeClass =&gt; 类级别的初始化方法
|------|-@Before =&gt; 方法级别的初始化方法
|------|------|-@Test =&gt; 测试方法
|------|-@After =&gt; 方法级别的清理
|------|-@Before
|------|------|-@Test
|------|-@After
|-@AfterClass =&gt; 类级别的清理
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 生命周期</span><br><span class="line"></span><br><span class="line">  - 为了保证测试的隔离性, 每个测试用例会生成新的测试实例, 在里面执行测试代码</span><br><span class="line">  - `@BeforeClass`在所有测试实例创建之前执行一次</span><br><span class="line">  - `@Before, @Test, @After` 都在测试实例中被创建和执行</span><br><span class="line">  - `@AfterClass`在所有测试实例执行完毕后执行一次</span><br><span class="line"></span><br><span class="line">- 测试类中的属性</span><br><span class="line"></span><br><span class="line">  - 假设测试类中有个属性int counter 初始化为 1;</span><br><span class="line">  - 则对于每个新的测试实例, 新建的实例中的counter初始都是1</span><br><span class="line">  - 所以`@Before, @Test, @After`需要是非静态的方法, 从而使得它修饰的函数能访问测试实例中属性</span><br><span class="line">  - 但是对于`@BeforeClass`这个类级别的修饰, 如果我想有一个对于所有的测试实例都共享的数据, 这个时候很明显它只能是静态数据, 因为所有的测试实体都是被新创建的, 非静态的数据是无法相互之间传递的</span><br><span class="line"></span><br><span class="line"># 43. 类加载器</span><br><span class="line"></span><br><span class="line">## 43.1 概念介绍</span><br><span class="line"></span><br><span class="line">类加载器是用来干什么的</span><br><span class="line"></span><br><span class="line">- 情景 : 我们如果需要使用类, 需要将类从class文件中加载到内存中, 现在该由谁来加载类? 加载类的时机什么? 为什么需要这个工具?</span><br><span class="line"></span><br><span class="line">- 由谁来加载类</span><br><span class="line">  - 类加载器, 并不是直接由JVM从class文件中加载类, 而是由类加载器ClassLoader将类从磁盘中加载到内存中</span><br><span class="line">- 为什么需要这个工具</span><br><span class="line">  - 显然, 在最开始的时候将所有的类一股脑的加载下来并不是一个效率的做法, 就像C语言中直接引入所有的头文件一样愚蠢, 对于资源有极大的浪费</span><br><span class="line">- 加载类的时机是什么</span><br><span class="line">  - 在类被使用时候ClassLoader从class文件中加载到内存中</span><br><span class="line"></span><br><span class="line">## 43.2 类加载器的层级和运行流程</span><br><span class="line"></span><br><span class="line">- 情景 : Java将类和类加载器分为三个层级, 但是现在我们有了一个类, 我们如何知道我们该由哪个类加载器加载</span><br><span class="line">  - BootStrap ClassLoader :  启动类加载器加载的系统性质的类</span><br><span class="line">  - Extension ClassLoader : 拓展类加载器加载和处理安全加密类相关的拓展类</span><br><span class="line">  - Application ClassLoader : 用户自己创建的类</span><br><span class="line">- 运行流程</span><br><span class="line">  1. 类 =&gt; AppLoader =&gt; ExtLoader =&gt; BootLoader</span><br><span class="line">  2. 由最后一级BootLoader先寻找, 如果没有找到这个类, 这个类不是BootLoader管的, 返回信息</span><br><span class="line">  3. 现在由ExtLoader寻找, 如果没有找到, 返回没有找到的信息</span><br><span class="line">  4. 现在由AppLoader寻找</span><br><span class="line">  5. BootLoader =&gt; ExtLoader =&gt; AppLoader =&gt; Class</span><br><span class="line">- 这样的运行顺序保证了一定是底层系统性质的类覆盖上层的类, 保证了核心库的安全性</span><br><span class="line">- 如果有一个类被查找到了, 会被它的那个层级的Loader缓存下来, 下次再需要访问的时候, 直接从换从中获取, 而不是重新从磁盘中读取</span><br><span class="line">- 三个类加载器之间有逻辑上的层级关系和父子关系, 但是没有实际上的继承关系, 他们都继承自同意父类`ClassLoader`</span><br><span class="line"></span><br><span class="line">## 43.3 获取ClassLoader</span><br><span class="line"></span><br><span class="line">如何获取Classloader呢</span><br><span class="line"></span><br><span class="line">- 通过`类.class.getClassLoader()`</span><br><span class="line">- 通过`类.class.getClassLoader().getParent()`获取当前的类加载器的父类加载器</span><br><span class="line"></span><br><span class="line">- 无法获取BootStrapLoader层级的类加载器, 返回的是null</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * 说明类的加载机制</span><br><span class="line"> */</span><br><span class="line">public class DemoClassLoader &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testBootstrapLoader()&#123;</span><br><span class="line">        //测试启动类加载器</span><br><span class="line">        ClassLoader classLoader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(&quot;classLoader = &quot; + classLoader);</span><br><span class="line">        // 启动类的加载器是用c语言写的, 无法直接获取</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader1 = DemoClassLoader.class.getClassLoader().getParent().getParent();</span><br><span class="line">        System.out.println(&quot;classLoader1 = &quot; + classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testExtensionLoader()&#123;</span><br><span class="line">        //测试拓展类加载器</span><br><span class="line">        ClassLoader classLoader = DemoClassLoader.class.getClassLoader().getParent();</span><br><span class="line">        System.out.println(&quot;classLoader = &quot; + classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testApplicationLoader()&#123;</span><br><span class="line">        //测试应用类加载器</span><br><span class="line">        ClassLoader classLoader = DemoClassLoader.class.getClassLoader();</span><br><span class="line">        System.out.println(&quot;classLoader = &quot; + classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>^reject</p>
<h1 id="44-反射"><a href="#44-反射" class="headerlink" title="44. 反射"></a>44. 反射</h1><h2 id="44-1-反射的意义"><a href="#44-1-反射的意义" class="headerlink" title="44.1. 反射的意义"></a>44.1. 反射的意义</h2><ul>
<li><p>情景 : 现在我们需要开发大型的或者说集成度很高的框架供多元的使用者使用, 这个时候我们无法得知使用者的传进来的类, 和其中有哪些方法, 但是我们又确实需要知道这些信息, 比如这个类的类型, 这个类中的某些方法, 这个时候我们就能通过反射获取这些 “标签”</p>
</li>
<li><p>反射能做到的事, 获取类的类型, 类的成员变量, 类的成员方法, 类的构造方法</p>
</li>
<li><p>反射让代码更灵活并且拓展了代码泛用性, 但是因为是动态读取的, 在性能上并不是很好</p>
</li>
</ul>
<h2 id="44-2-反射获取内容"><a href="#44-2-反射获取内容" class="headerlink" title="44.2 反射获取内容"></a>44.2 反射获取内容</h2><h3 id="44-2-1-获取对象的Class类"><a href="#44-2-1-获取对象的Class类" class="headerlink" title="44.2.1 获取对象的Class类"></a>44.2.1 获取对象的Class类</h3><p>首先获取目标类的Class&lt;?&gt;对象, 这个类中包含这个类的元数据(定义) : 类名, 父类, 实现的接口, 类修饰符, 方法, 字段等</p>
<p>该对象有三种获取方式</p>
<ul>
<li>直接通过类名获取, MyClass.class获取</li>
<li>myObject.getClass() : 通过对象实例获取</li>
<li>Class.forName(“com.example.MyClass”): 通过类的全限定名获取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetClass</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 1. 通过getClass方法获取Class对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; aClass1 = person.getClass();</span><br><span class="line">    System.out.println(<span class="string">&quot;aClass1 = &quot;</span> + aClass1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通过每个类的.class静态成员, 这个是jvm为所有类型提供的一个成员</span></span><br><span class="line">    Class&lt;Person&gt; aClass2 = Person.class;</span><br><span class="line">    System.out.println(<span class="string">&quot;aClass2 = &quot;</span> + aClass2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. static Class&lt;?&gt; forName获取</span></span><br><span class="line">    Class&lt;?&gt; aClass3 = Class.forName(<span class="string">&quot;com.javaSE.Person&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;aClass3 = &quot;</span> + aClass3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-2-2-最通用的获取Class类的方式"><a href="#44-2-2-最通用的获取Class类的方式" class="headerlink" title="44.2.2 最通用的获取Class类的方式"></a>44.2.2 最通用的获取Class类的方式</h3><p>通过类名.class获取</p>
<h3 id="44-3-1-获取构造方法"><a href="#44-3-1-获取构造方法" class="headerlink" title="44.3.1 获取构造方法"></a>44.3.1 获取构造方法</h3><h4 id="1-获取所有公有的构造方法"><a href="#1-获取所有公有的构造方法" class="headerlink" title="1. 获取所有公有的构造方法"></a>1. 获取所有公有的构造方法</h4><ul>
<li><p>流程</p>
<ol>
<li>构建<code>Constructor[]</code>数组, 用于接收从<code>class.getConstructors()</code>的构造方法对象</li>
<li>通过<code>for</code>循环遍历获取</li>
</ol>
</li>
<li><p>code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">    Class&lt;?&gt; aClass = Person.class;</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-获取特定的构造方法"><a href="#2-获取特定的构造方法" class="headerlink" title="2. 获取特定的构造方法"></a>2. 获取特定的构造方法</h4><ul>
<li><p>流程</p>
<ol>
<li>通过<code>Constructor</code>类型接收<code>class.getConstructor(Type p1....)</code>的返回</li>
<li>通过传递的参数类型来指定获取的构造函数比如填入()就是空参构造, 如果填入<code>(String.class)</code>就是用于获取参数列表是只传递了一个String的构造函数</li>
<li>通过构造方法, 能构建出新的实例, 通过调用<code>newInstance(参数...)</code>方法</li>
</ol>
</li>
<li><p>code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; aClass = Person.class;</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; constructor = aClass.getConstructor(String.class, Integer.class);</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;fang&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;p = &quot;</span> + p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-获取私有的方法"><a href="#3-获取私有的方法" class="headerlink" title="3. 获取私有的方法"></a>3. 获取私有的方法</h4><ul>
<li><p>流程</p>
<ol>
<li>将上面两者的<code>getConstructor</code>修改为<code>getDeclaredConstructor(s)</code>即可</li>
<li>如果还要能使用, 还需要<code>.setAccessible(true)</code>来解除私有的权限</li>
</ol>
</li>
<li><p>code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetPrivateConstructor</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// 获取私有构造</span></span><br><span class="line">    Class&lt;?&gt; aClass = Person.class;</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt;[] dc = aClass.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : dc) &#123;</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除私有构造的权限, 使之能使用私有构造</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = aClass.getDeclaredConstructor(String.class);</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;fung&quot;</span>);</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="44-4-通用的结构"><a href="#44-4-通用的结构" class="headerlink" title="44.4 通用的结构"></a>44.4 通用的结构</h3><ul>
<li>接下来介绍获取(使用)成员方法, 获取和构建成员变量, 都是一样的结构, 关注的方面都是接下来的几个方面, 只会给出代码<ul>
<li>获取所有public</li>
<li>获取特定的public</li>
<li>获取所有的方法(包含private)</li>
<li>获取特定的private</li>
<li>以及用于接收的类型</li>
<li>如何使用获取的内容</li>
</ul>
</li>
</ul>
<h3 id="44-5-获取成员方法"><a href="#44-5-获取成员方法" class="headerlink" title="44.5 获取成员方法"></a>44.5 获取成员方法</h3><ul>
<li><p>使用<code>Method</code>接收</p>
</li>
<li><p>获取所有的public &#x3D;&gt; <code>aClass.getMethods()</code></p>
</li>
<li><p>获取特定的方法 &#x3D;&gt; <code>aClass.getMethod(&quot;方法名&quot;, 这个方法需要传递的参数列表...)</code></p>
</li>
<li><p>获取所有的方法 &#x3D;&gt; <code>aClass.getDeclaredMethods()</code></p>
</li>
<li><p>获取特定的方法(可以是private) &#x3D;&gt; <code>aClass.getDeclaredMethod(&quot;方法名&quot;, 这个方法需要传递的参数列表...)</code></p>
</li>
<li><p>如何使用</p>
<ul>
<li>使用Object接收返回的结果, 因为不知道类型</li>
<li>调用<code>Method.invoke(对象, 参数列表)</code>来执行方法</li>
<li>如果是私有方法同样需要调用<code>setAccessiable(true)</code>来解除私有的权限</li>
</ul>
</li>
<li><p>code</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过Class使用public成员方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetMethods</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Class&lt;Person&gt; aClass = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的public方法</span></span><br><span class="line">    Method[] methods = aClass.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定的public方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">    System.out.println(setName);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> setName.invoke(p, <span class="string">&quot;fung&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> method.invoke(p);</span><br><span class="line">    System.out.println(<span class="string">&quot;o1 = &quot;</span> + o1);</span><br><span class="line">    System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过Class使用private方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetPrivateMethods</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// 获取所有方法</span></span><br><span class="line">    Class&lt;Person&gt; aClass = Person.class;</span><br><span class="line"></span><br><span class="line">    Method[] declaredMethods = aClass.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">        System.out.println(declaredMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定的private方法并使用</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    privateMethod.invoke(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-6-成员变量"><a href="#44-6-成员变量" class="headerlink" title="44.6 成员变量"></a>44.6 成员变量</h3><ul>
<li><p>获取所有public &#x3D;&gt; <code>aClass.getFiedls()</code></p>
</li>
<li><p>获取特定的public &#x3D;&gt; <code>aClass.getField(&quot;字段名&quot;)</code></p>
</li>
<li><p>获取所有的方法(包含private) &#x3D;&gt; <code>aClass.getDeclaredFields()</code></p>
</li>
<li><p>获取特定的private &#x3D;&gt; <code>aClass.getDeclaredField(&quot;字段名&quot;)</code></p>
</li>
<li><p>以及用于接收的类型 &#x3D;&gt; <code>Field</code></p>
</li>
<li><p>如何使用获取的内容</p>
<ul>
<li>通过<code>Field.set(对象实例, 值)</code>的形式赋值</li>
<li>通过<code>Filed.get(对象)</code>的形式获取值</li>
<li>通过<code>Filed.getType()</code>的形式获取属性的class对象</li>
</ul>
</li>
<li><p>code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过Class获取成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetField</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Class&lt;Person&gt; aClass = Person.class;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line"></span><br><span class="line">    Field[] pubFields = aClass.getFields();</span><br><span class="line">    Field[] allFields = aClass.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field pubField : pubFields) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pubField = &quot;</span> + pubField);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Field allField : allFields) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;allField = &quot;</span> + allField);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&lt;==================&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    name.set(p,<span class="string">&quot;fang&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> name.get(p);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">publicField</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;publicField&quot;</span>);</span><br><span class="line">    publicField.set(p,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> publicField.get(p);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="45-注解"><a href="#45-注解" class="headerlink" title="45 注解"></a>45 注解</h1><p>[[Spring#10.1 回顾注解开发]]</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io">Fun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fang-tech.github.io/2025/07/08/Java/JavaSE/javaAdvance/">https://fang-tech.github.io/2025/07/08/Java/JavaSE/javaAdvance/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://fang-tech.github.io" target="_blank">窄门</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/08/Java/JavaSE/javaBase/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">1. JDK和JRE1234567891. jdk : (Java Development Kit) : Java开发工具包   javac : 编译工具   jdb 调试工具   java 运行工具   jhat 内存分析工具   ...2. jre  (Java runtime Environment):java运行环境, 包含jvm以及后面开发用到的核心类库   3. jdk包含了jre包含了jvm  2. 编译和运行123451. 将文件后缀改为java    使用javac + 文件名.java编译java文件, 并生成可运行文件(.class文件)    2. 运行文件    java + 文件名(没有后缀, 默认识别.class文件)  3. 文档注释1234使用/***/正常写文档注释后, JDK提供工具快速生成总结了所有文档注释的可视化界面文件    1. 书写文档注释2. 使用javadoc -d api -suthor -version &lt;filename&gt;  4. java中的class的特殊命名规则  public类的类名需要和文件名一致 非...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Java/Dependency-Manager/Maven/code/maven_test/maven_web/target/maven_web-1.0-SNAPSHOT/index/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">            Title    index.html  </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/08/Java/JavaSE/javaBase/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-08</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">1. JDK和JRE1234567891. jdk : (Java Development Kit) : Java开发工具包   javac : 编译工具   jdb 调试工具   java 运行工具   jhat 内存分析工具   ...2. jre  (Java runtime Environment):java运行环境, 包含jvm以及后面开发用到的核心类库   3. jdk包含了jre包含了jvm  2. 编译和运行123451. 将文件后缀改为java    使用javac + 文件名.java编译java文件, 并生成可运行文件(.class文件)    2. 运行文件    java + 文件名(没有后缀, 默认识别.class文件)  3. 文档注释1234使用/***/正常写文档注释后, JDK提供工具快速生成总结了所有文档注释的可视化界面文件    1. 书写文档注释2. 使用javadoc -d api -suthor -version &lt;filename&gt;  4. java中的class的特殊命名规则  public类的类名需要和文件名一致 非...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Java/DataBase/JDBC/JDBC/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-08</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">JDBC基础篇2. JDBC的概述java只实现了连接数据库的接口的规范, 而没有定义详细的实现, 详细的实现交给实际的数据库场上实现, 所以想通过Java连接特定的数据库, 实际上需要下载对应厂商的jar包 3. Quick-start123456789101112131415161718192021222324252627282930// 1. 指明使用的数据库, 为其创建驱动Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);// 2. 建立与数据库的连接String url = &quot;jdbc:mysql://localhost:3306/atguigu&quot;;String username = &quot;root&quot;;String password = &quot;root&quot;;Connection connection = DriverManager.getConnection(url, username, password);// 3. 创建承载语句的对象Statement state...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Java/Dependency-Manager/Maven/Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-08</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">Maven依赖管理项目构建工具目录[TOC] 一、Maven简介1、为什么学习Maven1.1、Maven是一个依赖管理工具①jar 包的规模 随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。 比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能：  Nacos 服务注册发现 Web 框架环境 视图模板技术 Thymeleaf  最终却导入了 106 个 jar 包：  org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compilecom.netflix.ribbon: ribbon:jar:2.3.0:compileorg.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compilecommons-configuration:commons-configuration:jar:...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Java/JavaWeb/%E7%AC%94%E8%AE%B0/Ajax/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-08</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">Ajax1. Ajax概述 AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。  AJAX 不是新的编程语言，而是一种使用现有标准的新方法。  AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。  AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。  XMLHttpRequest 只是实现 Ajax 的一种方式。   ajax工作原理： ![[images&#x2F;image_bjXPJoLb6a-1690508517199.png]]  简单来说,我们之前发的请求通过类似  form表单标签,a标签 这种方式,现在通过 运行js代码动态决定什么时候发送什么样的请求 通过运行JS代码发送的请求浏览器可以不用跳转页面 ,我们可以在JS代码中决定是否要跳转页面 通过运行JS代码发送的请求,接收到返回结果后,我们可以将结果通过dom编程渲染到页面的某些元素上,实现局部更新  2 如何实现ajax请求 原生javascript方...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Java/JavaWeb/%E7%AC%94%E8%AE%B0/CSS/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-08</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">CSScss的三种引入方式 行内式 直接将style放在对应的标签内部    1234567891011121314&lt;input type=&quot;button&quot; value=&quot;按钮&quot;        style=&quot;              display: block;              width: auto;              height: auto;              font-family: 隶书;              background-color: bisque;              border-radius: 5px;              border: 3px solid goldenrod;              color: brown;              font-size: 22px;              line-height: 30px;              &quot;       /&gt;   内嵌式 将行内式的style提...</div></div></div></a><a class="pagination-related" href="/2025/07/08/Java/JavaWeb/%E7%AC%94%E8%AE%B0/ES6/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-08</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">ES61. ES6的介绍 ECMAScript 6，简称ES6，是JavaScript语言的一次重大更新。它于2015年发布，是原来的ECMAScript标准的第六个版本。ES6带来了大量的新特性，包括箭头函数、模板字符串、let和const关键字、解构、默认参数值、模块系统等等，大大提升了JavaScript的开发体验。由于VUE3中大量使用了ES6的语法,所以ES6成为了学习VUE3的门槛之一 ES6对JavaScript的改进在以下几个方面：   更加简洁：ES6引入了一些新的语法，如箭头函数、类和模板字符串等，使代码更加简洁易懂。  更强大的功能：ES6引入了一些新的API、解构语法和迭代器等功能，从而使得JavaScript更加强大。  更好的适用性：ES6引入的模块化功能为JavaScript代码的组织和管理提供了更好的方式，不仅提高了程序的可维护性，还让JavaScript更方便地应用于大型的应用程序。    总的来说，ES6在提高JavaScript的核心语言特性和功能方面取得了很大的进展。由于ES6已经成为了JavaScript的标准，它的大多数新特性都已被现在...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Fun</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">239</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">1. 继承的基础使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">2. 方法的重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-super%E5%92%8Cthis"><span class="toc-number">3.</span> <span class="toc-text">3. super和this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-super%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">4. super的具体使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-this%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">5. this的具体使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">6. 抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">7. 接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A4%9A%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">8. 多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">13. 静态成员内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">14. 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8Efinally"><span class="toc-number">11.</span> <span class="toc-text">15异常处理与finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">16. Object类中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-String%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">13.</span> <span class="toc-text">17. String基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-StringBuilder"><span class="toc-number">14.</span> <span class="toc-text">18. StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Math%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">19. Math工具类 :</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-BigInteger-%E5%A4%A7%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">20. BigInteger : 大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-BigDecimal-%E5%87%86%E7%A1%AE%E7%9A%84%E5%B0%8F%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">21. BigDecimal : 准确的小数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Calendar-%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-number">18.</span> <span class="toc-text">22. Calendar 日历类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-SimpleDateFormat-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%97%A5%E6%9C%9F"><span class="toc-number">19.</span> <span class="toc-text">23. SimpleDateFormat : 格式化输入输出日期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-JDK8%E6%96%B0%E5%A2%9E%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">20.</span> <span class="toc-text">24. JDK8新增日期类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-System%E7%B1%BB"><span class="toc-number">21.</span> <span class="toc-text">25. System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Arrays%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">22.</span> <span class="toc-text">26. Arrays数组工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">23.</span> <span class="toc-text">27. 包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-String%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">24.</span> <span class="toc-text">28. String和基本类型之间的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-javabean%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">25.</span> <span class="toc-text">29. javabean和包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">26.</span> <span class="toc-text">30. 创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F-extends-Thread"><span class="toc-number">26.1.</span> <span class="toc-text">第一种方式 extends Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">26.1.1.</span> <span class="toc-text">Thread类中的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E4%B8%AD%E5%85%B6%E4%BB%96%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">26.1.2.</span> <span class="toc-text">Thread中其他的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.2.</span> <span class="toc-text">第二种方式 实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">26.3.</span> <span class="toc-text">第三种方式  匿名内部类创建多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">27.</span> <span class="toc-text">31. 解决线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">27.0.1.</span> <span class="toc-text">同步代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">27.1.</span> <span class="toc-text">同步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%E9%9D%9E%E9%9D%99%E6%80%81"><span class="toc-number">27.1.1.</span> <span class="toc-text">普通同步方法 : 非静态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">27.1.2.</span> <span class="toc-text">静态同步方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%AD%BB%E9%94%81"><span class="toc-number">28.</span> <span class="toc-text">32. 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">29.</span> <span class="toc-text">33. 线程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-wait%E5%92%8Cnotify"><span class="toc-number">30.</span> <span class="toc-text">34. wait和notify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-Callable%E6%8E%A5%E5%8F%A3-%E6%9C%89%E8%BF%94%E5%9B%9E%E7%9A%84%E5%80%BC%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">31.</span> <span class="toc-text">35. Callable接口 : 有返回的值的线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">32.</span> <span class="toc-text">36. 线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-Timer-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">33.</span> <span class="toc-text">37. Timer - 定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E9%9B%86%E5%90%88"><span class="toc-number">34.</span> <span class="toc-text">38. 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E9%A1%B6%E7%BA%A7%E6%8E%A5%E5%8F%A3-Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">34.1.</span> <span class="toc-text">各个集合的顶级接口 : Collection接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">34.2.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">34.2.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">34.2.2.</span> <span class="toc-text">并发修改异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">34.3.</span> <span class="toc-text">ArrayList 底层分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedList"><span class="toc-number">34.4.</span> <span class="toc-text">linkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">34.5.</span> <span class="toc-text">Collection集合工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">34.6.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">34.6.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">34.6.2.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">34.6.3.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">34.6.4.</span> <span class="toc-text">泛型通配符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">34.7.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">34.8.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E7%9A%84%E5%8E%BB%E9%87%8D%E5%A4%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">34.9.</span> <span class="toc-text">HashSet的去重复过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E5%8E%BB%E9%87%8D%E5%A4%8D"><span class="toc-number">34.10.</span> <span class="toc-text">HashSet存储自定义类型如何去重复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-Map%E9%9B%86%E5%90%88"><span class="toc-number">35.</span> <span class="toc-text">39. Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">35.1.</span> <span class="toc-text">Map遍历的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96key-%E5%86%8D%E6%A0%B9%E6%8D%AEkey%E8%8E%B7%E5%8F%96value"><span class="toc-number">35.1.1.</span> <span class="toc-text">获取key, 再根据key获取value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%8F%96%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">35.1.2.</span> <span class="toc-text">直接获取键值对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%A6%82%E4%BD%95%E5%8E%BB%E9%87%8D%E5%A4%8D"><span class="toc-number">35.2.</span> <span class="toc-text">Map存储自定义对象时如何去重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">35.3.</span> <span class="toc-text">HashSet需要注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%9D%A2%E7%AC%94%E8%AF%95%E6%97%B6%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%97%AE%E5%88%B0%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">35.4.</span> <span class="toc-text">外面笔试时可能会问到的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-number">35.5.</span> <span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">35.6.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-File%E7%B1%BB"><span class="toc-number">36.</span> <span class="toc-text">40. File类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">36.0.1.</span> <span class="toc-text">File静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">36.0.2.</span> <span class="toc-text">File的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">36.0.3.</span> <span class="toc-text">File的获取方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">36.0.4.</span> <span class="toc-text">File的创建方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E7%B1%BB%E7%9A%84%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">36.0.5.</span> <span class="toc-text">File类的删除方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E7%B1%BB%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-number">36.0.6.</span> <span class="toc-text">File类的判断方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">36.0.7.</span> <span class="toc-text">File的遍历方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">36.0.8.</span> <span class="toc-text">相对路径和绝对路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-IO%E6%B5%81"><span class="toc-number">37.</span> <span class="toc-text">41. IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-number">37.1.</span> <span class="toc-text">IO流分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStream%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB-FileOutputStream"><span class="toc-number">37.2.</span> <span class="toc-text">OutputStream中的子类[FileOutputStream]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream%E5%AD%90%E7%B1%BB-FileInputStream-%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">37.3.</span> <span class="toc-text">InputStream子类[FileInputStream]的介绍以及方法的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">37.4.</span> <span class="toc-text">读取-1的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">37.5.</span> <span class="toc-text">字节流实现图片复制代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">37.6.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">37.6.1.</span> <span class="toc-text">字节流的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileReader"><span class="toc-number">37.6.2.</span> <span class="toc-text">FileReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWriter"><span class="toc-number">37.6.3.</span> <span class="toc-text">FileWriter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">37.6.4.</span> <span class="toc-text">IO异常的处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK7%E4%B9%8B%E5%90%8Eio%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">37.6.5.</span> <span class="toc-text">JDK7之后io异常处理方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">37.7.</span> <span class="toc-text">缓冲字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%B5%81-BufferedReader"><span class="toc-number">37.8.</span> <span class="toc-text">字符缓冲输入流_BufferedReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">37.9.</span> <span class="toc-text">转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">37.10.</span> <span class="toc-text">序列化流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">37.11.</span> <span class="toc-text">反序列化时出现的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-Junit"><span class="toc-number"></span> <span class="toc-text">42. Junit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#42-1-%E5%90%84%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">42.1 各个注解的运行时机与限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-2-%E5%AF%B9%E4%BA%8E%E9%99%90%E5%88%B6%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">2.</span> <span class="toc-text">42.2 对于限制的解释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-%E5%8F%8D%E5%B0%84"><span class="toc-number"></span> <span class="toc-text">44. 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#44-1-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">44.1. 反射的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-2-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">44.2 反射获取内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#44-2-1-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84Class%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">44.2.1 获取对象的Class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-2-2-%E6%9C%80%E9%80%9A%E7%94%A8%E7%9A%84%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">44.2.2 最通用的获取Class类的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-3-1-%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">44.3.1 获取构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%85%AC%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 获取所有公有的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 获取特定的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">3. 获取私有的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-4-%E9%80%9A%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">44.4 通用的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-5-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">44.5 获取成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-6-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.6.</span> <span class="toc-text">44.6 成员变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-%E6%B3%A8%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">45 注解</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/wrench/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/3-%E5%8A%A8%E6%80%81%E9%99%90%E6%B5%81/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.870Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/wrench/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/1-DCC/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.868Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%9C%AA%E7%90%86%E8%A7%A3%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.857Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/deployment/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.856Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/Project/Big-Market/%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/9.%20%E4%BD%BF%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%A4%84%E7%90%86%E6%8A%BD%E5%A5%96%E8%A7%84%E5%88%99/" title="无标题">无标题</a><time datetime="2025-07-08T15:03:04.855Z" title="发表于 2025-07-08 23:03:04">2025-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Fun</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>