<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式架构-架构演进概述 | Function's Blog</title><meta name="author" content="Function"><meta name="copyright" content="Function"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考凤凰架构: 演进的架构一大章节  演进中的架构 计算机总是务实, 某一架构的出现和兴盛往往都是在承载着某个历史使命, 衰败则是因为使命的消失或者有了更好的方案. 所以想要知道某个架构的历史使命, 我们不得不向过去看, 了解到它到底是解决了之前无法解决的什么问题, 也要向现在看它为什么能兴盛, 最后向未来看它为什么衰败, 如此才能理解这个架构的历史和使命 @fung  原始分布式时代令人惊讶的">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式架构-架构演进概述">
<meta property="og:url" content="https://fang-tech.github.io/2025/07/25/project/Architecture/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E6%A6%82%E8%BF%B0/index.html">
<meta property="og:site_name" content="Function&#39;s Blog">
<meta property="og:description" content="参考凤凰架构: 演进的架构一大章节  演进中的架构 计算机总是务实, 某一架构的出现和兴盛往往都是在承载着某个历史使命, 衰败则是因为使命的消失或者有了更好的方案. 所以想要知道某个架构的历史使命, 我们不得不向过去看, 了解到它到底是解决了之前无法解决的什么问题, 也要向现在看它为什么能兴盛, 最后向未来看它为什么衰败, 如此才能理解这个架构的历史和使命 @fung  原始分布式时代令人惊讶的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg">
<meta property="article:published_time" content="2025-07-24T16:53:26.000Z">
<meta property="article:modified_time" content="2025-07-30T08:04:04.146Z">
<meta property="article:author" content="Function">
<meta property="article:tag" content="Architecture">
<meta property="article:tag" content="Distributed Systems">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "分布式架构-架构演进概述",
  "url": "https://fang-tech.github.io/2025/07/25/project/Architecture/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E6%A6%82%E8%BF%B0/",
  "image": "https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg",
  "datePublished": "2025-07-24T16:53:26.000Z",
  "dateModified": "2025-07-30T08:04:04.146Z",
  "author": [
    {
      "@type": "Person",
      "name": "Function",
      "url": "https://fang-tech.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg"><link rel="canonical" href="https://fang-tech.github.io/2025/07/25/project/Architecture/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E6%A6%82%E8%BF%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式架构-架构演进概述',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> 项目</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Architecture/Distributed-Systems"><i class="fa-fw fa-solid fa-layer-group"></i><span> 分布式架构</span></a></li><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-laptop-code"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-cogs"></i><span> 计算机基础</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm"><i class="fa-fw fas fa-route"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/OS"><i class="fa-fw fas fa-desktop"></i><span> OS</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/Network"><i class="fa-fw fas fa-network-wired"></i><span> 计算机网络</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Function's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">分布式架构-架构演进概述</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-folder"></i><span> 项目</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Architecture/Distributed-Systems"><i class="fa-fw fa-solid fa-layer-group"></i><span> 分布式架构</span></a></li><li><a class="site-page child" href="/categories/Project/AI-Agentic-System/"><i class="fa-fw fa-solid fa-robot"></i><span> AI Agentic System</span></a></li><li><a class="site-page child" href="/categories/Project/Lottery/"><i class="fa-fw fa-solid fa-ticket"></i><span> Lottery</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-gear"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Middleware/MySQL/"><i class="fa-fw fa-solid fa-database"></i><span> MySQL</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-laptop-code"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-cogs"></i><span> 计算机基础</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Computer-Fundamentals/Algorithm"><i class="fa-fw fas fa-route"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/OS"><i class="fa-fw fas fa-desktop"></i><span> OS</span></a></li><li><a class="site-page child" href="/categories/Computer-Fundamentals/Network"><i class="fa-fw fas fa-network-wired"></i><span> 计算机网络</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">分布式架构-架构演进概述</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-24T16:53:26.000Z" title="发表于 2025-07-25 00:53:26">2025-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-30T08:04:04.146Z" title="更新于 2025-07-30 16:04:04">2025-07-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Architecture/">Architecture</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Architecture/Distributed-Systems/">Distributed Systems</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://icyfenix.cn/architecture/architect-history/">凤凰架构: 演进的架构一大章节</a></p>
</blockquote>
<h1 id="演进中的架构"><a href="#演进中的架构" class="headerlink" title="演进中的架构"></a>演进中的架构</h1><blockquote>
<p>计算机总是务实, 某一架构的出现和兴盛往往都是在承载着某个历史使命, 衰败则是因为使命的消失或者有了更好的方案. 所以想要知道某个架构的历史使命, 我们不得不向过去看, 了解到它到底是解决了之前无法解决的什么问题, 也要向现在看它为什么能兴盛, 最后向未来看它为什么衰败, 如此才能理解这个架构的历史和使命 @fung</p>
</blockquote>
<h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><p>令人惊讶的是, 使用多个独立的分布式服务共同构建一个大型系统的设想和尝试, 反而是比今天的大型单体系统出现的时间更早</p>
<p>在20世纪70年代末期到80年代初, 计算机硬件的运算能力的局促, 直接妨碍到了在单台计算机上信息系统软件能够达到的最大规模. 于是计算机科学家们开始探索一种多台计算机共同协作来支撑一套软件系统, 这就是原始分布式时代</p>
<p>负责制定 UNIX 系统技术标准的“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E8%BB%9F%E9%AB%94%E5%9F%BA%E9%87%91%E6%9C%83">开放软件基金会</a>”（Open Software Foundation，OSF，也即后来的“国际开放标准组织”）邀请了当时业界主流的计算机厂商一起参与，共同制订了名为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distributed_Computing_Environment">分布式运算环境</a>”（Distributed Computing Environment，DCE）的分布式技术体系. </p>
<blockquote>
<p>UNIX 的分布式设计哲学</p>
<p>Simplicity of both the interface and the implementation are more important than any other attributes of the system — including correctness, consistency, and completeness</p>
<p>保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要。</p>
<p>—— <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Richard_P._Gabriel">Richard P. Gabriel</a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Worse_is_better">The Rise of ‘Worse is Better’</a>，1991</p>
</blockquote>
<p>OSF尝试设计出来一种简单的, 透明的远程方法调用模式, 让程序员无需关注自己使用的方法是本地方法还是远程方法</p>
<p>调用远程方法的网络环境带来了一系列的新问题</p>
<ul>
<li>远程服务在哪里(服务发现)</li>
<li>有多少个(负载均衡)</li>
<li>网络出现了分区, 超时或者服务出错怎么办(熔断, 隔离, 降级)</li>
<li>方法的参数和返回结果如何表示 (序列化协议)</li>
<li>信息如何传输 (传输协议)</li>
<li>服务权限如何管理 (认证, 授权)</li>
<li>如何保证通信安全 (网络安全层)</li>
<li>如何令调用不同机器的服务返回相同的结果 (分布式数据一致性)</li>
</ul>
<p>尝试的结果自然是失败的, 不然我们现在看到的应用也不会是现在的以单体应用为主的模式了. 远程和本地方法在性能上的鸿沟是无法跨越的(抛弃了内联等优化), 在当时得硬件条件下如果想为用户提供可以接受的速度的远程调用服务, 不得不使用将多个方法打包到同一个方法体中等奇技淫巧, 并且开发者必须无时无刻不意识到本地和远程之间的边界. 设计为性能让步, DCE的努力”付之东流”</p>
<p>不过在这个时期产出了很多后续分布式的关键技术和概念</p>
<ul>
<li>源自 NCA 的远程服务调用规范（Remote Procedure Call，RPC），当时被称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DCE/RPC">DCE&#x2F;RPC</a>，它与后来 Sun 公司向互联网工程任务组（Internet Engineering Task Force，IETF）提交的基于通用 TCP&#x2F;IP 协议的远程服务标准<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E7%B6%B2%E8%B7%AF%E9%81%8B%E7%AE%97%E9%81%A0%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%BC%E5%8F%AB">ONC RPC</a>被认为是现代 RPC 的共同鼻祖；</li>
<li>源自 AFS 的分布式文件系统（Distributed File System，DFS）规范，当时被称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DCE_Distributed_File_System">DCE&#x2F;DFS</a>；源自 Kerberos 的服务认证规范；</li>
<li>还有时间服务、命名与目录服务，就连现在程序中很常用的通用唯一识别符 UUID 也是在 DCE 中发明出来的。</li>
</ul>
<blockquote>
<p>原始分布式时代的教训</p>
<p>Just because something <strong>can</strong> be distributed doesn’t mean it <strong>should</strong> be distributed. Trying to make a distributed call act like a local call always ends in tears</p>
<p>某个功能<strong>能够</strong>进行分布式，并不意味着它就<strong>应该</strong>进行分布式，强行追求透明的分布式操作，只会自寻苦果</p>
<p>—— <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kyle_Brown_(computer_scientist)">Kyle Brown</a>，IBM Fellow，<a target="_blank" rel="noopener" href="https://developer.ibm.com/technologies/microservices/articles/cl-evolution-microservices-patterns/">Beyond Buzzwords: A Brief History of Microservices Patterns</a>，2016</p>
</blockquote>
<h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><blockquote>
<p>单体架构（Monolithic）</p>
<p>“单体”只是表明系统中<strong>主要的过程调用</strong>都是进程内调用，不会发生进程间通信，仅此而已。</p>
</blockquote>
<p>单体架构是最早的架构, 也是使用得最自然的架构, 以至于相当长的一段时间里人们都没有去为单体架构专门下一个定义出来</p>
<p>在剖析单体架构之前, 非常有必要理清的一个概念就是, 单体架构并不是”不如”微服务架构, 在书籍中常出现的作为微服务架构的对比对象, 来说明单体系统的不足, 实际上是<strong>大型</strong>单体系统, 对于小型系统上单体架构有自己的优势</p>
<p>小型系统上, 单体架构易开发, 易部署, 易测试. 调用过程都是进程间调用, 运行效率最高</p>
<p>同时在纵向上, 无论是单体还是微服务抑或是其他架构风格, 都会对代码进行纵向的分层, 这点无关架构.</p>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250728235126.png"></p>
<p>在横向角度上看, 单体架构同样能将系统从技术, 功能, 职责上进行模块拆分. 横向拓展上来看, 部署多个单体副本也是个常见的需求.</p>
<p>单体系统的真正缺陷不在于拆分, 而是拆分后的隔离性与自治能力上的欠缺. 在隔离性上, 单体系统所有的代码都共享同一片进程空间, 错误的传播范围是全局性并且式难以隔离的. 自治能力的欠缺会导致在错误传播以后往往会对程序造成极大的破坏. 同时因为隔离性的不支持, 也带来了单体系统难以动态更新的问题. 并且很难优雅地支持异构(Java的native方法还是支持异构的, 所以还是支持的, 只是支持的形式不优雅).</p>
<p>但是上面列举的问题, 都不是现今微服务取代单体系统成为潮流趋势的核心原因. 最核心的原因是, 单体系统难以支持Phoenix的特性(程序动态迭代更新, 并通过不可靠的部件构建出来一个可靠的整体服务). <strong>单体架构风格潜在的观念是希望系统的每一个部件, 每一处代码都尽量可靠, 靠不出或少出缺陷来构建可靠系统</strong>. 单体系统靠高质量来保证的思路, 在小规模软件上还能运作良好, 但是规模越大, 交付一个可靠的单体系统就变得越来越具有挑战性. </p>
<p>为了允许程序出错, 为了获得隔离, 自治的能力, 可以技术异构等目标, 是继为了性能和算力之后, 让程序再次选择分布式的理由.</p>
<h2 id="SOA-面向服务架构-时代"><a href="#SOA-面向服务架构-时代" class="headerlink" title="SOA(面向服务架构)时代"></a>SOA(面向服务架构)时代</h2><blockquote>
<p>SOA 架构（Service-Oriented Architecture）</p>
<p>面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式。</p>
</blockquote>
<p>对一个大型的单体项目进行拆分, 使每个子系统都能独立部署, 运行, 更新, 开发者尝试了很多种架构</p>
<ul>
<li>烟囱式架构, 也叫信息孤岛架构, 各个模块之间没有任何的信息交互, 严格来说这个甚至不能叫做架构, 只是各个独立的子系统部署在了一起而已</li>
<li>微内核架构, 也叫插件式式架构, 在烟囱架构中, 即使是没有任何的业务往来的子系统之间也需要共享一些如人员权限, 组织等公共的主数据, 那就不妨将这些被共享的资源集中在一块, 成为一个被各个组件共同依赖的核心, 这个核心就是微内核, 具体的业务以插件的形式存在. 常用于桌面端的程序, 比如Web程序. 不过微内核架构也有它的缺陷和局限性, 微内核架构的假设是各个组件之间是相互独立的, 不可预知系统安装了哪些模块, 只是向他们提供一些公共的数据, 所有组件之间是不会有直接交互的. 我们必须找到方法既能拆分系统, 又能让子系统之间进行交互</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250730145535.png"></p>
<ul>
<li>事件驱动架构, 为了能让子系统之间交互, 我们在子系统之间提供一个事件队列管道, 子系统可以从事件管道中获取到自己的想要的也就是订阅了的事件, 同时子系统也能发布事件. 和发布订阅机制比较像. 同时每个子系统之间是独立, 高度解耦合的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/20250730150209.png"></p>
<p>在事件驱动架构之后, 软件架构发展就迎来了SOAP协议的诞生, 这个时候SOA (Service Oriented Architecture, SOA), 已经有了登上历史舞台的全部的前置条件. </p>
<p>软件架构来到了SOA时代, 许多的概念, 思想都已经能在今天的微服务中找到对应的身影了, 譬如服务之间的松散耦合, 注册, 发现, 治理, 隔离, 编排等等, 这些在今天微服务中耳熟能详的名词概念. SOA针对这些问题, 甚至是软件开发这件事情本身, 都提供了更加系统性, 更加具体的探索</p>
<ul>
<li>更具体: 体现在尽管SOA本身还属于抽象的软件架构风格, 但是实际上提供一套软件设计的基础平台</li>
<li>更系统: 是SOA的宏大理想, 终极目标是希望能总结出来一套自上而下的软件开发研究的方法论</li>
</ul>
<p>SOA在21世纪初10年间曾风靡一时, 最终还是偃旗息鼓, 沉寂下去. SOAP会被边缘化的本质原因: 过于严格的规范定义带来过度的复杂性. 而构建在SOAP基础之上的ESB, BPM, SCA, SDO等诸多上层建筑, 进一步加剧了这种复杂性. 过于精密的流程和理论也需要懂得复杂概念的专业人员才能驾驭, 它能实现多个异构代行系统之间的复杂集成交互, 却很难作为一种具有广泛普适性的软件架构风格来推广</p>
<p>经过了30年的技术进步, 软件受架构复杂性牵制越来越大, 已经离透明二字越来越远了, 这是不是忘记了我们最开始透明和简单的初心? 微服务时代, 似乎正是带着这样的自省开始的</p>
<h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><blockquote>
<p>微服务架构（Microservices）</p>
<p>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</p>
</blockquote>
<p>微服务并不是SOA的变体</p>
<blockquote>
<p>Microservices and SOA</p>
<p>This common manifestation of SOA has led some microservice advocates to reject the SOA label entirely, although others consider microservices to be one form of SOA , perhaps service orientation done right. Either way, the fact that SOA means such different things means it’s valuable to have a term that more crisply defines this architectural style</p>
<p>由于与 SOA 具有一致的表现形式，这让微服务的支持者更加迫切地拒绝再被打上 SOA 的标签，尽管有一些人坚持认为微服务就是 SOA 的一种变体形式，也许从面向服务方面这个方面来说是对的，但无论如何，SOA 与微服务都是两种不同的东西，正因如此，使用一个别的名称来简明地定义这种架构风格就显得更有必要。</p>
<p>—— Martin Fowler &#x2F; James Lewis，<a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">Microservices</a></p>
</blockquote>
<p>微服务有九个核心的业务与技术特征</p>
<ul>
<li><strong>围绕业务能力构建</strong> （Organized around Business Capability）:  也就是康威定律, 有怎么样结构, 规模, 能力的团队, 就会产出对应的结构, 规模, 能力的产品. 比如本应该归属于一个产品内的功能被划分到了不同的团队, 必然会产生大量的跨团队的沟通协作, 跨越团队边界进行协作在管理, 工作安排, 沟通上都会有更高昂的成本, 高效的团队必然会进行改进, 当团队和产品磨合稳定以后, 团队和产品就会有一致性的结构</li>
<li><strong>分散治理</strong>（Decentralized Governance）: 谁家的孩子谁来管, 服务对应的开发团队有直接对服务运行质量负责的责任, 也应该有着不受外界干预地掌控服务各方面的权力. 实际开发中并不会有高程度的技术异构, 甚至一般来说是有主语言, 微服务更加强调的是确实有必要的技术异构时, 应该有选择不统一的权力</li>
<li><strong>通过服务来实现独立自治的组件</strong>（Componentization via Services）: 通过服务这种进程外组件, 以远程调用的形式提供服务, 虽然有着更高昂的车成本, 但是这是为组件带来隔离和自治能力的必要代价</li>
<li><strong>产品化思维</strong> (Products not Projects): 避免把软件研发视作去完成某个功能, 而是要视作一种持续改进, 提升的过程. 微服务下, 要求开发团队中的每个人都有产品化思维, 关心整个产品的全部的可行性. DDD也是在这个时期提出的理念.</li>
<li><strong>数据去中心化</strong> （Decentralized Data Management）:  微服务明确体长数据应该按照领域分散管理, 更新, 维护, 存储. 如果使用中心化的存储, 所有领域必须修改和映射到同一个实体身上, 这使得不同服务之间相互影响, 丧失了独立性. 尽管在分布式中要想处理好一致性问题相当困难, 但是两害相权取其轻, 有一些必要的代价是值得付出的</li>
<li><strong>强终端弱管道</strong> (Smart Endpoint and Dumb Pipe) : 弱管道可以说是指名道姓地反对SOAP和ESB地复杂地通信机制. 认证, 事务一致性, 授权等一系列的工作, 构建在通信管道上对于一些应用程序来说是必要的, 但是对于更多的应用程序来说都是一个负担. 如果服务需要额外的通信能力, 应该在自己的Endpoint上解决, 而不是在管道上一揽子地解决</li>
<li><strong>容错性设计</strong> (Design for Failure) : 不再虚幻地追求服务永远稳定, 而是接受服务总是会出错的现实, 要求在微服务的设计中, 有自动的机制对其依赖的服务能够进行快速的故障检测, 并在持续出错的时候进行隔离, 服务恢复的时候进行重建. 如果没有容错性的设计, 系统很容易就会因为一两个服务的崩溃所带来的雪崩效应给淹没. 可靠系统完全可能由会出错的服务组成, 这也是微服务最大的价值</li>
<li><strong>演进式设计</strong> (Evolutionary Design) : 容灾性设计是允许服务出错, 演进式设计则是承认服务会报废淘汰, 一个设计良好的服务应该是能够报废的,  而不是期望能够得到永生. 系统中出现不可替代, 不可更改的服务, 不能说明这个服务有多重要, 恰恰相反, 是说明了系统设计上的脆弱性</li>
<li><strong>基础设施自动化</strong> (Infrastructure Automation) : 微服务下运维的对象比起单体架构要有数量级上的增长, 使用微服务的团队更加依赖于基础设施上的自动化</li>
</ul>
<p>微服务所带来的自由是一把双刃开锋的宝剑，当软件架构者拿起这把宝剑，一刃指向 SOA 定下的复杂技术标准，将选择的权力夺回的同一时刻，另外一刃也正朝向着自己映出冷冷的寒光。微服务时代中，软件研发本身的复杂度应该说是有所降低。一个简单服务，并不见得就会同时面临分布式中所有的问题，也就没有必要背上 SOA 那百宝袋般沉重的技术包袱。需要解决什么问题，就引入什么工具；团队熟悉什么技术，就使用什么框架。此外，像 Spring Cloud 这样的胶水式的全家桶工具集，通过一致的接口、声明和配置，进一步屏蔽了源自于具体工具、框架的复杂性，降低了在不同工具、框架之间切换的成本，所以，作为一个普通的服务开发者，作为一个“螺丝钉”式的程序员，微服务架构是友善的。可是，微服务对架构者是满满的恶意，对架构能力要求已提升到史无前例的程度，笔者在这部文档的多处反复强调过，技术架构者的第一职责就是做决策权衡，有利有弊才需要决策，有取有舍才需要权衡，如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中利弊，恐怕也就无可避免地陷入选择困难症的困境之中。</p>
<h2 id="后微服务时代"><a href="#后微服务时代" class="headerlink" title="后微服务时代"></a>后微服务时代</h2><blockquote>
<p>后微服务时代（Cloud Native）</p>
<p>从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”。</p>
</blockquote>
<p>分布式架构中出现的问题 : 注册发现, 跟踪治理, 负载均衡, 传输通信等, 这些问题从原始分布式时代就已经出现了, 只要是分布式架构就无法避免, 但是这些问题一定要软件系统来自己解决吗?</p>
<p>后微服务时代就是通过容器化和虚拟化技术, 在硬件层面实现了这些服务. </p>
<p>表 1-1 列出了在同一个分布式服务的问题在传统 Spring Cloud 中提供的应用层面的解决方案与在 Kubernetes 中提供的基础设施层面的解决方案，尽管因为各自出发点不同，解决问题的方法和效果都有所差异，但这无疑是提供了一条全新的、前途更加广阔的解题思路。</p>
<p>表 1-1 传统 Spring Cloud 与 Kubernetes 提供的解决方案对比</p>
<table>
<thead>
<tr>
<th></th>
<th>Kubernetes</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>弹性伸缩</td>
<td>Autoscaling</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>服务发现</td>
<td>KubeDNS &#x2F; CoreDNS</td>
<td>Spring Cloud Eureka</td>
</tr>
<tr>
<td>配置中心</td>
<td>ConfigMap &#x2F; Secret</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务网关</td>
<td>Ingress Controller</td>
<td>Spring Cloud Zuul</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Load Balancer</td>
<td>Spring Cloud Ribbon</td>
</tr>
<tr>
<td>服务安全</td>
<td>RBAC API</td>
<td>Spring Cloud Security</td>
</tr>
<tr>
<td>跟踪监控</td>
<td>Metrics API &#x2F; Dashboard</td>
<td>Spring Cloud Turbine</td>
</tr>
<tr>
<td>降级熔断</td>
<td>N&#x2F;A</td>
<td>Spring Cloud Hystrix</td>
</tr>
</tbody></table>
<p>一旦虚拟化的硬件跟上了软件的灵活性, 那些与业务无关的技术问题有可能从软件层面剥离, 悄无声息解决于硬件基础设施之内, 让软件只需要关注业务&#x2F;</p>
<p>但是Kurbernets并没有完美解决所有的分布式问题, 仅从功能上看k8s甚至不如之前的Spring Cloud方案. 因为有一些问题处于应用系统与基础设置的边缘, 使得很难在基础设施层上进行处理. 举个例子，微服务 A 调用了微服务 B 的两个服务，称为 B1和 B2，假设 B1表现正常但 B2出现了持续的 500 错，那在达到一定阈值之后就应该对 B2进行熔断，以避免产生<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Snowball_effect">雪崩效应</a>。如果仅在基础设施层面来处理，这会遇到一个两难问题，切断 A 到 B 的网络通路则会影响到 B1的正常调用，不切断的话则持续受 B2的错误影响。基础设施是针对整个容器来管理的，粒度相对粗旷，只能到容器层面，对单个远程服务就很难有效管控</p>
<p>为了解决这一类问题，虚拟化的基础设施很快完成了第二次进化，引入了今天被称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Service_mesh">服务网格</a>”（Service Mesh）的“边车代理模式”（Sidecar Proxy）. 系统自动在服务容器(通常是指 Kubernetes 的 Pod) 中注入一个通信代理服务器, 以类似网络安全里中间人的方式进行流量劫持, 在应用毫无感知的情况下, 悄然接管所有的对外通信. 这个代理处理实现正常的服务间通信以外 (数据平面通信), 还接收来自控制器的指令, 以实现熔断, 认证, 度量, 监控, 均衡负载等各种附加功能. 这样便实现了既不需要在应用层面加入额外的处理代码，也提供了几乎不亚于程序代码的精细管理能力</p>
<p><img src="https://icyfenix.cn/assets/img/sidecar.4174a72d.png" alt="img"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Architecture/">Architecture</a><a class="post-meta__tags" href="/tags/Distributed-Systems/">Distributed Systems</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/25/computer-fundamentals/Operating%20System/IO-%E9%9B%B6%E6%8B%B7%E8%B4%9D/" title="操作系统I/O - 零拷贝"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">操作系统I/O - 零拷贝</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O的演进DMA技术在最开始的时候, 读一个文件的过程是   用户进程调用read(), 切换到内核态, CPU向磁盘发起IO请求 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信号给CPU CPU将数据从磁盘数据控制器缓冲区中拷贝到 PageCache CPU将数据从PageCache中拷贝到用户缓冲区 read()调用返回, 切换到用户态  一共发生了两次用户态和内核态的上下文切换, 发生了两次拷贝, 并且数据的搬运也是交给CPU来操作的, 占用了大量的CPU的时间, 导致了CPU吞吐量下降 解决方式就是引入了DMA(Direct Memory Access)直接内存访问技术,  我们将把数据从磁盘控制器缓冲区搬运到PageCache的工作交给了DMA控制器来进行  现在的读一个文件的流程变成了  用户进程调用read(), 切换到内核态, 向操作系统发起IO请求, 将数据读取到自己的内存缓冲区中, 进程进入到了阻塞状态 CPU收到操作系统发送的指令以后, 将请求发送给DMA, DMA再进一步发送给磁盘 磁盘将数据放入到磁盘控制器缓冲区里面, 发送IO中断信...</div></div></div></a><a class="pagination-related" href="/2025/07/24/language/Java/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExecutor/" title="线程池-ThreadPoolExecutor类详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">线程池-ThreadPoolExecutor类详解</div></div><div class="info-2"><div class="info-item-1">线程池-ThreadPoolExecutor类详解ThreadPoolExecutor的构造方法12345678public ThreadPoolExecutor(int corePoolSize,                            int maximumPoolSize,                            long keepAliveTime,                            TimeUnit unit,                            BlockingQueue&lt;Runnable&gt; workQueue) &#123;    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,            Executors.defaultThreadFactory(), defaultHandler);&#125;  corePoolSize: 核心线程数, 线程池中即使没有任务也要保持存活的最大线程数量 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/01/project/Architecture/%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" title="分布式架构-远程服务调用 (RPC)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-01</div><div class="info-item-2">分布式架构-远程服务调用 (RPC)</div></div><div class="info-2"><div class="info-item-1">远程服务调用 (RPC) 参考: 主要是基于凤凰架构改动, 推荐阅读原文 ​	凤凰架构: 远程服务调用  进程间通信RPC最初出现的时候, 是希望能提供一种像调用本地方法一样调用远程方法的技术, 虽然现在已经不是这样了, 但至少它的初心是这样的 我们是怎么调用一个本地方法的? 12345678// Caller : 方法的调用者, 也就是程序中的main函数// Callee : 被调用的方法, 也就是程序中的println()// Call Site : 调用点, 也就是发生方法调用的指令的位置// Parameter : 参数, 也就是hello world// Retval : 返回值, 由Callee传给Caller的数据public static void main(String[] args) &#123;    System.out.println(&quot;hello world!&quot;);&#125;  完成这样的以一个方法的整体的流程是  传递方法参数: 将方法的参数入栈,将hello world的引用地址入栈 确定方法的版本: 根据println()...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117002.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Function</div><div class="author-info-description">Function的个人博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fang-tech"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%94%E8%BF%9B%E4%B8%AD%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">演进中的架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E4%BB%A3"><span class="toc-number">1.1.</span> <span class="toc-text">原始分布式时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.</span> <span class="toc-text">单体系统时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOA-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-%E6%97%B6%E4%BB%A3"><span class="toc-number">1.3.</span> <span class="toc-text">SOA(面向服务架构)时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3"><span class="toc-number">1.4.</span> <span class="toc-text">微服务时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3"><span class="toc-number">1.5.</span> <span class="toc-text">后微服务时代</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/09/computer-fundamentals/Operating%20System/Linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统内存管理 - Linux物理内存篇">操作系统内存管理 - Linux物理内存篇</a><time datetime="2025-08-09T03:10:20.000Z" title="发表于 2025-08-09 11:10:20">2025-08-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/04/computer-fundamentals/Operating%20System/Linux%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98(%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AF%87)/" title="操作系统内存管理 - Linux虚拟内存篇">操作系统内存管理 - Linux虚拟内存篇</a><time datetime="2025-08-04T05:16:26.000Z" title="发表于 2025-08-04 13:16:26">2025-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/02/computer-fundamentals/Network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="深入理解三次握手的实现原理">深入理解三次握手的实现原理</a><time datetime="2025-08-02T05:33:20.000Z" title="发表于 2025-08-02 13:33:20">2025-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/01/project/Architecture/%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1/REST/" title="无标题">无标题</a><time datetime="2025-08-01T09:56:46.412Z" title="发表于 2025-08-01 17:56:46">2025-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/01/project/Architecture/%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" title="分布式架构-远程服务调用 (RPC)">分布式架构-远程服务调用 (RPC)</a><time datetime="2025-08-01T08:40:26.000Z" title="发表于 2025-08-01 16:40:26">2025-08-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/fang-tech/Pic/img/202507101117129.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Function</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"lang":"zh-CN","input_position":"top","emit_metadata":1,"reactions_enabled":1}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'fang-tech/fang-tech.github.io',
      'data-repo-id': 'R_kgDOPJD8XA',
      'data-category-id': 'DIC_kwDOPJD8XM4CswtE',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>