[{"title":"Binary Sort-二分查找","url":"/2025/07/10/Algorithm/Binary%20Search/","content":"二分查找典型特征\n原数组是有序的, 或者改变原数组顺序不影响答案\n我们要找出来一个数字在数组中的位置(标准二分查找题目)\n\n一般化特征\n我们能一次性排除解空间中的一半解\n我们要找出来解空间中的某一个解的位置\n\n解题通法-红蓝染色法我们能将数组依照单调性分成两部分, 以我们要找出target为例\nnum &gt;&#x3D; target的部分染成蓝色, num &lt; target为红色, 我们需要染色的区间是[left, right]或者(left-1, right+1)…\n\n[left, right]要染色的区间的含义就是我们现在没有染色也就是不知道其中的元素和target之间的关系\n\n循环不变量(以两端闭区间举例)\n\nleft - 1始终是红色\nright + 1始终是蓝色\n\n思考顺序\n首先确定我们怎么确定答案, 这种方式一定是要利用原数组在找到答案方面的单调性, 我们一定能一次性排除一半的解空间\n确定下来红蓝染色情况\n确定下来没有染色区间的开闭选择(一般是双开区间)\n\n典型例题及实现找到第一个大于等于target的值\n闭区间private int lower_bound(int[] nums, int target) &#123;    int left = 0;    int right = nums.length - 1;    // [left, right], left == right + 1 区间为空    // left - 1始终 &lt; target    // right + 1始终 &gt;= target    while (left &lt; right + 1) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target)             left = mid + 1;        else             right = mid - 1;    &#125;    return right + 1;&#125;\n\n开区间private int lower_bound(int[] nums, int target) &#123;    int left = -1;    int right = nums.length;    // (left, right), left + 1 == right 区间为空    // left 始终 &lt; target    // right 始终 &gt;= target    while (left + 1 &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target)             left = mid;        else             right = mid;    &#125;    return right;&#125;\n\n左开右闭private int lower_bound(int[] nums, int target) &#123;    int left = -1;    int right = nums.length - 1;    // (left, right], left == right 区间为空    // left 始终 &lt; target    // right + 1始终 &gt;= target    while (left &lt; right) &#123;        int mid = left + (right - left + 1) / 2;        if (nums[mid] &lt; target)             left = mid;        else             right = mid - 1;    &#125;    return right + 1;&#125;\n\n这里会有个额外的问题是mid向下取整, 会在left &#x3D; -1, right &#x3D; 0的时候取到-1, 所以我们需要调整成向上取整, 在left &#x3D; -1, right &#x3D; 0的时候取整到0, 就会不落到区间外面了\n左闭右开private int lower_bound(int[] nums, int target) &#123;    int left = 0;    int right = nums.length;    // [left, right), left == right 区间为空    // left - 1始终 &lt; target    // right 始终 &gt;= target    while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target)             left = mid + 1;        else             right = mid;    &#125;    return right;&#125;\n\n参考链接灵茶山艾府-红蓝染色法\n","categories":["Algorithm","Binary sort"],"tags":["Algorithm","Binary Sort"]},{"title":"Spring AI 测试文件","url":"/2025/07/10/Spring/Spring%20AI/Spring%20AI-test/","content":"Spring AI 测试文件\n","tags":["Spring AI"]},{"title":"Spring AI 测试文件","url":"/2025/07/10/Java/JUC/JUC%20test/","content":"JUC测试文件\n","tags":["JUC"]}]