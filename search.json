[{"title":"Binary Sort-二分查找","url":"/2025/07/10/Algorithm/Binary%20Search/","content":"二分查找典型特征\n原数组是有序的, 或者改变原数组顺序不影响答案\n我们要找出来一个数字在数组中的位置(标准二分查找题目)\n\n一般化特征\n我们能一次性排除解空间中的一半解\n我们要找出来解空间中的某一个解的位置\n\n解题通法-红蓝染色法我们能将数组依照单调性分成两部分, 以我们要找出target为例\nnum &gt;&#x3D; target的部分染成蓝色, num &lt; target为红色, 我们需要染色的区间是[left, right]或者(left-1, right+1)…\n\n[left, right]要染色的区间的含义就是我们现在没有染色也就是不知道其中的元素和target之间的关系\n\n循环不变量(以两端闭区间举例)\n\nleft - 1始终是红色\nright + 1始终是蓝色\n\n思考顺序\n首先确定我们怎么确定答案, 这种方式一定是要利用原数组在找到答案方面的单调性, 我们一定能一次性排除一半的解空间\n确定下来红蓝染色情况\n确定下来没有染色区间的开闭选择(一般是双开区间)\n\n典型例题及实现找到第一个大于等于target的值\n闭区间private int lower_bound(int[] nums, int target) &#123;    int left = 0;    int right = nums.length - 1;    // [left, right], left == right + 1 区间为空    // left - 1始终 &lt; target    // right + 1始终 &gt;= target    while (left &lt; right + 1) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target)             left = mid + 1;        else             right = mid - 1;    &#125;    return right + 1;&#125;\n\n开区间private int lower_bound(int[] nums, int target) &#123;    int left = -1;    int right = nums.length;    // (left, right), left + 1 == right 区间为空    // left 始终 &lt; target    // right 始终 &gt;= target    while (left + 1 &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target)             left = mid;        else             right = mid;    &#125;    return right;&#125;\n\n左开右闭private int lower_bound(int[] nums, int target) &#123;    int left = -1;    int right = nums.length - 1;    // (left, right], left == right 区间为空    // left 始终 &lt; target    // right + 1始终 &gt;= target    while (left &lt; right) &#123;        int mid = left + (right - left + 1) / 2;        if (nums[mid] &lt; target)             left = mid;        else             right = mid - 1;    &#125;    return right + 1;&#125;\n\n这里会有个额外的问题是mid向下取整, 会在left &#x3D; -1, right &#x3D; 0的时候取到-1, 所以我们需要调整成向上取整, 在left &#x3D; -1, right &#x3D; 0的时候取整到0, 就会不落到区间外面了\n左闭右开private int lower_bound(int[] nums, int target) &#123;    int left = 0;    int right = nums.length;    // [left, right), left == right 区间为空    // left - 1始终 &lt; target    // right 始终 &gt;= target    while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target)             left = mid + 1;        else             right = mid;    &#125;    return right;&#125;\n\n题单典型题目35. 搜索插入位置\n74. 搜索二维矩阵\n34. 在排序数组中查找元素的第一个和最后一个位置\n非典型题目33. 搜索旋转排序数组\n153. 寻找旋转排序数组中的最小值\n参考链接灵茶山艾府-红蓝染色法\n","categories":["Algorithm","Binary sort"],"tags":["Algorithm","Binary Sort"]},{"title":"Java Colletion-集合框架面试问题","url":"/2025/07/10/Interview/Java%20Collection/","content":"&#x2F;&#x2F; TODO\n","categories":["Interview","Java","Collection"],"tags":["Java","Interview","Collection"]},{"title":"Java基础面试问题","url":"/2025/07/10/Interview/Java%20Base/","content":"Java基础a &#x3D; a + b 与 a +&#x3D; b 的区别+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。\nbyte a = 127;byte b = 127;b = a + b; // error : cannot convert from int to byteb += a; // ok\n\n(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)\n为什么需要泛型？适用于多种数据类型执行相同的代码\n引入泛型，它将提供类型的约束，提供编译前的检查\n泛型方法泛型方法创建\n\n泛型方法使用\n\n泛型方法创建的时候需要使用&lt;T&gt;来声明这是一个泛型方法, 在传入的参数中需要有Class&lt;T&gt; c参数来指明传入的参数的类型, 然后在方法中通过反射newInstance方法来创建一个新的对象\n使用泛型方法的时候, 可以通过Class.forName(“全限定类名”)来获取Class类\n泛型的上限和下限？在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\n上限\nclass Info&lt;T extends Number&gt;&#123;    // 此处泛型只能是数字类型\n\n下限\npublicstaticvoidfun(Info&lt;? super String&gt; temp)&#123;// 只能接收String或Object类型的泛型，String类的父类只有Object类System.out.print(temp +&quot;, &quot;);&#125;\n\n如何理解Java中的泛型是伪泛型？泛型中类型擦除 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型, 同时这里是会擦除成下限类型），就像完全没有泛型一样。\n注解元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented\n\n@Retention用于标明注解被保留的阶段\n@Target用于标明注解使用的范围\n@Inherited用于标明注解可继承\n\nJava异常类层次结构?\nThrowable\n 是 Java 语言中所有错误与异常的超类。 \n\nError 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\nException 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。\n\n\n\n\n\n运行时异常\n\n都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。\n\n非运行时异常 （编译异常）\n\n是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。\n可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）区别？\n可查异常（编译器要求必须处置的异常）：\n\n正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。\n除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\n\n不可查异常(编译器不要求强制处置的异常)\n\n包括运行时异常（RuntimeException与其子类）和错误（Error）\n什么是SPI机制？SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。\nSPI整体机制图如下：\n\n当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。\nSPI机制的应用？\nSPI机制 - JDBC DriverManager\n\n在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName(“com.mysql.jdbc.Driver”)这句先加载数据库相关的驱动，然后再进行获取连接等的操作。而JDBC4.0之后不需要用Class.forName(“com.mysql.jdbc.Driver”)来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现。\n\nJDBC接口定义\n\n首先在java中定义了接口java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。\n\nmysql实现\n\n在mysql的jar包mysql-connector-java-6.0.6.jar中，可以找到META-INF/services目录，该目录下会有一个名字为java.sql.Driver的文件，文件内容是com.mysql.cj.jdbc.Driver，这里面的内容就是针对Java中定义的接口的实现。\n\npostgresql实现\n\n同样在postgresql的jar包postgresql-42.0.0.jar中，也可以找到同样的配置文件，文件内容是org.postgresql.Driver，这是postgresql对Java的java.sql.Driver的实现。\n\n使用方法\n\n上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用Class.forName(&quot;com.mysql.jdbc.Driver&quot;)来加载驱动了，而是直接使用如下代码：\nString url = &quot;jdbc:xxxx://xxxx:xxxx/xxxx&quot;;Connection conn = DriverManager.getConnection(url,username,password);.....","categories":["Interview","Java","JavaBase"],"tags":["Java","Interview","JavaBase"]},{"title":"Java JUC-并发编程面试问题","url":"/2025/07/11/Interview/Java%20JUC/","content":"并发编程问题\n","categories":["Interview","Java","JUC"]},{"title":"MySQL 锁机制","url":"/2025/07/16/MiddleWare/MySQL/MySQl%20%E9%94%81/","content":"\n参考:\n\nhttps://relph1119.github.io/mysql-learning-notes/#/mysql/25-%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81 \nhttps://xiaolincoding.com/mysql/lock/how_to_lock.html\n\n\nMySQL锁机制详解快照读与锁定读MySQL中读可以分作两类\n\n快照读: 也就是普通的select, 读-读场景不需要额外的机制保证并发安全, 而读-写场景通过MVCC来实现隔离级别\n锁定读: 会加锁的读, 是select ... for update或者select ... lock in share mode , 在MySQL中update, delete操作会分成两部分, 读取阶段和写入(删除)阶段, 前一阶段就属于锁定读\n\n共享锁(S)和互斥锁(X)共享锁: 如果一个事务给一个表(记录)加了S锁, 其他事务能再获取这个S锁, 但是该事务和其他事务都不能再获取这个表(记录)的X锁\n互斥锁: 独占锁, 如果有一个事务给一个表(记录)加了X锁, 其他事务不能再从这个表(记录)上获取锁了(无论XS), 同时也不能给已经上锁了的表(记录)加上X锁\n\n\n\n兼容性\n共享锁S\n互斥锁X\n\n\n\n共享锁S\n兼容\n不兼容\n\n\n互斥锁X\n不兼容\n不兼容\n\n\n类似于读-读并发安全, 所以不需要额外处理, 也就是S锁能兼容, 其他的情况都存在并发安全问题, 所以不能兼容\n表锁表级锁锁上整张表的锁, 分有X和S两种\n什么时候会加上表级锁: MySQL InnoDB引擎中因为有更细粒度的行级锁, 所以其实表级锁应用场景极其有限(没啥用)\n但是现在有个问题就是, 如果我们要对某个表加X锁或者S锁, 有个问题就是, 我们需要确保现在这个表是没有不兼容的行锁的\n\n我们要加上表级S锁的时候, 就需要保证表内没有X锁\n我们要加上表级X锁的时候, 就需要保证表内没有锁\n\n这种时候很明显我们不能遍历每行来看是不是有加锁, Innodb引入了意向锁的机制\n意向锁IS锁: 共享意向锁, IX锁: 互斥意向锁\n什么时候会加上意向锁: 现在在加锁前, 我们会现在表级上加上一个意向锁, 比如我们要加上一个互斥X锁, 我们就会先在表上加一把IX, IS同理\n在有了意向锁以后, 我们就能通过判断表上有没有持有IS和IX锁来快速判断现在我们能不能加表锁\nIS, IX是表级锁, 它们的出现仅仅是为了在之后加表级锁的时候快速判断表中是不是存在加锁的记录, IS锁和IS锁之间是兼容的,  IX和IX之间是兼容的\n\n\n\n兼容性\nX\nIX\nS\nIS\n\n\n\nX\n不兼容\n不兼容\n不兼容\n不兼容\n\n\nIX\n不兼容\n兼容 兼容的\n不兼容\n兼容 兼容的\n\n\nS\n不兼容\n不兼容\n兼容 兼容的\n兼容 兼容的\n\n\nIS\n不兼容\n兼容 兼容的\n兼容 兼容的\n兼容 兼容的\n\n\nMDL锁Meta Data Lock: 元数据锁, 是针对DDL操作的锁, 防止在存在事务还在执行的时候变更表结构\n什么时候会加上MDL: \n\n对一张表CRUD的时候, 加上MDL读锁\n修改表结构的时候, 加上MDL写锁\n\nMDL写锁的获取会阻塞MDL读锁的获取, 也就是如果有一个事务在修改表结构获取MDL写锁的时候阻塞了, 后续的CRUD操作都会被阻塞住\nMDL在事务提交后才会释放\nAUTO-INC锁是用于处理AUTO_INCREAMENT自增字段的自增的锁, 如果并发地向一张表中插入记录, 就可能会导致自增字段值重复\n有两种锁来解决并发自增问题\n\nAUTO-INC锁: 在执行插入语句的时候, 会加上一个表级的AUTO_INC锁, 然后分配自增属性的值, 在插入语句执行结束后将锁释放掉, 以此将插入时生成自增值串行化\n轻量级锁: 在执行插入语句的时候, 获取这个轻量级锁, 在生成自增属性的值以后就将锁释放掉\n\n如果我们的插入语句在执行前就知道要插入多少条数据, 就会采用轻量级锁\n\nTIP：设计InnoDB的大佬提供了一个称之为innodb_autoinc_lock_mode的系统变量来控制到底使用上述两种方式中的哪种来为AUTO_INCREMENT修饰的列进行赋值，当innodb_autoinc_lock_mode值为0时，一律采用AUTO-INC锁；当innodb_autoinc_lock_mode值为2时，一律采用轻量级锁；当innodb_autoinc_lock_mode值为1时，两种方式混着来（也就是在插入记录数量确定时采用轻量级锁，不确定时使用AUTO-INC锁）。不过当innodb_autoinc_lock_mode值为2时，可能会造成不同事务中的插入语句为AUTO_INCREMENT修饰的列生成的值是交叉的，在有主从复制的场景中是不安全的。\n\n行锁行锁在MySQL中是InnoDB独有的更加细粒度的锁\n记录锁Record Lock: 记录锁, 有S锁和X锁之分, 是针对一条记录上加的锁, 也就是对某一行加上的锁\n什么时候加锁: 在执行锁定读的时候会对遍历到的行加上, 往往是以next-key lock的组成部分的形式被加上\n间隙锁Gap Loc: 间隙锁, 有S锁和X锁, 但是没有分别, 实际上是都是S锁的行为, 多个事务可同时获取一个间隙的Gap Lock, 是对一个开区间的锁, 用于解决可重复读隔离级别下的幻读现象的\n\n在id范围(3, 5)的间隙锁以后, 其他事务就无法再插入id &#x3D;4的记录了\n什么时候加锁: 和记录锁是一样的, 执行锁定读的时候会对遍历到的行加上, 往往是以next-key lock的组成部分的形式被加上\nNext-Key LockNext-Key Lock &#x3D; Record Lock + Gap Lock, 锁定一个范围, 并且锁定记录本身\n因为Next-Key Lock是包含Record Lock的, 所以是分X锁和S锁的\n插入意向锁是在insert前会对某个记录加上锁, 用于提高插入的并发效率, 只要插入位置不同, 想插入的事务间不会相互阻塞, 只有当多个事务尝试插入相同位置时才会产生冲突\n什么时候加锁: 在执行插入操作的时候需要判断这个位置上有没有间隙锁, 如果有, 插入操作就会被阻塞, 然后生成一个插入意向锁(is_wait &#x3D; true), 在这个间隙锁被释放掉以后, 插入意向锁就会被真正获取到, 执行插入操作\n有插入意向锁（当前机制）：\ncss复制索引：[1] [4] [7] [10]事务A：INSERT 5  → 在(4,7)设置插入意向锁事务B：INSERT 6  → 在(4,7)设置插入意向锁结果：两个事务可以并发执行 ✓\n\n没有插入意向锁（假设情况）：\ncss复制索引：[1] [4] [7] [10]事务A：INSERT 5  → 在(4,7)设置间隙锁事务B：INSERT 6  → 等待事务A释放间隙锁结果：事务B被阻塞，必须等待 ✗\n","categories":["Middleware","MySQL","Lock"]},{"title":"Spring AI 测试文件","url":"/2025/07/10/Spring/Spring%20AI/Spring%20AI-test/","content":"Spring AI 测试文件\n","categories":["Spring","Spring AI"],"tags":["Spring AI"]},{"title":"Spring AI 测试文件","url":"/2025/07/10/Java/JUC/JUC%20test/","content":"JUC测试文件\n","tags":["JUC"]}]